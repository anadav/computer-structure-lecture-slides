\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{bytefield}
\usepackage{tikz}
\usepackage[american]{circuitikz}
\usepackage{listings}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, backgrounds}
\usetheme{Madrid}
\lstset{
    escapeinside={@}{@},
    basicstyle=\ttfamily\small
}

\newcommand{\drawPipelineDiagram}[1][0,0]{%
    \scalebox{0.85}{%
    \begin{tikzpicture}[shift={(#1)},
        component/.style={draw, thick, minimum height=0.8cm},
        latch/.style={draw, thick, fill=yellow!20, minimum width=0.2cm, minimum height=4cm},
        stage/.style={font=\bfseries},
        label/.style={font=\tiny},
        port/.style={font=\tiny, inner sep=0.035cm},
        % Define styles for adder and muxes
        adder/.style={muxdemux, muxdemux def={Lh=4, NL=2, Rh=2, NR=1, NB=1, w=1.5, inset w=0.5, inset Lh=2, inset Rh=1.5}, 
                      external pins width=0, scale=0.4, fill=blue!15},
        greenmux/.style={muxdemux, muxdemux def={Lh=4, Rh=2, NL=2, NR=1, NB=0, NT=0, w=1}, 
                         external pins width=0, scale=0.6, fill=green!20},
        bluemux/.style={muxdemux, muxdemux def={Lh=2, Rh=4, NL=1, NR=2, NB=1, w=1}, 
                        external pins width=0, scale=0.6, fill=blue!20}
    ]
        % Define origin node for relative positioning
        \coordinate (origin) at (0,0);
        
        % Pipeline latches - positioned relative to origin with equal spacing
        \node[latch] (L1) at ([shift={(3,2)}]origin) {};
        \node[latch] (L2) at ([shift={(3,0)}]L1) {};
        \node[latch] (L3) at ([shift={(3,0)}]L2) {};
        \node[latch] (L4) at ([shift={(3,0)}]L3) {};
        
        % Stage labels - positioned at midpoints between latches
        \node[stage] at ([yshift=4cm]$(origin |- L1)!0.5!(L1)$) {Fetch};
        \node[stage] at ([yshift=4cm]$(L1)!0.5!(L2)$) {Decode};
        \node[stage] at ([yshift=4cm]$(L2)!0.5!(L3)$) {Execute};
        \node[stage] at ([yshift=4cm]$(L3)!0.5!(L4)$) {Memory};
        \node[stage] at ([yshift=4cm]$(L4.east) + (1.5,0)$) {WB};
        
        % Fetch Stage
        % PC MUX - blue mux should have right side wide (inputs), left side narrow (output)
        \node[bluemux] (pcmux) at ($(origin) + (0.3,4.5)$) {};
        \node[font=\tiny] at (pcmux.center) {};
        
        % Define PC MUX coordinates for compatibility
        \coordinate (pcmux_in1) at (pcmux.brpin 1);
        \coordinate (pcmux_in2) at (pcmux.brpin 2);
        \coordinate (pcmux_out) at (pcmux.blpin 1);
        \coordinate (pcmux_selectorup) at (pcmux.bbpin 1);

        % PC - positioned relative to L1
        \node[component, fill=blue!20, minimum width=0.6cm, minimum height=0.6cm] (PC) at ([xshift=-2.5cm, yshift=0]L1.center) {\small PC};

        % ICache - positioned relative to L1
        \node[component, fill=purple!20, minimum width=1.2cm, minimum height=2cm] (ICache) at ([xshift=-1cm, yshift=0]L1.center) {};
        \node[align=center] at ([yshift=0.6cm]ICache.center) {\footnotesize inst.\\[-0.14cm]\footnotesize cache};
 
        % PC adder using circuitikz with one bit adder style
        \node[adder] (fe_adder) at ($(PC.center) + (0.7,1.8)$) {};
        \node[font=\tiny] at (fe_adder.center) {+};
        \coordinate (fe_adder_input1) at (fe_adder.blpin 1);
        \coordinate (fe_adder_input2) at (fe_adder.blpin 2);
        \coordinate (fe_adder_output) at (fe_adder.brpin 1);
        \node[left, font=\tiny] (four) at ([xshift=-0.2cm]fe_adder_input1) {4};
        
        % Decode Stage - positioned between L1 and L2, with vertical offset
        \node[component, fill=pink!30, minimum width=1.2cm, minimum height=1.8cm] (RF) at ($(L1.east)!0.5!(L2.west) + (0,0.41)$) {};
        \node[align=center] at ([yshift=-0.35cm]RF.north) {\footnotesize register\\[-0.11cm]\footnotesize file};
        
        % Register file input ports (left side, inside the box)
        \node[port] (rf_src1) at ([xshift=-0.4cm, yshift=0.1cm]RF.center) {~src1};
        \node[port] (rf_src2) at ([xshift=-0.4cm, yshift=-0.3cm]RF.center) {~src2};
        \node[port] (rf_dst) at ([xshift=-0.35cm, yshift=-0.7cm]RF.center) {dst};
        
        % Register file selector coordinate (slightly left of dst)
        \coordinate (rf_selector) at ([xshift=-0.1cm]rf_dst.south);
        
        % Register file output ports (right side, aligned to right edge)
        \node[port, anchor=east] (rf_src1_data) at ([xshift=0.6cm, yshift=0.07cm]RF.center) {src1};
        \node[port, anchor=east] (rf_data1) at ([yshift=-0.15cm]rf_src1_data.east) {data};
        \node[port, anchor=east] (rf_src2_data) at ([xshift=0.6cm, yshift=-0.37cm]RF.center) {src2};
        \node[port, anchor=east] (rf_data2) at ([yshift=-0.15cm]rf_src2_data.east) {data};
        
        % Sign extension - positioned relative to register file  
        \node[component, fill=green!20, ellipse, minimum width=0.4cm, minimum height=0.3cm, align=center] (SignExt) at ([xshift=0.6cm, yshift=-1.5cm]RF.center) {
            \scriptsize sign\\[-0.25cm]\scriptsize ext.
        };
        
        % Execute Stage
        % Execute adder using circuitikz with one bit adder style
        \node[adder] (ex_adder) at ($(L2.east)!0.5!(L3.west) + (0,1.56)$) {};
        \node[font=\tiny] at (ex_adder.center) {+};
        \coordinate (ex_adder_input1) at (ex_adder.blpin 1);
        \coordinate (ex_adder_input2) at (ex_adder.blpin 2);
        \coordinate (ex_adder_output) at (ex_adder.brpin 1);
        
        % Execute stage ALU source MUX - green mux should have left side wide (inputs), right side narrow (output)
        \node[greenmux] (exemux) at ($(L2.east)!0.5!(L3.west) + (0,-0.32)$) {};
        \node[font=\tiny] at (exemux.center) {};
        \coordinate (exemux_in1) at (exemux.blpin 1);
        \coordinate (exemux_in2) at (exemux.blpin 2);
        \coordinate (exemux_out) at (exemux.brpin 1);
        
        % ALU using circuitikz ALU style
        \node[muxdemux, muxdemux def={Lh=5, NL=2, Rh=2, NR=1, NB=2, NT=1, w=2, inset w=1, inset Lh=2, inset Rh=0, square pins=1},
              external pins width = 0, scale=0.5, fill=green!15] (ALU) at ($(L2.east)!0.65!(L3.west) + (0,0)$) {};
        \node[rotate=90, font=\tiny] at (ALU.center) {ALU};
        \coordinate (alu_input1) at (ALU.blpin 1);
        \coordinate (alu_input2) at (ALU.blpin 2);
        \coordinate (alu_output) at (ALU.brpin 1);
        
        % Memory Stage - positioned relative to L4
        \node[component, fill=brown!20, minimum width=1.2cm, minimum height=2cm] (DCache) at ([xshift=-1.5cm, yshift=0]L4.center) {};
        \node[align=center] at ([yshift=0.6cm]DCache.center) {\footnotesize data\\[-0.14cm]\footnotesize cache};

        % Data Cache ports (aligned to left side of box)
        \node[port, anchor=west] (dc_addr) at ([xshift=-0.62cm, yshift=0cm]DCache.center) {address};
        \node[port, anchor=west] (dc_data) at ([xshift=-0.62cm, yshift=-0.7cm]DCache.center) {data};

        % DCache output port
        \node[port, anchor=east] (dc_data_out) at ([xshift=0.65cm, yshift=0cm]DCache.center){};
        
        % Write Back Stage MUX - green mux should have left side wide (inputs), right side narrow (output)
        \node[greenmux] (wbmux) at ($(L4.east) + (0.8,-0.21)$) {};
        \node[font=\tiny] at (wbmux.center) {};
        \coordinate (wbmux_in1) at (wbmux.blpin 1);
        \coordinate (wbmux_in2) at (wbmux.blpin 2);
        \coordinate (wbmux_out) at (wbmux.brpin 1);
        
        % Main data path connections
        \draw[blue, thick, ->] (four) -- (fe_adder_input1);
        \draw[blue, thick, ->] (pcmux_out) -- ++(-0.4,0) |- (PC.west);
        \draw[blue, thick, ->] (PC.east) -- (ICache);
        \draw[blue, thick, ->] (PC.east) -- ++(0.1,0) |- (fe_adder_input2);
        \draw[->] (ICache) -- (L1);

        \draw[blue, thick, ->] (fe_adder_output) -- (fe_adder_output -| L1.west);
        \draw[blue, thick, ->] (fe_adder_output) -- ++(0.3,0) |- (pcmux_in1);
        \draw[blue, thick, ->] (fe_adder_output -| L1.east) -- (fe_adder_output -| L2.west);
        \draw[blue, thick, ->] (fe_adder_output -| L2.east) -- ++(0.3,0) |- (ex_adder_input1);
        
        % From L1 to Register File inputs
        \draw[->] (L1.east) -- ++(0.3,0) |- (rf_src1.west);
        \draw[->] (L1.east) -- ++(0.3,0) |- (rf_src2.west);
        \draw[->] (L1.east) -- ++(0.3,0) |- (SignExt.west);

        \draw[->] (L1.east) -- ++(0.3,0) |- ([yshift=-0.8cm]SignExt -| L2.west);
        \draw[->] ([yshift=-0.8cm]SignExt -| L2.east) -- ([yshift=-0.8cm]SignExt -| L3.west);
        \draw[->] ([yshift=-0.8cm]SignExt -| L3.east) -- ([yshift=-0.8cm]SignExt -| L4.west);
        \draw[->] ([yshift=-0.8cm]SignExt -| L4.east) -- ++(0.3, 0) -- ++(0, -0.2) -| (rf_dst.south);

        % From L1 for "instruction" title
        \draw[->] (ICache -| L1.east) -- ++(0.3,0) node[yshift=0.55cm,rotate=90,above] {\tiny{}instruction}; 

        % From Register File outputs to L2
        \draw[green, thick, ->] ([yshift=-0.01cm]rf_data1.east) -- ([yshift=-0.01cm]rf_data1.east -| L2.west);
        \draw[green, thick, ->] (rf_data2.east) -- (rf_data2.east -| L2.west);
        \draw[green, thick, ->] (SignExt.east) -- (SignExt.east -| L2.west);
        
        % From L2 to Execute components
        \draw[green, thick, ->] ([yshift=-0.01cm]rf_data1.east -| L2.east) -- ++(0.2,0) |- (alu_input1);
        \draw[green, thick, ->] (rf_data2.east -| L2.east) -- (exemux_in1);
        \draw[green, thick, ->] (SignExt.east -| L2.east) -- ++(0.3,0) |- (exemux_in2);
        \draw[green, thick, ->] (SignExt.east -| L2.east) -- ++(0.3,0) |- (ex_adder_input2);
        
        % MUX to ALU
        \draw[green, thick, ->] (exemux_out) -- ++(0.3,0) |- (alu_input2);
        
        % ALU and adder to L3
        \draw[green, thick, ->] (alu_output) -- (L3.west |- alu_output);
        \draw[blue, thick, ->] (ex_adder_output) -- (L3.west |- ex_adder_output);
        \draw[blue, thick, ->] (L3.east |- ex_adder_output) -- ++(0.25,0) |- (pcmux_in2);
        
        % L3 to Memory and from
        \draw[green, thick, ->] (alu_output -| L3.east) -- (dc_addr.west);
        \draw[green, thick, ->] (dc_data.east -| L3.east) -- (dc_data.west);
        \draw[green, thick, ->] (dc_data.east -| L3.east) -- ++(0.3,0) |- ([yshift=-1.3cm]L4.west);
        \draw[green, thick, ->] (dc_data_out) -- (dc_data_out -| L4.west);
        
        % L4 to WB mux - ALU result and memory data
        \draw[green, thick, ->] (alu_output -| L4.east) -- (wbmux_in1);
        \draw[green, thick, ->] ([yshift=-1.3cm]L4.east) -- ++(0.3,0) |- (wbmux_in2);
        
        % Write back path from mux output
        \draw[green, thick, ->] (wbmux_out) -- ++(0.3,0) -- ++(0,-2.2) -| (rf_selector);
        
        % PC MUX inputs: branch target from L3
        \draw[orange!70, thick, ->] (alu_output -| L3.east) -- ++(0.35,0) -- ++(0,3.3) -| (pcmux_selectorup);
        
    \end{tikzpicture}
    }%
}

% Define macro for placing MUX with configurable location, rotation, and fill color
% Usage: \placeMux[rotation]{x,y}{prefix}{fill color}
% rotation: angle in degrees (default 0)
% x,y: position
% prefix: name prefix for coordinates
% fill color: color for the mux (e.g., blue!20)
\newcommand{\placeMux}[4][0]{%
    \node[trapezium, trapezium left angle=70, trapezium right angle=70,
          trapezium stretches=true, minimum height=0.3cm, minimum width=1cm,
          draw, thick, fill=#4, rotate=#1] (#3mux) at (#2) {};
    
    % Define input/output coordinates based on rotation only
    % For trapezoid: unrotated has narrow left, wide right
    % Inputs should be on the wide side, output on narrow side
    \ifnum#1=90
        % Rotation 90: narrow side moves to bottom, wide side to top
        % So output should be on south (narrow), inputs on north (wide)
        \coordinate (#3mux_in1) at ([yshift=-0.2cm]#3mux.south);
        \coordinate (#3mux_in2) at ([yshift=0.2cm]#3mux.south);
        \coordinate (#3mux_out) at (#3mux.north);
        % Selector positions
        \coordinate (#3mux_selectorup) at (#3mux.east);
        \coordinate (#3mux_selectordown) at (#3mux.west);
    \else\ifnum#1=180
        % Rotation 180: narrow side moves to right, wide side to left
        % So output on east (narrow), inputs on west (wide)
        \coordinate (#3mux_in1) at ([yshift=0.2cm]#3mux.west);
        \coordinate (#3mux_in2) at ([yshift=-0.2cm]#3mux.west);
        \coordinate (#3mux_out) at (#3mux.east);
        % Selector positions
        \coordinate (#3mux_selectorup) at (#3mux.south);
        \coordinate (#3mux_selectordown) at (#3mux.north);
   \else\ifnum#1=270
        % Rotation 270: narrow side moves to top, wide side to bottom
        % So output on north (narrow), inputs on south (wide)
        \coordinate (#3mux_in1) at ([yshift=0.2cm]#3mux.south);
        \coordinate (#3mux_in2) at ([yshift=-0.2cm]#3mux.south);
        \coordinate (#3mux_out) at (#3mux.north);
        % Selector positions
        \coordinate (#3mux_selectorup) at (#3mux.west);
        \coordinate (#3mux_selectordown) at (#3mux.east);
    \else
        % Default (0 degrees): narrow left, wide right
        % Output on west (narrow), inputs on east (wide)
        \coordinate (#3mux_in1) at ([yshift=0.2cm]#3mux.east);
        \coordinate (#3mux_in2) at ([yshift=-0.2cm]#3mux.east);
        \coordinate (#3mux_out) at (#3mux.west);
        % Selector positions
        \coordinate (#3mux_selectorup) at (#3mux.north);
        \coordinate (#3mux_selectordown) at (#3mux.south);
    \fi\fi\fi
}

\title{Computer Structure}
\subtitle{Pipeline}
\author{Lihu Rappoport}
\date{}

\begin{document}

\frame{\titlepage}




%% Slide: A Basic Processor
\begin{frame}{A Basic Processor}
    \centering
    \begin{tikzpicture}[scale=0.8]
        % Placeholder for processor diagram
        \node[draw, rectangle, minimum width=12cm, minimum height=6cm, dashed, align=center] {
            \Large Processor Pipeline Diagram\\
            \normalsize (Fetch $\rightarrow$ Decode $\rightarrow$ Execute $\rightarrow$ Memory $\rightarrow$ Write Back)
        };
    \end{tikzpicture}
\end{frame}

%% Slide: Pipelined Car Assembly - Combined with overlays
\begin{frame}{Pipelined Car Assembly}
    \centering
    \begin{tikzpicture}[
        stage/.style={draw, thick, minimum width=3cm, minimum height=3cm, align=center, font=\large\bfseries},
        ]

        % Time progress bar - changes with each overlay
        \draw[draw=black, thick] (-5, 4) rectangle (5, 4.4);
        \only<1>{\fill[fill=blue!40] (-5, 4) rectangle (-5, 4.4);}
        \only<2>{\fill[fill=blue!40] (-5, 4) rectangle (-3.57, 4.4);}
        \only<3>{\fill[fill=blue!40] (-5, 4) rectangle (-0.71, 4.4);}
        \only<4>{\fill[fill=blue!40] (-5, 4) rectangle (0.14, 4.4);}
        \only<5>{\fill[fill=blue!40] (-5, 4) rectangle (1.43, 4.4);}
        \only<6>{\fill[fill=blue!40] (-5, 4) rectangle (2.86, 4.4);}
        \only<7>{\fill[fill=blue!40] (-5, 4) rectangle (5, 4.4);}

        \only<1>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {00:00};}
        \only<2>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {01:00};}
        \only<3>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {03:00};}
        \only<4>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {04:00};}
        \only<5>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {05:00};}
        \only<6>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {06:00};}
        \only<7>{\node[right, font=\Large\bfseries] at (5.2, 4.2) {07:00};}

        % Three stages (always visible)
        \node[stage, fill=orange!40] (chassis) at (-4, 1.5) {
            \includegraphics[width=1.2cm]{generated/noun-chassis-8091073.pdf}
        };
        \node[font=\small, anchor=north] at (chassis.south) {chassis};
        \node[font=\small, anchor=north] at ([yshift=-0.3cm]chassis.south) {1 hour};

        \node[stage, fill=green!40] (engine) at (0, 1.5) {
            \includegraphics[width=1.4cm]{generated/noun-engine-8079892.pdf}
        };
        \node[font=\small, anchor=north] at (engine.south) {engine};
        \node[font=\small, anchor=north] at ([yshift=-0.3cm]engine.south) {2 hours};

        \node[stage, fill=blue!40] (finish) at (4, 1.5) {
            \includegraphics[width=1.2cm]{generated/noun-car-spray-5038977.pdf}
        };
        \node[font=\small, anchor=north] at (finish.south) {finish};
        \node[font=\small, anchor=north] at ([yshift=-0.3cm]finish.south) {1 hour};

        % Overlay 1: 00:00 - Car 1 at chassis
        \only<1>{
            \node[below=1.5cm of chassis] (car1) {
                \includegraphics[width=1.2cm]{generated/noun-car-4612699.pdf}
            };
            \node[below=0.05cm of car1, font=\small] {Car 1};
        }

        % Overlay 2: 01:00 - Car 2 at chassis, Car 1 at engine
        \only<2>{
            \node[below=1.5cm of chassis] (car2) {
                \includegraphics[width=1.2cm]{generated/noun-car-2302591.pdf}
            };
            \node[below=0.05cm of car2, font=\small] {Car 2};

            \node[below=1.5cm of engine] (car1) {
                \includegraphics[width=1.2cm]{generated/noun-car-4612699.pdf}
            };
            \node[below=0.05cm of car1, font=\small] {Car 1};
        }

        % Overlay 3: 03:00 - Car 3 at chassis, Car 2 at engine, Car 1 at finish
        \only<3>{
            \node[below=1.5cm of chassis] (car3) {
                \includegraphics[width=1.2cm]{generated/noun-car-24929.pdf}
            };
            \node[below=0.05cm of car3, font=\small] {Car 3};

            \node[below=1.5cm of engine] (car2) {
                \includegraphics[width=1.2cm]{generated/noun-car-2302591.pdf}
            };
            \node[below=0.05cm of car2, font=\small] {Car 2};

            \node[below=1.5cm of finish] (car1) {
                \includegraphics[width=1.2cm]{generated/noun-car-4612699.pdf}
            };
            \node[below=0.05cm of car1, font=\small] {Car 1};

            \node[align=center, font=\small] at (0, -3.2) {
                Car 2 waited an hour after finishing station 1\\
                for Car 1 to finish station 2
            };
        }

        % Overlay 4: 04:00 - Car 3 at chassis, Car 2 at engine, Car 1 done
        \only<4>{
            \node[below=1.5cm of chassis] (car3) {
                \includegraphics[width=1.2cm]{generated/noun-car-24929.pdf}
            };
            \node[below=0.05cm of car3, font=\small] {Car 3};

            \node[below=1.5cm of engine] (car2) {
                \includegraphics[width=1.2cm]{generated/noun-car-2302591.pdf}
            };
            \node[below=0.05cm of car2, font=\small] {Car 2};

            \node at (7, -1) (car1) {
                \includegraphics[width=1.2cm]{generated/noun-car-4612699.pdf}
            };
            \node[below=0.05cm of car1, font=\small] {Car 1};

            \node[align=center, font=\normalsize] at (0, -3.2) {
                \textbf{First car done after 4 hours}
            };
        }

        % Overlay 5: 05:00 - Car 4 at chassis, Car 3 at engine, Car 2 at finish
        \only<5>{
            \node[below=1.5cm of chassis] (car4) {
                \includegraphics[width=1.2cm]{generated/noun-car-2502122.pdf}
            };
            \node[below=0.05cm of car4, font=\small] {Car 4};

            \node[below=1.5cm of engine] (car3) {
                \includegraphics[width=1.2cm]{generated/noun-car-24929.pdf}
            };
            \node[below=0.05cm of car3, font=\small] {Car 3};

            \node[below=1.5cm of finish] (car2) {
                \includegraphics[width=1.2cm]{generated/noun-car-2302591.pdf}
            };
            \node[below=0.05cm of car2, font=\small] {Car 2};
        }

        % Overlay 6: 06:00 - Car 4 at chassis, Car 3 at engine, Car 2 done
        \only<6>{
            \node[below=1.5cm of chassis] (car4) {
                \includegraphics[width=1.2cm]{generated/noun-car-2502122.pdf}
            };
            \node[below=0.05cm of car4, font=\small] {Car 4};

            \node[below=1.5cm of engine] (car3) {
                \includegraphics[width=1.2cm]{generated/noun-car-24929.pdf}
            };
            \node[below=0.05cm of car3, font=\small] {Car 3};

            \node at (7, -1) (car2) {
                \includegraphics[width=1.2cm]{generated/noun-car-2302591.pdf}
            };
            \node[below=0.05cm of car2, font=\small] {Car 2};

            \node[align=center, font=\small] at (0, -3.2) {
                Second car done 5 hours from starting,\\
                2 hours after the first car is done
            };
        }

        % Overlay 7: 07:00 - Car 5 at chassis, Car 4 at engine, Car 3 at finish
        \only<7>{
            \node[below=1.5cm of chassis] (car5) {
                \includegraphics[width=1.2cm]{generated/noun-car-25465.pdf}
            };
            \node[below=0.05cm of car5, font=\small] {Car 5};

            \node[below=1.5cm of engine] (car4) {
                \includegraphics[width=1.2cm]{generated/noun-car-2502122.pdf}
            };
            \node[below=0.05cm of car4, font=\small] {Car 4};

            \node[below=1.5cm of finish] (car3) {
                \includegraphics[width=1.2cm]{generated/noun-car-24929.pdf}
            };
            \node[below=0.05cm of car3, font=\small] {Car 3};

            \node[align=left, font=\normalsize] at (0, -3.5) {
                \textbf{Pipeline latency is 4 hours}\\[1mm]
                \textbf{Pipeline throughput is one car every 2 hours}
            };
        }
    \end{tikzpicture}
\end{frame}

%% Slide: Pipelined Car Assembly
\begin{frame}{Pipelining Instructions}
\begin{tikzpicture}[scale=0.9, transform shape,
    stage/.style={draw, minimum height=6mm, minimum width=8mm, font=\tiny, align=center, inner sep=1pt},
    fetch/.style={stage, fill=orange!60},
    reg/.style={stage, fill=cyan!30},
    alu/.style={stage, fill=green!40},
    mem/.style={stage, fill=gray!30},
    wb/.style={stage, fill=purple!30},
    pfetch/.style={stage, fill=orange!60, minimum width=10mm},
    preg/.style={stage, fill=cyan!30, minimum width=5mm},
    palu/.style={stage, fill=green!40, minimum width=10mm},
    pmem/.style={stage, fill=gray!30, minimum width=10mm},
    pwb/.style={stage, fill=purple!30, minimum width=10mm},]


% First pipeline diagram (non-pipelined)

% Time axis for first diagram with ticks above
\coordinate (timeline_start) at (1, 1.5);
\coordinate (timeline_end) at (11, 1.5);
\draw[->] (timeline_start) -- (timeline_end);
\draw[->] (timeline_start) -- (timeline_end)
  node[pos=1, right]{\footnotesize time};

\foreach \x/\t in {1/0, 2/2, 3/4, 4/6, 5/8, 6/10, 7/12, 8/14, 9/16, 10/18} {
    \draw (\x, 1.5) -- (\x, 1.6);  % tick marks
    \node[above] (t1-\t) at (\x, 1.6) {\tiny \t};
}

% First instruction row
\node[fetch, anchor=north west] (f1) at ([yshift=-1]timeline_start) {IF};
\node[anchor=east] (f1ins) at ([xshift=-4mm]f1.west) {\footnotesize lw R1, 100(R0)};
\node[reg, anchor=west] (r1a) at (f1.east) {ID};
\node[alu, anchor=west] (a1) at (r1a.east) {EXE};
\node[mem, anchor=west] (m1) at (a1.east) {MEM};
\node[wb, anchor=west] (r1b) at (m1.east) {WB};

% Second instruction row  
\node[fetch, anchor=north west] (f2) at (r1b.south east) {IF};
\node (f2ins) at (f1ins |- f2) {\footnotesize lw R2, 200(R0)};
\node[reg, anchor=west] (r2a) at (f2.east) {ID};
\node[alu, anchor=west] (a2) at (r2a.east) {EXE};
\node[mem, anchor=west] (m2) at (a2.east) {MEM};
\node[wb, anchor=west] (r2b) at (m2.east) {WB};

% Third instruction row
\node[fetch, anchor=north west] (f3) at (r2b.south east) {IF};
\node (f3ins) at (f1ins |- f3) {\footnotesize lw R3, 300(R0)};
\draw[dotted, ->] (f3.east) -- ++(2, 0);

% Timing annotations using relative positioning
\draw[<->] ([yshift=-2mm]f1.south west) -- node[below] {\footnotesize 8 ns} ([yshift=-2mm]r1b.south east);

\draw[<->] ([yshift=-2mm]f2.south west) -- node[below] {\footnotesize 8 ns} ([yshift=-2mm]r2b.south east);

\draw[<->] ([yshift=-2mm]f3.south west) -- node[below] {\footnotesize 8 ns} ++(3.5, 0);

% Vertical arrow for execution order - relative to instructions
\draw[->] 
  ([xshift=-3mm]f1ins.north west)
    -- node[rotate=90, anchor=south]{\tiny program execution order}
  ([xshift=-3mm]f3ins.south west);


% Second pipeline diagram (pipelined) - moved higher

% Time axis for second diagram
\coordinate (ptimeline_start) at (1, -2.3);
\coordinate (ptimeline_end) at (11, -2.3);

\draw[->] (ptimeline_start) -- (ptimeline_end)
  node[pos=1, right]{\footnotesize time};
\foreach \x/\t in {1/0, 2/2, 3/4, 4/6, 5/8, 6/10, 7/12, 8/14, 9/16, 10/18} {
    \draw (\x, -2.3) -- (\x, -2.2);  % tick marks
    \node[above] (t2-\t) at (\x, -2.2) {\tiny \t};
}

% First instruction (pipelined)
\node[pfetch, anchor=north west] (pf1) at ([yshift=-1]ptimeline_start) {IF};
\node[anchor=east] (pf1ins) at ([xshift=-4mm]pf1.west) {\footnotesize lw R1, 100(R0)};
\node[preg, anchor=west] (pr1a) at ([xshift=5mm]pf1.east) {ID};
\node[palu, anchor=west] (pa1) at (pr1a.east) {EXE};
\node[pmem, anchor=west] (pm1) at (pa1.east) {MEM};
\node[pwb, anchor=west] (pr1b) at (pm1.east) {WB};

% Second instruction (pipelined - starts after first Inst Fetch)
\node[pfetch, anchor=north west] (pf2) at (pf1.south east) {IF};
\node (pf2ins) at (pf1ins |- pf2) {\footnotesize lw R2, 200(R0)};
\node[preg, anchor=west] (pr2a) at ([xshift=5mm]pf2.east) {ID};
\node[palu, anchor=west] (pa2) at (pr2a.east) {EXE};
\node[pmem, anchor=west] (pm2) at (pa2.east) {MEM};
\node[pwb, anchor=west] (pr2b) at (pm2.east) {WB};

% Third instruction (pipelined - starts after second Inst Fetch)
\node[pfetch, anchor=north west] (pf3) at (pf2.south east) {IF};
\node (pf3ins) at (pf1ins |- pf3) {\footnotesize lw R3, 300(R0)};
\node[preg, anchor=west] (pr3a) at ([xshift=5mm]pf3.east) {ID};
\node[palu, anchor=west] (pa3) at (pr3a.east) {EXE};
\node[pmem, anchor=west] (pm3) at (pa3.east) {MEM};
\node[pwb, anchor=west] (pr3b) at (pm3.east) {WB};

% Timing annotations for pipeline stages
\draw[<->] ([yshift=-1mm]pf1.south west) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pf1.south east);

\draw[<->] ([yshift=-1mm]pf2.south west) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pf2.south east);

\draw[<->] ([yshift=-1mm]pf3.south west) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pf3.south east);

\draw[<->] ([yshift=-1mm]pf3.south east) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pa3.south west);

\draw[<->] ([yshift=-1mm]pa3.south west) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pa3.south east);

\draw[<->] ([yshift=-1mm]pm3.south west) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pm3.south east);

\draw[<->] ([yshift=-1mm]pr3b.south west) -- node[below, font=\tiny] {2 ns} ([yshift=-1mm]pr3b.south east);

% Vertical arrow for execution order - relative to instructions
\draw[->] 
  ([xshift=-3mm]pf1ins.north west)
    -- node[rotate=90, anchor=south]{\tiny program execution order}
  ([xshift=-3mm]pf3ins.south west);

\end{tikzpicture}

\vspace{0.2cm}
\centering
\large Ideal speedup is number of stages in the pipeline. Do we achieve this?
\end{frame}


%% Slide: Pipelined CPU
\begin{frame}{Pipelined CPU}
    \centering
    \begin{tikzpicture}[scale=0.7]
        % Placeholder for pipelined CPU diagram
        \node[draw, rectangle, minimum width=14cm, minimum height=7cm, dashed, align=center] {
            \Large Pipelined CPU Architecture\\
            \normalsize (Fetch $\rightarrow$ Decode $\rightarrow$ Execute $\rightarrow$ Memory $\rightarrow$ WB)\\
            \small with pipeline latches between stages
        };
    \end{tikzpicture}
\end{frame}

%% Slide: Structural Hazard
\begin{frame}{Structural Hazard}
    \textbf{Structural Hazard:} Different instructions using the same resource at the same time
    \vspace{1cm}
    
    \begin{columns}
        \column{0.45\textwidth}
        \textbf{Register File Contention:}
        \begin{itemize}
            \item Read during ID (stage 2)
            \item Write during WB (stage 5)
            \item Solution: 2 read ports, 1 write port
        \end{itemize}
        
        \vspace{0.3cm}
        \centering
        \begin{tikzpicture}[scale=0.5, transform shape]
            % Define styles
            \tikzstyle{block} = [rectangle, draw, thick, minimum width=0.8cm, minimum height=0.8cm, inner sep=2pt]
            \tikzstyle{latch} = [rectangle, draw, thick, minimum width=0.12cm, minimum height=1.4cm, fill=gray!20]
            \tikzstyle{line} = [draw, thick]
            
            % Stage labels
            \node[above] at (0,0.8) {\tiny IF};
            \node[above] at (2.4,0.8) {\tiny ID};
            \node[above] at (4.8,0.8) {\tiny EXE};
            \node[above] at (7.4,0.8) {\tiny MEM};
            \node[above] at (9.8,0.8) {\tiny WB};
            
            % Single pipeline row components
            \node[block, fill=white] (IM) at (0,0) {IM};
            \fill[gray!30] (IM.north) -- (IM.north east) -- (IM.south east) -- (IM.south) -- cycle;
            \node[block, fill=none] at (0,0) {IM};
            
            \node[latch] (L1) at (1.2,0) {};
            
            % Highlight Reg for READ (left half)
            \node[block, fill=white] (Reg1) at (2.4,0) {Reg};
            \fill[red!40] (Reg1.north west) -- (Reg1.north) -- (Reg1.south) -- (Reg1.south west) -- cycle;
            \fill[gray!30] (Reg1.north) -- (Reg1.north east) -- (Reg1.south east) -- (Reg1.south) -- cycle;
            \node[block, fill=none] at (2.4,0) {Reg};
            
            \node[latch] (L2) at (3.6,0) {};
            
            % ALU
            \begin{scope}[shift={(4.8,0)}, scale=1.2]
                \coordinate (toptopleft) at (0, 0.6);
                \coordinate (topbottomleft) at (0, 0.24);
                \coordinate (left) at (0.16, 0);
                \coordinate (bottomtopleft) at (0, -0.24);
                \coordinate (bottombottomleft) at (0, -0.6);
                \coordinate (topright) at (0.48, 0.3);
                \coordinate (bottomright) at (0.48, -0.3);
                \fill[gray!30] (toptopleft) -- (topbottomleft) -- (left) -- (bottomtopleft) -- (bottombottomleft) -- (bottomright) -- (topright) -- cycle;
                \draw[thick] (toptopleft) -- (topbottomleft) -- (left) -- (bottomtopleft) -- (bottombottomleft) -- (bottomright) -- (topright) -- cycle;
                \coordinate (alu_input1) at (0, 0.4);
                \coordinate (alu_input2) at (0, -0.4);
                \coordinate (alu_output) at (0.48, 0);
            \end{scope}
            
            \node[latch] (L3) at (6.2,0) {};
            
            \node[block, fill=white] (DM) at (7.4,0) {DM};
            \fill[gray!30] (DM.north west) -- (DM.north) -- (DM.south) -- (DM.south west) -- cycle;
            \node[block, fill=none] at (7.4,0) {DM};
            
            \node[latch] (L4) at (8.6,0) {};
            
            % Highlight Reg for WRITE (right half)
            \node[block, fill=white] (Reg2) at (9.8,0) {Reg};
            \fill[gray!30] (Reg2.north west) -- (Reg2.north) -- (Reg2.south) -- (Reg2.south west) -- cycle;
            \fill[red!40] (Reg2.north) -- (Reg2.north east) -- (Reg2.south east) -- (Reg2.south) -- cycle;
            \node[block, fill=none] at (9.8,0) {Reg};
            
            % Connections
            \draw[line] (-0.8,0) -- (IM.west);
            \draw[line] (IM.east) -- (L1.west);
            
            % Two inputs to first Reg (from different sources)
            \draw[line] ([yshift=2.4pt]L1.east) -- ([yshift=2.4pt]Reg1.west);
            \draw[line] (L1.east) -- (Reg1.west);
            
            \draw[line] (Reg1.east) -- (L2.west);
            
            % Two inputs to ALU
            \draw[line] ([yshift=2.4pt]L2.east) -- ++(0.24,0) |- (alu_input1);
            \draw[line] ([yshift=-2.4pt]L2.east) -- ++(0.24,0) |- (alu_input2);
            
            % ALU output to next latch
            \draw[line] (alu_output) -- (L3.west);
            
            % DM connections
            \draw[line] (L3.east) -- (DM.west);
            \draw[line] (DM.east) -- (L4.west);
            
            % Bypass around DM
            \draw[line] (L3.east) -- ($(L3.east)!0.5!(DM.west)$) -- ++(0, -0.56) -|
                        ($(L4.west)!0.5!(DM.east)$) -- (L4.west);
            
            \draw[line] (L4.east) -- (Reg2.west);
            \draw[line] (Reg2.east) -- ++(0.6,0);
        \end{tikzpicture}
        
        \column{0.45\textwidth}
        \textbf{Memory Contention:}
        \begin{itemize}
            \item Inst Fetch during IF (stage 1)
            \item Data access during MEM (stage 4)
            \item Solution: separate I\$ and D\$
        \end{itemize}
        
        \vspace{0.3cm}
        \centering
        \begin{tikzpicture}[scale=0.5, transform shape]
            % Define styles
            \tikzstyle{block} = [rectangle, draw, thick, minimum width=0.8cm, minimum height=0.8cm, inner sep=2pt]
            \tikzstyle{latch} = [rectangle, draw, thick, minimum width=0.12cm, minimum height=1.4cm, fill=gray!20]
            \tikzstyle{line} = [draw, thick]
            
            % Stage labels
            \node[above] at (0,0.8) {\tiny IF};
            \node[above] at (2.4,0.8) {\tiny ID};
            \node[above] at (4.8,0.8) {\tiny EXE};
            \node[above] at (7.4,0.8) {\tiny MEM};
            \node[above] at (9.8,0.8) {\tiny WB};
            
            % Single pipeline row components
            % Highlight IM for instruction fetch (READ - left side)
            \node[block, fill=white] (IM) at (0,0) {IM};
            \fill[blue!40] (IM.north west) -- (IM.north) -- (IM.south) -- (IM.south west) -- cycle;
            \fill[gray!30] (IM.north) -- (IM.north east) -- (IM.south east) -- (IM.south) -- cycle;
            \node[block, fill=none] at (0,0) {IM};
            
            \node[latch] (L1) at (1.2,0) {};
            
            \node[block, fill=white] (Reg1) at (2.4,0) {Reg};
            \fill[gray!30] (Reg1.north) -- (Reg1.north east) -- (Reg1.south east) -- (Reg1.south) -- cycle;
            \node[block, fill=none] at (2.4,0) {Reg};
            
            \node[latch] (L2) at (3.6,0) {};
            
            % ALU
            \begin{scope}[shift={(4.8,0)}, scale=1.2]
                \coordinate (toptopleft) at (0, 0.6);
                \coordinate (topbottomleft) at (0, 0.24);
                \coordinate (left) at (0.16, 0);
                \coordinate (bottomtopleft) at (0, -0.24);
                \coordinate (bottombottomleft) at (0, -0.6);
                \coordinate (topright) at (0.48, 0.3);
                \coordinate (bottomright) at (0.48, -0.3);
                \fill[gray!30] (toptopleft) -- (topbottomleft) -- (left) -- (bottomtopleft) -- (bottombottomleft) -- (bottomright) -- (topright) -- cycle;
                \draw[thick] (toptopleft) -- (topbottomleft) -- (left) -- (bottomtopleft) -- (bottombottomleft) -- (bottomright) -- (topright) -- cycle;
                \coordinate (alu_input1) at (0, 0.4);
                \coordinate (alu_input2) at (0, -0.4);
                \coordinate (alu_output) at (0.48, 0);
            \end{scope}
            
            \node[latch] (L3) at (6.2,0) {};
            
            % Highlight DM for data access (READ/WRITE - right side)
            \node[block, fill=white] (DM) at (7.4,0) {DM};
            \fill[gray!30] (DM.north west) -- (DM.north) -- (DM.south) -- (DM.south west) -- cycle;
            \fill[blue!40] (DM.north) -- (DM.north east) -- (DM.south east) -- (DM.south) -- cycle;
            \node[block, fill=none] at (7.4,0) {DM};
            
            \node[latch] (L4) at (8.6,0) {};
            
            \node[block, fill=white] (Reg2) at (9.8,0) {Reg};
            \fill[gray!30] (Reg2.north west) -- (Reg2.north) -- (Reg2.south) -- (Reg2.south west) -- cycle;
            \node[block, fill=none] at (9.8,0) {Reg};
            
            % Connections
            \draw[line] (-0.8,0) -- (IM.west);
            \draw[line] (IM.east) -- (L1.west);
            
            % Two inputs to first Reg (from different sources)
            \draw[line] ([yshift=2.4pt]L1.east) -- ([yshift=2.4pt]Reg1.west);
            \draw[line] (L1.east) -- (Reg1.west);
            
            \draw[line] (Reg1.east) -- (L2.west);
            
            % Two inputs to ALU
            \draw[line] ([yshift=2.4pt]L2.east) -- ++(0.24,0) |- (alu_input1);
            \draw[line] ([yshift=-2.4pt]L2.east) -- ++(0.24,0) |- (alu_input2);
            
            % ALU output to next latch
            \draw[line] (alu_output) -- (L3.west);
            
            % DM connections
            \draw[line] (L3.east) -- (DM.west);
            \draw[line] (DM.east) -- (L4.west);
            
            % Bypass around DM
            \draw[line] (L3.east) -- ($(L3.east)!0.5!(DM.west)$) -- ++(0, -0.56) -|
                        ($(L4.west)!0.5!(DM.east)$) -- (L4.west);
            
            \draw[line] (L4.east) -- (Reg2.west);
            \draw[line] (Reg2.east) -- ++(0.6,0);
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}{Pipeline Architecture}
\begin{center}
\begin{tikzpicture}[scale=1.2, transform shape]
    % Define styles
    \tikzstyle{block} = [rectangle, draw, thick, minimum width=1cm, minimum height=1cm, inner sep=2pt]
    \tikzstyle{latch} = [rectangle, draw, thick, minimum width=0.15cm, minimum height=1.8cm, fill=gray!20]
    \tikzstyle{line} = [draw, thick]
    
    % Stage labels
    \node[above, font=\footnotesize] at (0,1) {IF};
    \node[above, font=\footnotesize] at (2.4,1) {ID};
    \node[above, font=\footnotesize] at (4.8,1) {EXE};
    \node[above, font=\footnotesize] at (7.4,1) {MEM};
    \node[above, font=\footnotesize] at (9.8,1) {WB};
    
    % Single pipeline row components
    \node[block, fill=white] (IM) at (0,0) {IM};
    
    % Shade right half of IM (background)
    \fill[gray!30] (IM.north) -- (IM.north east) -- (IM.south east) -- (IM.south) -- cycle;
    % Redraw IM border and text on top
    \node[block, fill=none] at (0,0) {IM};
    
    % Latch after IM
    \node[latch] (L1) at (1.2,0) {};
    
    \node[block, fill=white] (Reg1) at (2.4,0) {Reg};
    
    % Shade right half of first Reg (background)
    \fill[gray!30] (Reg1.north) -- (Reg1.north east) -- (Reg1.south east) -- (Reg1.south) -- cycle;
    % Redraw Reg1 border and text on top
    \node[block, fill=none] at (2.4,0) {Reg};
    
    % Latch after Reg1
    \node[latch] (L2) at (3.6,0) {};
    
    % ALU using the custom shape (with gray shading)
    \begin{scope}[shift={(4.8,0)}, scale=1.2]
        % Trapezoid coordinates
        \coordinate (toptopleft) at (0, 0.8);
        \coordinate (topbottomleft) at (0, 0.3);
        \coordinate (left) at (0.2, 0);
        \coordinate (bottomtopleft) at (0, -0.3);
        \coordinate (bottombottomleft) at (0, -0.8);
        \coordinate (topright) at (0.6, 0.4);
        \coordinate (bottomright) at (0.6, -0.4);
        
        % Draw the trapezoid with gray fill
        \fill[gray!30] (toptopleft) -- (topbottomleft) -- (left) -- (bottomtopleft) -- (bottombottomleft) -- (bottomright) -- (topright) -- cycle;
        \draw[thick] (toptopleft) -- (topbottomleft) -- (left) -- (bottomtopleft) -- (bottombottomleft) -- (bottomright) -- (topright) -- cycle;
        
        % ALU connection points
        \coordinate (alu_input1) at (0, 0.5);
        \coordinate (alu_input2) at (0, -0.5);
        \coordinate (alu_output) at (0.6, 0);
    \end{scope}
    
    % Latch after ALU
    \node[latch] (L3) at (6.2,0) {};
    
    \node[block, fill=white] (DM) at (7.4,0) {DM};
    
    % Shade left half of DM for read, right half for write
    \fill[gray!30] (DM.north west) -- (DM.north) -- (DM.south) -- (DM.south west) -- cycle;
    % Redraw DM border and text on top
    \node[block, fill=none] at (7.4,0) {DM};
    
    % Latch after DM
    \node[latch] (L4) at (8.6,0) {};
    
    \node[block, fill=white] (Reg2) at (9.8,0) {Reg};
    
    % Shade left half of last Reg (background)
    \fill[gray!30] (Reg2.north west) -- (Reg2.north) -- (Reg2.south) -- (Reg2.south west) -- cycle;
    % Redraw Reg2 border and text on top
    \node[block, fill=none] at (9.8,0) {Reg};
    
    % Main horizontal connections
    \draw[line] (-0.8,0) -- (IM.west);
    \draw[line] (IM.east) -- (L1.west);
    
    % Two inputs to first Reg (from different sources)
    \draw[line] ([yshift=3pt]L1.east) -- ([yshift=3pt]Reg1.west);
    \draw[line] ([yshift=-3pt]L1.east) -- ([yshift=-3pt]Reg1.west);
    
    \draw[line] (Reg1.east) -- (L2.west);
    
    % Two inputs to ALU
    \draw[line] ([yshift=3pt]L2.east) -- ++(0.3,0) |- (alu_input1);
    \draw[line] ([yshift=-3pt]L2.east) -- ++(0.3,0) |- (alu_input2);
    
    % ALU output to next latch
    \draw[line] (alu_output) -- (L3.west);
    
    % DM connections
    \draw[line] (L3.east) -- (DM.west);
    \draw[line] (DM.east) -- (L4.west);
    
    % Bypass around DM (using relative positioning)
    \draw[line] (L3.east) -- ($(L3.east)!0.5!(DM.west)$) -- ++(0, -0.7) -|
                ($(L4.west)!0.5!(DM.east)$) -- (L4.west);
    
    % Single connection to final Reg
    \draw[line] (L4.east) -- (Reg2.west);
    
    \draw[line] (Reg2.east) -- ++(0.6,0);
    
\end{tikzpicture}
\end{center}
\end{frame}

%% Slide: Pipeline Example
\begin{frame}{Pipeline Example: cycle 1}
    \begin{columns}
        \column{0.4\textwidth}
        \begin{tabular}{ll}
            0 & \texttt{lw R10,9(R1)}\\
            4 & \texttt{sub R11,R2,R3}\\
            8 & \texttt{and R12,R4,R5}\\
            12 & \texttt{or R13,R6,R7}
        \end{tabular}
        
        \column{0.6\textwidth}
        \centering
        PC = 0
        \vspace{0.5cm}
        
        \begin{tikzpicture}[scale=0.6]
            \node[draw, dashed, minimum width=8cm, minimum height=3cm, align=center] {
                Pipeline State Diagram\\
                (Cycle 1)
            };
        \end{tikzpicture}
    \end{columns}
\end{frame}

%% Slide: RAW Dependency
\begin{frame}{RAW Dependency}
    \begin{columns}
        \column{0.5\textwidth}
        Program execution order:
        \begin{enumerate}
            \item \texttt{sub R2, R1, R3}
            \item \texttt{and R12, \textcolor{red}{R2}, R5}
            \item \texttt{or R13, R6, \textcolor{red}{R2}}
            \item \texttt{add R14, \textcolor{red}{R2}, \textcolor{red}{R2}}
            \item \texttt{sw R15, 100(\textcolor{red}{R2})}
        \end{enumerate}
        
        \column{0.5\textwidth}
        \centering
        \begin{tikzpicture}[scale=0.5]
            % Pipeline stages showing dependency
            \node[draw, fill=red!30, minimum width=6cm, minimum height=3cm] {
                RAW Hazard Area
            };
        \end{tikzpicture}
    \end{columns}
\end{frame}

%% Slide: Using Bypass to Solve RAW Dependency
\begin{frame}{Using Bypass to Solve RAW Dependency}
    \begin{itemize}
        \item Bypass result directly from EXE output to EXE input
        \item No stall needed when bypass is possible
        \item Hardware forwards data from:
        \begin{itemize}
            \item EXE/MEM pipeline register
            \item MEM/WB pipeline register
        \end{itemize}
    \end{itemize}
    
    \centering
    \begin{tikzpicture}[scale=0.7]
        \node[draw, dashed, minimum width=10cm, minimum height=4cm] {
            Bypass/Forwarding Hardware Diagram
        };
    \end{tikzpicture}
\end{frame}

%% Slide: Bypass Control
\begin{frame}[fragile]{Bypass Control}
    \textbf{L3\_reg\_wr = L3.RegWrite and (L3.opcode != lw)}
    
    \vspace{0.3cm}
    \textbf{Forwarding from EXE (L3):}
    \begin{itemize}
        \item \small if (L3\_reg\_wr and (L3.dst == L2.src1)) ALUSelA = 1
        \item \small if (L3\_reg\_wr and (L3.dst == L2.src2)) ALUSelB = 1
    \end{itemize}
    
    \vspace{0.3cm}
    \textbf{Forwarding from MEM (L4):}
    \begin{itemize}
        \item \small if (L4.RegWrite and ((not L3\_reg\_wr) or (L3.dst $\neq$ L2.src1))\\
              and (L4.dst = L2.src1)) ALUSelA = 2
        \item \small if (L4.RegWrite and ((not L3\_reg\_wr) or (L3.dst $\neq$ L2.src2))\\
              and (L4.dst = L2.src2)) ALUSelB = 2
    \end{itemize}
\end{frame}

%% Slide: Register File Split
\begin{frame}{Register File Split}
    \begin{itemize}
        \item Register file is written during first half of the cycle
        \item Register file is read during second half of the cycle
        \item[$\Rightarrow$] Register file is written before it is read $\Rightarrow$ returns the correct data
    \end{itemize}
    
    \centering
    \begin{tikzpicture}[scale=0.8]
        % Timeline showing register file operations
        \draw[->] (0,0) -- (8,0) node[right] {time};
        \draw[thick, blue] (1,0.5) -- (3,0.5) node[midway, above] {Write};
        \draw[thick, red] (4,0.5) -- (6,0.5) node[midway, above] {Read};
    \end{tikzpicture}
\end{frame}

%% Slide: Can't Always Bypass
\begin{frame}{Can't Always Bypass}
    \begin{itemize}
        \item Load word can still cause a hazard
        \begin{itemize}
            \item An instruction tries to read a register following a load instruction that writes to the same register
        \end{itemize}
        \item A hazard detection unit is needed to "stall" the load instruction
    \end{itemize}
    
    Program execution order:
    \begin{enumerate}
        \item \texttt{lw \textcolor{red}{R2}, 30(R1)}
        \item \texttt{and R12, \textcolor{red}{R2}, R5}
        \item \texttt{or R13, R6, \textcolor{red}{R2}}
        \item \texttt{add R14, \textcolor{red}{R2}, \textcolor{red}{R2}}
        \item \texttt{sw R15, 100(\textcolor{red}{R2})}
    \end{enumerate}
\end{frame}

%% Slide: Stall If Cannot Bypass
\begin{frame}[fragile]{Stall If Cannot Bypass}
    \begin{verbatim}
if (L2.RegWrite and (L2.opcode == lw) and 
    ((L2.dst == L1.src1) or (L2.dst == L1.src2))) 
then stall
    \end{verbatim}
    
    \vspace{0.5cm}
    \begin{itemize}
        \item De-assert the enable to the L1 latch, and to the IP
        \begin{itemize}
            \item The dependent instruction (and) stays another cycle in L1
        \end{itemize}
        \item Issue a NOP into the L2 latch (instead of the stalled inst.)
        \item Allow the stalling instruction (lw) to move on
    \end{itemize}
    
    \centering
    \begin{tikzpicture}[scale=0.6]
        \node[draw, fill=gray!30, minimum width=2cm, minimum height=1cm] {bubble};
    \end{tikzpicture}
\end{frame}

%% Slide: Software Scheduling to Avoid Load Hazards
\begin{frame}[fragile]{Software Scheduling to Avoid Load Hazards}
    \begin{tikzpicture}[remember picture, overlay]
        % Calculate base position
        \coordinate (base) at ($(current page.north) + (0, -1.5)$);

        % Example C code (left column)
        \node[anchor=north west, align=left] (example) at ($(base) + (-7, 0)$) {
            Example: code for (assume all\\
            variables are in memory):
        };
        \node[anchor=north west, font=\ttfamily, align=left] (c_code) at ($(example.south west) + (-0, -0.1)$) {
            a = b + c;\\
            d = e - f;
        };

        % Slow code column
        \node[anchor=north west, align=left] (slow_title) at ($(base) + (-0.5, 0)$) {\textbf{Slow code}};
        \draw (slow_title.south west) -- (slow_title.south east);

        \node[anchor=north west, font=\small\ttfamily, align=left] (slow_code) at ($(slow_title.south west) + (0, -0.1)$) {
            LW~~~\underline{Rb},b\\
            LW~~~\underline{\textcolor{red}{Rc}},c\\
            \textcolor{blue}{Stall}\\
            ADD~~\underline{Ra},\underline{Rb},\underline{\textcolor{red}{Rc}}\\
            \tikzmark{slow_sw1}SW~~~\underline{a},\underline{Ra}\\
            \tikzmark{slow_re}LW~~~\underline{Re},e\\
            LW~~~\underline{\textcolor{red}{Rf}},f\\
            \textcolor{blue}{Stall}\\
            SUB~~\underline{Rd},\underline{Re},\underline{\textcolor{red}{Rf}}\\
            SW~~~\underline{d},\underline{Rd}
        };

        % Fast code column
        \node[anchor=north west, align=left] (fast_title) at ($(base) + (3.5, 0)$) {\textbf{Fast code}};
        \draw (fast_title.south west) -- (fast_title.south east);

        \node[anchor=north west, font=\small\ttfamily, align=left] (fast_code) at ($(fast_title.south west) + (0, -0.1)$) {
            LW~~~\underline{Rb},b\\
            LW~~~\underline{Rc},c\\
            \tikzmark{fast_re}LW~~~\textcolor{green!60!black}{\underline{Re},e}\\
            ADD~~\underline{Ra},\underline{Rb},\underline{Rc}\\
            LW~~~\underline{Rf},f\\
            \tikzmark{fast_sw1}SW~~~\textcolor{green!60!black}{\underline{a},\underline{Ra}}\\
            SUB~~\underline{Rd},\underline{Re},\underline{Rf}\\
            SW~~~\underline{d},\underline{Rd}
        };

        % Arrows using tikzmark
        \begin{scope}[overlay, remember picture]
            % Arrow from slow LW Re,e to fast LW Re,e
            \draw[->, thick] ($(pic cs:slow_re) + (2.2, 0.1)$) to[out=0, in=180] ($(pic cs:fast_re) + (-0.3, 0.1)$);

            % Arrow from slow SW a,Ra to fast SW a,Ra
            \draw[->, thick] ($(pic cs:slow_sw1) + (2.2, 0.1)$) to[out=0, in=180] ($(pic cs:fast_sw1) + (-0.3, 0.1)$);
        \end{scope}

        % Bottom text
        \node[anchor=north, align=center] at ($(current page.south) + (0, 1.2)$) {
            {\large Instruction order can be changed \underline{as long as} the correctness is kept}
        };
    \end{tikzpicture}
\end{frame}

\begin{frame}[label=control-hazard]{Control Hazard on Branches}
    \centering
    \drawPipelineDiagram[0,0.5]
    
    \vspace{0.5cm}
    \begin{center}
        \texttt{jcc target; if cond then PC $\leftarrow$ target}
        
        \vspace{0.2cm}
        \begin{minipage}{0.8\textwidth}
            \textcolor{green!70!black}{$\diamond$ The target is saved in the instruction relative to the address of the fall-through instruction}
            
            \textcolor{green!70!black}{$\diamond$ Most conditional jumps are short (if and loop) $\Rightarrow$ save bits in the instruction encoding}
        \end{minipage}
    \end{center}
\end{frame}

%% Slide: Control Hazard on Branches - With Annotations
\begin{frame}[label=control-hazard-annotated]{Control Hazard on Branches}
    \centering
    \begin{columns}[c]
        \column{0.1\textwidth}
        \begin{tabular}{rl}
            \footnotesize 0 & \footnotesize\ttfamily or\\
            \footnotesize 4 & \footnotesize\ttfamily jcc 50H\\
            \footnotesize 8 & \footnotesize\ttfamily and\\
            \footnotesize 12 & \footnotesize\ttfamily sw\\
            \footnotesize 16 & \footnotesize\ttfamily sub
        \end{tabular}
        
        \column{0.9\textwidth}
        \drawPipelineDiagram[0,0.5]
    \end{columns}
    
    % Add annotations specific to this slide
    \begin{tikzpicture}[remember picture, overlay]
        % Add blue numbers for PC values
        \node[blue, font=\footnotesize\bfseries] at ($(current page.center) + (-6.4,-1.2)$) {8};
        \node[blue, font=\footnotesize\bfseries] at ($(current page.center) + (-3.7,1.4)$) {12};
        \node[blue, font=\footnotesize\bfseries] at ($(current page.center) + (-1.4,1.4)$) {8};
        \node[blue, font=\footnotesize\bfseries] at ($(current page.center) + (1.1,1.4)$) {4};
        
        % Add instruction labels in latches
        \node[font=\footnotesize\bfseries] at ($(current page.center) + (-3.05,-0.3)$) {jcc};
        \node[font=\footnotesize\bfseries] at ($(current page.center) + (-0.7,-0.3)$) {or};
        
        % Add orange highlight around certain paths
        \draw[orange!50, very thick, rounded corners] ($(current page.center) + (-7.0,0.9)$) rectangle ($(current page.center) + (6.4,3.1)$);
        
        % Add green highlight for decode stage
        \draw[green!50, very thick, rounded corners] ($(current page.center) + (-3.7,-1.5)$) rectangle ($(current page.center) + (-1.8,1.3)$);
        
        % Add text annotations at bottom
        \node[font=\footnotesize, align=left] at ($(current page.center) + (0,-3.0)$) {
            \texttt{jcc target; if cond then PC $\leftarrow$ target}
        };
        \node[font=\footnotesize, align=left, text=green!70!black] at ($(current page.center) + (0,-3.5)$) {
            $\diamond$ The target is saved in the instruction relative to the address of the fall-through instruction
        };
        \node[font=\footnotesize, align=left, text=green!70!black] at ($(current page.center) + (0,-4.0)$) {
            $\diamond$ Most conditional jumps are short (if and loop) $\Rightarrow$ save bits in the instruction encoding
        };
    \end{tikzpicture}
\end{frame}

%% Slide: Control Hazard: Stall
\begin{frame}{Control Hazard: Stall}
    \begin{itemize}
        \item Stall pipe when branch is encountered until resolved
        \item Stall impact: assumptions
        \begin{itemize}
            \item CPI = 1
            \item 20\% of instructions are branches
            \item Stall 3 cycles on every branch
            \item[$\Rightarrow$] $\text{CPI}_{\text{new}} = 1 + 0.2 \times 3 = 1.6$
        \end{itemize}
    \end{itemize}

    \vspace{0.5cm}
    \centering
    $\text{CPI}_{\text{new}} = \text{CPI}_{\text{Ideal}} + \text{Avg. } \frac{\text{stall cycles}}{\text{instruction}}$

    \vspace{0.5cm}
    \textcolor{red}{\textbf{We lose 60\% of the performance}}
\end{frame}

%% Slide: Control Hazard: Stall
\begin{frame}{Control Hazard: Stall}
    \begin{itemize}
        \item Stall pipe when branch is encountered until resolved
        \item Stall impact: assumptions
        \begin{itemize}
            \item CPI = 1
            \item 20\% of instructions are branches
            \item Stall 3 cycles on every branch
            \item[$\Rightarrow$] $\text{CPI}_{\text{new}} = 1 + 0.2 \times 3 = 1.6$
        \end{itemize}
    \end{itemize}

    \vspace{0.5cm}
    \centering
    $\text{CPI}_{\text{new}} = \text{CPI}_{\text{Ideal}} + \text{Avg. } \frac{\text{stall cycles}}{\text{instruction}}$

    \vspace{0.5cm}
    \textcolor{red}{\textbf{We lose 60\% of the performance}}
\end{frame}

%% Slide: Control Hazard: Predict Not Taken
\begin{frame}{Control Hazard: Predict Not Taken}
    \begin{itemize}
        \item Execute instructions from the fall-through (not-taken) path
        \begin{itemize}
            \item As if there is no branch
            \item If the branch is not-taken ($\sim50\%$), no penalty is paid
        \end{itemize}
        \item If branch actually taken
        \begin{itemize}
            \item Flush the fall-through path instructions before they change the machine state (memory / registers)
            \item Fetch the instructions from the correct (taken) path
        \end{itemize}
        \item Assuming 20\% of instructions are branches and $\sim50\%$ branches not taken on average
        \begin{itemize}
            \item $\text{CPI}_{\text{new}} = 1 + (0.2 \times 0.5) \times 3 = 1.3$
        \end{itemize}
    \end{itemize}
\end{frame}

%% Slide: Dynamic Branch Prediction
\begin{frame}{Dynamic Branch Prediction}
    \begin{itemize}
        \item \textbf{Branch Target Buffer} (BTB) that predicts (at fetch)
        \begin{itemize}
            \item[$\diamond$] Instruction is a branch
            \item[$\diamond$] Branch taken / not-taken
            \item[$\diamond$] Taken branch target
        \end{itemize}
    \end{itemize}
    
    \vspace{0.3cm}
    
    \begin{tikzpicture}[scale=1]
        % Draw the BTB table with light blue fill for data area
        \fill[blue!15] (0,0) rectangle (7.5,2.5);
        
        % Draw outer border
        \draw[thick] (0,0) rectangle (7.5,3);
        
        % Column dividers
        \draw[thick] (2.5,0) -- (2.5,3);
        \draw[thick] (5,0) -- (5,3);
        
        % Header row separator
        \draw[thick] (0,2.5) -- (7.5,2.5);
        
        % Data row lines (4 rows shown)
        \draw (0,2) -- (7.5,2);
        \draw (0,1.5) -- (7.5,1.5);
        \draw (0,1) -- (7.5,1);
        \draw (0,0.5) -- (7.5,0.5);
        
        % Header text
        \node at (1.25,2.75) {Branch IP};
        \node at (3.75,2.75) {Target IP};
        \node at (6.25,2.75) {History};
        
        % Arrow from "IP of inst in fetch" to comparison circle
        \draw[->,thick] (-2.5,1.25) -- (-0.3,1.25);
        \node[left] (ip) at (-2.5,1.25) {\small IP of inst in fetch};
        
        % Comparison circle positioned between arrow and Branch IP column
        \draw[thick,fill=white] (1.25,-1.25) circle (0.25);
        \node (qmark) at (1.25,-1.25) {\small ?=};
        \draw[thick] (ip.east) -- (qmark.west);
        
        % Connect comparison to Branch IP column (horizontal then down)
        \draw[thick] (0.25,1.25) -- (1.25,1.25);
        \draw[->,thick] (1.25,1.25) -- (1.25,0) -- (1.25,-0.8);
        
        % Arrow from Target IP column straight down
        \draw[->,thick] (3.75,0) -- (3.75,-0.8);
        
        % Arrow from History column straight down
        \draw[->,thick] (6.25,0) -- (6.25,-0.8);
        
        % Output labels
        \node[below,align=center] at (1.25,-1) {\small Inst predicted\\to be branch};
        \node[below,align=center] at (3.75,-1) {\small Predicted\\Target};
        \node[below,align=center] at (6.25,-1) {\small Branch predicted\\taken or not taken};
    \end{tikzpicture}
    
    \vspace{0.4cm}
    
    \begin{itemize}
        \item BTB allocated at execute -- after all branch info is known
        \item BTB is looked up at instruction fetch
    \end{itemize}
\end{frame}


%% Slide: BTB
\begin{frame}{BTB}
    \begin{itemize}
        \item \textbf{Allocation} - at Decode / EXE
        \begin{itemize}
            \item Allocate instructions identified as branches (after decode)
            \item Not taken branches need not be allocated
            \item BTB miss implicitly predicts not-taken
        \end{itemize}
        \item \textbf{Prediction} - at Fetch
        \begin{itemize}
            \item BTB lookup is done parallel to IC lookup
            \item BTB provides:
            \begin{itemize}
                \item Indication that the instruction is a branch (BTB hits)
                \item Branch predicted target
                \item Branch predicted direction
                \item Branch predicted type (e.g., conditional, unconditional)
            \end{itemize}
        \end{itemize}
        \item \textbf{Update} (when branch outcome is known - at EXE)
        \begin{itemize}
            \item Branch target
            \item Branch history (taken / not-taken)
        \end{itemize}
    \end{itemize}
\end{frame}

%% Slide: BTB (cont.)
\begin{frame}{BTB (cont.)}
    \begin{itemize}
        \item \textbf{Wrong prediction}
        \begin{itemize}
            \item Predict not-taken, actual taken
            \item Predict taken, actual not-taken, or actual taken but wrong target
        \end{itemize}
        \item \textbf{In case of wrong prediction  flush the pipeline}
        \begin{itemize}
            \item Reset latches (same as making all instructions to be NOPs)
            \item Select the PC source to be from the correct path
            \item Need get the fall-through with the branch
            \item Start fetching instruction from correct path
        \end{itemize}
        \item \textbf{Assuming P\% correct prediction rate}
        \begin{itemize}
            \item $\text{CPI}_{\text{new}} = 1 + (0.2 \times (1-P)) \times 3$
            \item For example, if P=0.7
            \item $\text{CPI}_{\text{new}} = 1 + (0.2 \times 0.3) \times 3 = 1.18$
        \end{itemize}
    \end{itemize}
\end{frame}

%% Slide: Adding a BTB to the Pipeline
\begin{frame}{Adding a BTB to the Pipeline}
    \centering
    \begin{tikzpicture}[scale=0.7]
        % Placeholder for BTB pipeline integration diagram
        \node[draw, rectangle, minimum width=14cm, minimum height=7cm, dashed, align=center] {
            \Large BTB Integration with Pipeline\\
            \normalsize BTB lookup parallel with I-cache lookup\\
            \small Predicted target and direction available at Fetch
        };
    \end{tikzpicture}
\end{frame}

%% Slide: Using The BTB
\begin{frame}{Using The BTB}
    \centering
    \tiny
    \begin{tikzpicture}[scale=0.8, node distance=0.5cm, remember picture,
        stage_label/.style={font=\footnotesize\bfseries}]

        % Shift flowchart to the right
        \begin{scope}[xshift=3cm]
        % Flowchart for BTB usage (drawn first)
        \node[draw, rectangle, fill=orange!40] (pc) {PC moves to next instruction};
        \node[draw, rectangle, fill=orange!40, below left=of pc, align=center] (imem) {Inst Mem gets PC\\and fetches new inst};
        \node[draw, rectangle, fill=orange!40, below right=of pc, align=center] (btb) {BTB gets PC\\and looks it up};
        \node[draw, diamond, fill=orange!40, below=of btb] (hit) {BTB Hit?};
        \node[draw, diamond, fill=orange!40, below left=of hit] (taken) {Br taken?};
        \node[draw, rectangle, fill=orange!40, below left=of taken] (pred) {PC $\leftarrow$ pred addr};
        \node[draw, rectangle, fill=orange!40, below right=of taken] (inc) {PC $\leftarrow$ PC + 4};
        \node[draw, rectangle, fill=orange!40, below=of pred, align=center] (predinst) {IF/ID latch loaded\\with pred inst};
        \node[draw, rectangle, fill=orange!40, below=of inc, align=center] (seqinst) {IF/ID latch loaded\\with seq. inst};
        \node[draw, rectangle, fill=orange!40, align=center] (new) at (seqinst -| imem) {IF/ID latch loaded\\with new inst};
        \node[draw, diamond, fill=orange!40, below=of new, align=center] (branch) {Branch?};

        \draw[->] (pc) -- (imem);
        \draw[->] (pc) -- (btb);
        \draw[->] (btb) -- (hit);
        \draw[->] (hit) -| node[left] {yes} (taken);
        \draw[->] (hit) -| node[right] {no} ([xshift=6.5cm]inc);
        \draw[->] (taken.west) -| node[left] {yes} (pred);
        \draw[->] (taken) -| node[right] {no} (inc);
        \draw[->] (pred) -- (predinst);
        \draw[->] (inc) -- (seqinst);
        \draw[->] (imem) -- (new);
        \draw[->] (new) -- (branch);

        % Pipeline stage labels with arrows (drawn on top)
        % Calculate boundary line positions based on actual nodes
        \coordinate (if_id_y) at ($(pc.north) + (0, 0.3)$);
        \coordinate (id_exe_y) at (new.center |- new.center);
        \coordinate (exe_mem_y) at ([yshift=-0.3cm]branch.south);

        % Find leftmost element
        \coordinate (leftmost) at (imem.west);
        \end{scope}

        % Position labels and lines relative to flowchart (outside shifted scope)
        \coordinate (label_x) at ($(leftmost) + (-1.5, 0)$);
        \coordinate (line_left) at ($(label_x) + (0.5, 0)$);
        \coordinate (line_right) at ($(line_left) + (13, 0)$);

        % Calculate midpoints for label positioning
        \coordinate (if_mid_y) at ($(if_id_y)!0.5!(id_exe_y)$);
        \coordinate (id_mid_y) at ($(id_exe_y)!0.5!(exe_mem_y)$);
        \coordinate (exe_mid_y) at ($(exe_mem_y) + (0, -0.5)$);

        % IF label and arrows (positioned at midpoint between if_id_y and id_exe_y)
        \node[stage_label] (if_label) at (label_x |- if_mid_y) {IF};
        \draw[->] (if_label.north) -- ($(if_label.north |- if_id_y) + (0, -0.1)$);
        \draw[->] (if_label.south) -- ($(if_label.south |- id_exe_y) + (0, 0.1)$);

        % ID label and arrows (positioned at midpoint between id_exe_y and exe_mem_y)
        \node[stage_label] (id_label) at (label_x |- id_mid_y) {ID};
        \draw[->] (id_label.north) -- ($(id_label.north |- id_exe_y) + (0, -0.1)$);
        \draw[->] (id_label.south) -- ($(id_label.south |- exe_mem_y) + (0, 0.1)$);

        % EXE label and arrow (positioned below exe_mem_y)
        \node[stage_label] (exe_label) at (label_x |- exe_mid_y) {EXE};
        \draw[->] (exe_label.north) -- ($(exe_label.north |- exe_mem_y) + (0, -0.1)$);

        % Draw horizontal lines (behind everything else by drawing them last but with background layer)
        \begin{scope}[on background layer]
            \draw[thick] (line_left |- if_id_y) -- (line_right |- if_id_y);
            \draw[thick] (line_left |- id_exe_y) -- (line_right |- id_exe_y);
            \draw[thick] (line_left |- exe_mem_y) -- (line_right |- exe_mem_y);
        \end{scope}
    \end{tikzpicture}
\end{frame}

%% Slide: Using The BTB (cont.)
\begin{frame}{Using The BTB (cont.)}
    \centering
    \tiny
    \begin{tikzpicture}[scale=0.8, node distance=0.5cm, remember picture,
        stage_label/.style={font=\footnotesize\bfseries}]

        % Shift flowchart to the right
        \begin{scope}[xshift=1cm]
        % Continuation of BTB flowchart (drawn first)
        \node[draw, diamond, fill=orange!40] (branch) {Branch?};
        \node[draw, rectangle, fill=orange!40, below left=of branch, align=center] (calc) {Calculate br\\cond \& trgt};
        \node[draw, rectangle, fill=orange!40, below right=of branch] (continue1) {continue};
        \node[draw, rectangle, fill=orange!40, below=of calc] (update) {Update BTB};
        \node[draw, diamond, fill=orange!40, below=of update, align=center] (correct) {Correct\\pred?};
        \node[draw, rectangle, fill=orange!40, below right=of correct, align=center] (flush) {Flush pipe \&\\update PC};
        \node[draw, rectangle, fill=orange!40, below left=of correct] (continue2) {continue};
        \node[draw, rectangle, fill=orange!40, below=of flush, align=center] (correctinst) {IF/ID latch loaded\\with correct inst};

        \draw[->] (branch) -| node[left] {yes} (calc);
        \draw[->] (branch) -| node[right] {no} (continue1);
        \draw[->] (calc) -- (update);
        \draw[->] (update) -- (correct);
        \draw[->] (correct) -| node[right] {no} (flush);
        \draw[->] (correct) -| node[left] {yes} (continue2);
        \draw[->] (flush) -- (correctinst);

        % Pipeline stage labels with arrows (drawn on top)
        % Calculate boundary line positions based on actual nodes
        \coordinate (id_exe_y) at ([yshift=0.3cm]branch.north);
        \coordinate (exe_mem_y) at (update.center |- update.center);
        \coordinate (mem_wb_y) at (flush.center);
        \coordinate (wb_end_y) at ([yshift=-0.3cm]flush.south);
        \coordinate (end_y) at (correctinst.center |- correctinst.center);

        % Add short arrow into branch from id_exe line
        \draw[->, thick, orange!70] ([yshift=0.3cm]branch.north) -- (branch.north);

        % Find leftmost element
        \coordinate (leftmost) at (continue2.west);
        \end{scope}

        % Position labels and lines relative to flowchart (outside shifted scope)
        \coordinate (label_x) at ($(leftmost) + (-1.5, 0)$);
        \coordinate (line_left) at ($(label_x) + (0.5, 0)$);
        \coordinate (line_right) at ($(line_left) + (13, 0)$);

        % Calculate midpoints for label positioning
        \coordinate (id_mid_y) at ($(id_exe_y)!0.5!(exe_mem_y)$);
        \coordinate (exe_mid_y) at ($(exe_mem_y)!0.5!(mem_wb_y)$);
        \coordinate (mem_mid_y) at ($(mem_wb_y)!0.5!(wb_end_y)$);
        \coordinate (wb_mid_y) at ($(wb_end_y)!0.5!(end_y)$);

        % ID label and arrows (positioned at midpoint between id_exe_y and exe_mem_y)
        \node[stage_label] (id_label) at (label_x |- id_mid_y) {ID};
        \draw[->] (id_label.north) -- ($(id_label.north |- id_exe_y) + (0, -0.1)$);
        \draw[->] (id_label.south) -- ($(id_label.south |- exe_mem_y) + (0, 0.1)$);

        % EXE label and arrows (positioned at midpoint between exe_mem_y and mem_wb_y)
        \node[stage_label] (exe_label) at (label_x |- exe_mid_y) {EXE};
        \draw[->] (exe_label.north) -- ($(exe_label.north |- exe_mem_y) + (0, -0.1)$);
        \draw[->] (exe_label.south) -- ($(exe_label.south |- mem_wb_y) + (0, 0.1)$);

        % MEM label and arrows (positioned at midpoint between mem_wb_y and wb_end_y)
        \node[stage_label] (mem_label) at (label_x |- mem_mid_y) {MEM};
        \draw[->] (mem_label.north) -- ($(mem_label.north |- mem_wb_y) + (0, -0.1)$);
        \draw[->] (mem_label.south) -- ($(mem_label.south |- wb_end_y) + (0, 0.1)$);

        % WB label and arrows (positioned at midpoint between wb_end_y and end_y)
        \node[stage_label] (wb_label) at (label_x |- wb_mid_y) {WB};
        \draw[->] (wb_label.north) -- ($(wb_label.north |- wb_end_y) + (0, -0.1)$);
        \draw[->] (wb_label.south) -- ($(wb_label.south |- end_y) + (0, 0.1)$);

        % Draw horizontal lines (behind everything else by drawing them last but with background layer)
        \begin{scope}[on background layer]
            \draw[thick] (line_left |- id_exe_y) -- (line_right |- id_exe_y);
            \draw[thick] (line_left |- exe_mem_y) -- (line_right |- exe_mem_y);
            \draw[thick] (line_left |- mem_wb_y) -- (line_right |- mem_wb_y);
            \draw[thick] (line_left |- wb_end_y) -- (line_right |- wb_end_y);
            \draw[thick] (line_left |- end_y) -- (line_right |- end_y);
        \end{scope}
    \end{tikzpicture}
\end{frame}

%% Backup Slides

%% Backup Slides Separator
\begin{frame}[plain]
    \begin{center}
        \vfill
        {\Huge \textbf{Backup Slides}}
        \vfill
    \end{center}
\end{frame}

%% Slide: Control Signals
\begin{frame}{Control Signals}
    \centering
    \footnotesize
    \renewcommand{\arraystretch}{0.9}
    \begin{tabular}{|l|c|c|c|c|c|c|c|}
        \hline
        \textbf{func} & \textbf{10 0000} & \textbf{10 0010} & \multicolumn{5}{c|}{\textbf{Don't Care}} \\
        \hline
        \textbf{op} & \textbf{00 0000} & \textbf{00 0000} & \textbf{00 1101} & \textbf{10 0011} & \textbf{10 1011} & \textbf{00 0100} & \textbf{00 0010} \\
        \hline
        & \textbf{add} & \textbf{sub} & \textbf{ori} & \textbf{lw} & \textbf{sw} & \textbf{beq} & \textbf{jump} \\
        \hline
        \textbf{RegDst} & 1 & 1 & 0 & 0 & x & x & x \\
        \hline
        \textbf{ALUSrc} & 0 & 0 & 1 & 1 & 1 & 0 & x \\
        \hline
        \textbf{MemtoReg} & 0 & 0 & 0 & 1 & x & x & x \\
        \hline
        \textbf{RegWrite} & 1 & 1 & 1 & 1 & 0 & 0 & 0 \\
        \hline
        \textbf{MemWrite} & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
        \hline
        \textbf{Branch} & 0 & 0 & 0 & 0 & 0 & 1 & x \\
        \hline
        \textbf{Jump} & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
        \hline
        \textbf{ALUctr$\langle$2:0$\rangle$} & Add & Subtract & Or & Add & Add & Subtract & xxx \\
        \hline
    \end{tabular}
\end{frame}

%% Slide: Multi-Cycle Control
\begin{frame}{Multi-Cycle Control}
    \begin{itemize}
        \item \textbf{Pass control signals along just like the data}
    \end{itemize}

    \vspace{0.5cm}
    \centering
    % TODO: Add figure for multi-cycle control
    %\includegraphics[width=0.9\textwidth]{figures/multi_cycle_control.png}
\end{frame}

%% Slide: Five Execution Steps
\begin{frame}{Five Execution Steps}
    \begin{itemize}
        \item \textbf{Instruction Fetch}
        \begin{itemize}
            \item Use PC to get instruction and put it in the Instruction Register.
            \item Increment the PC by 4 and put the result back in the PC.
            \item \texttt{IR = Memory[PC]; PC = PC + 4;}
        \end{itemize}

        \item \textbf{Instruction Decode and Register Fetch}
        \begin{itemize}
            \item Read registers rs and rt
            \item Compute the branch address
            \item \texttt{A = Reg[IR[25-21]]; B = Reg[IR[20-16]];}
            \item \texttt{ALUOut = PC + (sign-extend(IR[15-0]) << 2);}
            \item We aren't setting any control lines based on the instruction type
        \end{itemize}
    \end{itemize}
\end{frame}

%% Slide: Five Execution Steps (cont.)
\begin{frame}{Five Execution Steps (cont.)}
    \begin{itemize}
        \item \textbf{Execution} - ALU is performing one of three functions:
        \begin{itemize}
            \item \textbf{Memory Reference:} \texttt{ALUOut = A + sign-extend(IR[15-0]);}
            \item \textbf{R-type:} \texttt{ALUOut = A op B;}
            \item \textbf{Branch:} \texttt{if (A==B) PC = ALUOut;}
        \end{itemize}

        \item \textbf{Memory Access or R-type instruction completion}
        \item \textbf{Write-back step}
    \end{itemize}
\end{frame}

%% Slide: The Store Instruction
\begin{frame}{The Store Instruction}
    \begin{center}
    \textbf{Instruction Format:}

    \vspace{0.3cm}
    \begin{tikzpicture}
        \draw[thick] (0,0) rectangle (10,0.6);
        \draw[thick] (2,0) -- (2,0.6);
        \draw[thick] (4,0) -- (4,0.6);
        \draw[thick] (6,0) -- (6,0.6);

        \node at (1,0.3) {\small op};
        \node at (3,0.3) {\small rs};
        \node at (5,0.3) {\small rt};
        \node at (8,0.3) {\small immediate};

        \node[above, anchor=south west, inner sep=1pt] at (0,0.6) {\footnotesize 31};
        \node[above, anchor=south, inner sep=1pt] at (2,0.6) {\footnotesize 26};
        \node[above, anchor=south, inner sep=1pt] at (4,0.6) {\footnotesize 21};
        \node[above, anchor=south, inner sep=1pt] at (6,0.6) {\footnotesize 16};
        \node[above, anchor=south east, inner sep=1pt] at (10,0.6) {\footnotesize 0};

        \node[below] at (1,0) {\footnotesize 6 bits};
        \node[below] at (3,0) {\footnotesize 5 bits};
        \node[below] at (5,0) {\footnotesize 5 bits};
        \node[below] at (8,0) {\footnotesize 16 bits};
    \end{tikzpicture}
    \end{center}

    \vspace{0.3cm}
    \textbf{Execution Steps:}
    \begin{itemize}
        \item Fetch instruction from memory: \texttt{mem[PC]}
        \item Calculate address: $\text{Addr} \leftarrow \text{R[rs]} + \text{SignExt(imm16)}$
        \item \textbf{Store:} $\textcolor{blue}{\text{Mem[Addr]} \leftarrow \text{R[rt]}}$
        \item Update PC: $\text{PC} \leftarrow \text{PC} + 4$
    \end{itemize}

    \vspace{0.2cm}
    \textbf{Example:} \texttt{sw rt, rs, imm16} \quad $\Rightarrow$ \quad $\text{Mem[R[rs]} + \text{SignExt(imm16)]} \leftarrow \text{R[rt]}$
\end{frame}

%% Slide: RAW Hazard: SW Solution
\begin{frame}{RAW Hazard: SW Solution}
    \begin{itemize}
        \item Have compiler avoid hazards by adding NOP instructions
        \item Problem: this really slows us down!
    \end{itemize}

    \vspace{0.5cm}
    \centering
    % TODO: Add figure for RAW hazard SW solution
    %\includegraphics[width=0.95\textwidth]{figures/raw_hazard_sw.png}
\end{frame}

%% Slide: Delayed Branch
\begin{frame}[fragile]{Delayed Branch}
    \begin{itemize}
        \item \textbf{Define branch to take place AFTER \textit{n} following instruction}
        \begin{itemize}
            \item HW executes \textit{n} instructions following the branch regardless of branch is taken or not
        \end{itemize}

        \item \textbf{SW puts in the \textit{n} slots following the branch instructions that need to be executed regardless of branch resolution}
        \begin{itemize}
            \item Instructions that are before the branch instruction, or
            \item Instructions from the converged path after the branch
        \end{itemize}

        \item \textbf{If cannot find independent instructions, put NOP}
    \end{itemize}

    \vspace{0.5cm}
    \begin{columns}
        \column{0.45\textwidth}
        \begin{block}{Original Code}
            \small\ttfamily
            r3 = 23\\
            R4 = R3+R5\\
            If (r1==r2) goto x\\
            R1 = R4 + R5\\
            X: R7 = R1
        \end{block}

        \column{0.45\textwidth}
        \begin{block}{New Code}
            \small\ttfamily
            If (r1==r2) goto x\\
            \textcolor{red}{r3 = 23}\\
            \textcolor{red}{R4 = R3 +R5}\\
            \textcolor{red}{NOP}\\
            R1 = R4 + R5\\
            X: R7 = R1
        \end{block}
    \end{columns}
\end{frame}

%% Slide: Delayed Branch Performance
\begin{frame}{Delayed Branch Performance}
    \begin{itemize}
        \item Filling \textbf{1 delay slot is easy}, \textbf{2 is hard}, \textbf{3 is harder}
        \item Assume we can effectively fill \textbf{d\%} of the delayed slots
    \end{itemize}

    \vspace{0.5cm}
    \begin{center}
        \Large
        $\text{CPI}_{\text{new}} = 1 + 0.2 \times (3 \times (1-d))$
    \end{center}
    \vspace{0.5cm}

    \begin{itemize}
        \item For example, for $d=0.5$: \quad \textcolor{blue}{\textbf{$\text{CPI}_{\text{new}} = 1.3$}}
        \item \textbf{Problem: Mixing architecture with micro-architecture}
        \begin{itemize}
            \item New generations require more delay slots
            \item Causes \textbf{compatibility issues} between generations
        \end{itemize}
    \end{itemize}
\end{frame}

\end{document}