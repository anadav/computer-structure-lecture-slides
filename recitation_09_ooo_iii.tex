\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, fit, decorations.pathreplacing, matrix, backgrounds}
\usepackage{tcolorbox}
\usepackage{array}
\usepackage{listings}
\usepackage{minted}
\usepackage{pgfkeys}
\usepackage{adjustbox}
\usepackage[normalem]{ulem}
\usepackage{xparse}
\usepackage{multicol}
\usetheme{Madrid}

\title{Out-of-Order Execution: Part III}
\subtitle{Memory Operations \& Pipeline Timing}
\author{Computer Architecture 2360267}
\date{2025, Recitation \#9}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{Reminders: OOO Memory Operations}
\begin{itemize}
    \item L1 and L2 caches are \textbf{non-blocking}
    \item RS (Reservation Station) solves false register dependencies
    \item MOB (Memory Order Buffer) solves memory dependencies
    \begin{itemize}
        \item Some dependencies can be resolved statically: \texttt{store r1,a; load r2,b}
        \item Problem: Some cannot: \texttt{store r1,[r3]; load r2,b}
    \end{itemize}
    \item Stores/loads are heavily used in x86 due to limited registers
    \item \textbf{Stores are NOT executed out-of-order} (difficult to undo)
    \begin{itemize}
        \item Decomposed into 2 uops: STA (Store Address) and STD (Store Data)
    \end{itemize}
    \item \textbf{Loads ARE executed out-of-order}
    \item Previous stores may have unknown virtual addresses
\end{itemize}
\end{frame}

\section{Memory Operation Lifecycle}

% ============================================================================
% Load/Store Lifecycle Diagram Macro Definitions
% ============================================================================

% MACRO DEFINITIONS MOVED HERE - DO NOT REMOVE
% These definitions must come before any slides that use LoadLifecycleDiagram

% Define colors for the load lifecycle diagrams
\definecolor{lightblue}{RGB}{200,230,250}
\definecolor{lightyellow}{RGB}{255,250,200}
\definecolor{lightcyan}{RGB}{230,255,255}
\definecolor{lightpink}{RGB}{255,240,245}
\definecolor{highlightyellow}{RGB}{255,230,100}

% Commands for highlighting entries
\newcommand{\newentry}[1]{\colorbox{highlightyellow}{#1}}
\newcommand{\removedentry}[1]{\colorbox{highlightyellow}{\sout{#1}}}

% pgfkeys setup for Load Lifecycle diagram
\pgfkeys{
    /LoadLife/.is family, /LoadLife,
    default/.style = {
        % RAT physical registers
        rat0 = {}, rat1 = {}, rat2 = {}, rat3 = {},
        % ROB first entry
        robOp = {}, robValid = {}, robRdy = {}, robData = {}, robDst = {},
        % Instruction Queue (2 rows)
        iq1 = {}, iq2 = {},
        % RS content (2 rows)
        rs1 = {}, rs2 = {},
        % Store Buffer (2 data rows, 4 fields each: V, Addr, Data, Snr)
        sb1v = {}, sb1addr = {}, sb1data = {}, sb1snr = {},
        sb2v = {}, sb2addr = {}, sb2data = {}, sb2snr = {},
        % Load Buffer (V, Addr, BC)
        lbV = {}, lbAddr = {}, lbBC = {},
        % EXE units (second row content)
        alu = {}, agu = {},
        % Retire
        retire = {},
        % Retire box (optional box next to retire)
        retirebox = {},
        % Arrow flags (independent control)
        arrowDTLB = 0,
        arrowCache = 0,
        arrowStoreCache = 0,
    },
    rat0/.estore in = \ratZero,
    rat1/.estore in = \ratOne,
    rat2/.estore in = \ratTwo,
    rat3/.estore in = \ratThree,
    robOp/.estore in = \robOp,
    robValid/.estore in = \robValid,
    robRdy/.estore in = \robRdy,
    robData/.estore in = \robData,
    robDst/.estore in = \robDst,
    iq1/.estore in = \iqOne,
    iq2/.estore in = \iqTwo,
    rs1/.estore in = \rsOne,
    rs2/.estore in = \rsTwo,
    sb1v/.estore in = \sbOneV,
    sb1addr/.estore in = \sbOneAddr,
    sb1data/.estore in = \sbOneData,
    sb1snr/.estore in = \sbOneSnr,
    sb2v/.estore in = \sbTwoV,
    sb2addr/.estore in = \sbTwoAddr,
    sb2data/.estore in = \sbTwoData,
    sb2snr/.estore in = \sbTwoSnr,
    lbV/.estore in = \lbV,
    lbAddr/.estore in = \lbAddr,
    lbBC/.estore in = \lbBC,
    alu/.estore in = \aluContent,
    agu/.estore in = \aguContent,
    retire/.estore in = \retireContent,
    retirebox/.estore in = \retireBoxContent,
    arrowDTLB/.estore in = \arrowDTLB,
    arrowCache/.estore in = \arrowCache,
    arrowStoreCache/.estore in = \arrowStoreCache,
}

% Macro for creating load lifecycle diagram using matrix of nodes
% Usage: \LoadLifecycleDiagram[key=value, ...]
% Available keys:
%   rat0, rat1, rat2, rat3 - RAT physical register mappings
%   robOp, robValid, robRdy, robData - ROB entry fields (Phys Reg is hard-coded as RF0-RF3)
%   iq1, iq2 - Instruction Queue entries (2 rows)
%   rs1, rs2 - Reservation Station entries (2 rows)
%   sb1v, sb1addr, sb1data, sb1snr - Store Buffer row 1 (V, Addr, Data, Snr)
%   sb2v, sb2addr, sb2data, sb2snr - Store Buffer row 2 (V, Addr, Data, Snr)
%   lbV, lbAddr, lbBC - Load Buffer fields (Valid, Address, Blocking Conditions)
%   alu, agu - EXE unit contents (second row; first row is hard-coded as "ALU1"/"AGU")
%   retire - Retire stage content
%   retirebox - Optional box next to retire (for additional information)
%   arrows - Arrow display flag (0-4, controls which arrows are shown)
\newcommand{\LoadLifecycleDiagram}[1][]{%
    % Set defaults and process keys
    \pgfkeys{/LoadLife,default,#1}%
\begin{tikzpicture}[
    scale=0.7,
    every node/.style={transform shape},
    cell/.style={draw, rectangle, minimum height=4.5mm, text height=1.5ex, text depth=0.25ex, font=\tiny\ttfamily},
    headerbox/.style={draw, rectangle, fill=gray!10, minimum height=4.5mm, text height=1.5ex, text depth=0.25ex, font=\tiny\ttfamily, align=center},
    smallbox/.style={draw, rectangle, minimum width=1.2cm, minimum height=0.7cm, font=\scriptsize\ttfamily, align=center},
    labelstyle/.style={font=\scriptsize\bfseries\sffamily},
    greenarrow/.style={->, very thick, yellow!80!orange, >=stealth}
]

% RAT (Register Alias Table)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:RAT},
        nodes={cell, align=center},
        row 1/.style={nodes={headerbox, minimum height=6mm}},
        column 1/.append style={nodes={text width=0.9cm, fill=gray!10}},
        column 2/.append style={nodes={text width=0.9cm, minimum width=0.9cm}},
        ampersand replacement=\&] (rat) {
    {\tiny\begin{tabular}{@{}c@{}}Arch\\Reg\end{tabular}} \& {\tiny\begin{tabular}{@{}c@{}}Phys\\Reg\end{tabular}} \\
    R0 \& \ifx\ratZero\empty{ }\else\ratZero\fi \\
    R1 \& \ifx\ratOne\empty{ }\else\ratOne\fi \\
    R2 \& \ifx\ratTwo\empty{ }\else\ratTwo\fi \\
    R3 \& \ifx\ratThree\empty{ }\else\ratThree\fi \\
};

% ROB (Reorder Buffer)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:ROB},
        right=0.7cm of rat.north east,
        anchor=north west,
        nodes={cell, align=center},
        row 1/.style={nodes={headerbox, minimum height=6mm}},
        column 1/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        column 2/.append style={nodes={text width=0.35cm, fill=lightblue!30}},
        column 3/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        column 4/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        column 5/.append style={nodes={text width=0.7cm, fill=lightblue!30}},
        column 6/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        ampersand replacement=\&] (rob) {
    {\tiny\begin{tabular}{@{}c@{}}Phys\\Reg\end{tabular}} \& Op \& Val \& Rdy \& Data \& DST \\
    RF0 \& \ifx\robOp\empty{ }\else\robOp\fi \& \ifx\robValid\empty{ }\else\robValid\fi \& \ifx\robRdy\empty{ }\else\robRdy\fi \& \ifx\robData\empty{ }\else\robData\fi \& \ifx\robDst\empty{ }\else\robDst\fi \\
    RF1 \& {} \& {} \& {} \& {} \& {} \\
    RF2 \& {} \& {} \& {} \& {} \& {} \\
    RF3 \& {} \& {} \& {} \& {} \& {} \\
};

% RS (Reservation Station)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:RS},
        below right=1.2cm and 0.5cm of rob.north east,
        anchor=north west,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=2.8cm}},
        ampersand replacement=\&] (rs) {
    \ifx\rsOne\empty{ }\else\rsOne\fi \\
    \ifx\rsTwo\empty{ }\else\rsTwo\fi \\
};

% Instruction Queue (above RS label)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:Instruction Q},
        above=0.6cm of rs.north,
        anchor=south,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=2.8cm}},
        ampersand replacement=\&] (instq) {
    \ifx\iqOne\empty{ }\else\iqOne\fi \\
    \ifx\iqTwo\empty{ }\else\iqTwo\fi \\
};

% MOB (Memory Order Buffer) - Load Buffer
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        right=1.0cm of rs.north east,
        anchor=north west,
        nodes={cell, align=center},
        row 1/.style={nodes={headerbox}},
        column 1/.append style={nodes={text width=0.6cm}},
        column 2/.append style={nodes={text width=1.3cm}},
        column 3/.append style={nodes={text width=0.5cm}},
        ampersand replacement=\&] (loadbuf) {
    V \& Addr \& BC \\
    \ifx\lbV\empty{ }\else\lbV\fi \& \ifx\lbAddr\empty{ }\else\lbAddr\fi \& \ifx\lbBC\empty{ }\else\lbBC\fi \\
};

% Load Buffer label
\node[labelstyle, above=0.05cm of loadbuf.north] (loadbuflabel) {Load Buffer};

% Store Buffer (above Load Buffer, matching its width)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        above=0.6cm of loadbuf.north,
        anchor=south,
        nodes={cell, align=center},
        row 1/.style={nodes={headerbox}},
        column 1/.append style={nodes={text width=0.35cm}},
        column 2/.append style={nodes={text width=1.2cm}},
        column 3/.append style={nodes={text width=1.2cm}},
        column 4/.append style={nodes={text width=0.35cm}},
        ampersand replacement=\&] (storebuf) {
    V \& Addr \& Data \& Snr \\
    \ifx\sbOneV\empty{ }\else\sbOneV\fi \& \ifx\sbOneAddr\empty{ }\else\sbOneAddr\fi \& \ifx\sbOneData\empty{ }\else\sbOneData\fi \& \ifx\sbOneSnr\empty{ }\else\sbOneSnr\fi \\
};

% Store Buffer label
\node[labelstyle, above=0.05cm of storebuf.north] (storebuflabel) {Store Buffer};

% MOB cyan background using fit (includes Store Buffer label and Load Buffer label)
\begin{scope}[on background layer]
\node[draw, fill=lightcyan, fit=(storebuflabel)(storebuf)(loadbuflabel)(loadbuf), inner sep=2pt] (mobbox) {};
\end{scope}

% MOB label positioned above the cyan box
\node[labelstyle, anchor=south] at ([yshift=0.05cm]mobbox.north) (moblabel) {MOB};

% Data Cache (right of Load Buffer, aligned with data row)
\node[smallbox, right=1.2cm of loadbuf.east, anchor=west] (dcache) {Data\\Cache};

% EXE block - Individual matrices
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        below=0.7cm of rs.south,
        anchor=north,
        nodes={cell, align=center},
        row 1/.style={nodes={fill=gray!10}},
        column 1/.append style={nodes={text width=1.2cm}},
        ampersand replacement=\&] (alu1) {
    ALU1 \\
    \ifx\aluContent\empty{ }\else\aluContent\fi \\
};

\node[font=\large, right=0.25cm of alu1] (dots) {$\bullet\bullet\bullet$};

\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        right=0.25cm of dots,
        anchor=west,
        nodes={cell, align=center},
        row 1/.style={nodes={fill=gray!10}},
        column 1/.append style={nodes={text width=1.2cm}},
        ampersand replacement=\&] (agu) {
    AGU \\
    \ifx\aguContent\empty{ }\else\aguContent\fi \\
};

% EXE label and pink background using fit
\node[labelstyle, left=0.1cm of alu1.west, anchor=east] (exelabel) {EXE};
\begin{scope}[on background layer]
\node[draw, fill=lightpink, fit=(exelabel)(alu1)(dots)(agu), inner sep=2pt] (exeblock) {};
\end{scope}

% dTLB (right of AGU, aligned with second row)
\node[smallbox, right=1.2cm of agu.east, anchor=west] (dtlb) {dTLB};

% Retire (below ROB, left-aligned with ROB)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]left:Retire},
        below=0.4cm of rob.south west,
        anchor=north west,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=1.8cm}},
        ampersand replacement=\&] (retire) {
    \ifx\retireContent\empty{ }\else\retireContent\fi \\
};

% Draw green arrows based on flags
\ifnum\arrowDTLB=1 \draw[greenarrow] (agu.east) -- (dtlb.west); \fi
\ifnum\arrowCache=1 \draw[greenarrow] (loadbuf.east) -- (dcache.west); \fi
\ifnum\arrowStoreCache=1 \draw[greenarrow] (storebuf.east) -| (dcache.north); \fi

\end{tikzpicture}%
}

\subsection{The Life of a Load}

% Life of a Load - Step 1: Initial State
\begin{frame}
\frametitle{The Life of a Load: Initial State}
\begin{center}
\LoadLifecycleDiagram[
    iq1={\newentry{R3$\leftarrow$MEM(R2+50)}},
    lbAddr={Not Vld},
    robDst={}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
Load instruction \texttt{R3$\leftarrow$MEM(R2+50)} is waiting in the Instruction Queue, ready to be allocated.
\end{tcolorbox}
\end{frame}

% Life of a Load - Step 2: Allocation
\begin{frame}
\frametitle{The Life of a Load: Allocation}
\begin{center}
\LoadLifecycleDiagram[
    rat3={\newentry{RF0}},
    robOp={\newentry{Ld}},
    robValid={\newentry{1}},
    robRdy={\newentry{0}},
    robData={\newentry{N/A}},
    robDst={\newentry{R3}},
    iq1={\removedentry{R3$\leftarrow$MEM(R2+50)}},
    rs1={\newentry{RF0$\leftarrow$MEM(R2+50)}},
    lbV={\newentry{1}},
    lbAddr={\newentry{Not Vld}},
    lbBC={\newentry{0}}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The load is allocated with one entry in the ROB, one in the RS, and one in the Load Buffer. The RAT is updated to rename R3 to physical register RF0.
\end{tcolorbox}
\end{frame}

% Life of a Load - Step 3: Dispatch
\begin{frame}
\frametitle{The Life of a Load: Dispatch to AGU}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robOp={Ld},
    robValid={1},
    robRdy={0},
    robData={N/A},
    robDst={R3},
    rs1={\removedentry{RF0$\leftarrow$MEM(R2+50)}},
    lbV={1},
    lbAddr={Not Vld},
    lbBC={0},
    agu={\newentry{R2+50}}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The load address calculation is dispatched to the AGU when the source register R2 is ready. The RS entry is released after dispatch.
\end{tcolorbox}
\end{frame}

% Life of a Load - Step 4: Address Calculation
\begin{frame}
\frametitle{The Life of a Load: Address Calculation}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robOp={Ld},
    robValid={1},
    robRdy={0},
    robData={N/A},
    robDst={R3},
    lbV={1},
    lbAddr={\newentry{R2+50}},
    lbBC={0},
    agu={\removedentry{R2+50}},
    arrowDTLB=1
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The AGU computes the virtual address and updates the Load Buffer with R2+50. The address is then pipelined to the dTLB for translation.
\end{tcolorbox}
\end{frame}

% Life of a Load - Step 5: Dispatch to DCU
\begin{frame}
\frametitle{The Life of a Load: Blocking Check \& Dispatch to Cache}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robOp={Ld},
    robValid={1},
    robRdy={0},
    robData={N/A},
    robDst={R3},
    lbV={1},
    lbAddr={R2+50},
    lbBC={0},
    arrowCache=1
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The Load Buffer checks for memory hazards with prior stores. If no blocking conditions exist, the load is dispatched to the Data Cache (DCU).
\end{tcolorbox}
\end{frame}

% Life of a Load - Step 6: Data Return
\begin{frame}
\frametitle{The Life of a Load: Data Return}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robOp={Ld},
    robValid={1},
    robRdy={\newentry{1}},
    robData={\newentry{data}},
    robDst={R3},
    lbV={1},
    lbAddr={R2+50},
    lbBC={0},
    arrowCache=1
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The Data Cache returns the requested data. The result is sent to the RS (for forwarding to dependent instructions) and the ROB is updated with the load result.
\end{tcolorbox}
\end{frame}

% Life of a Load - Step 7: Retire
\begin{frame}
\frametitle{The Life of a Load: Retire \& Release}
\begin{center}
\LoadLifecycleDiagram[
    rat3={\removedentry{RF0}},
    robOp={\removedentry{Ld}},
    robValid={\removedentry{1}},
    robRdy={\removedentry{1}},
    robData={\removedentry{data}},
    robDst={\removedentry{R3}},
    lbV={\removedentry{1}},
    lbAddr={\removedentry{R2+50}},
    lbBC={\removedentry{0}},
    retire={\newentry{R3$\leftarrow$data}}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
When all previous instructions have retired, the load retires in-order. The RAT is updated to commit the architectural state. Finally, the Load Buffer and ROB entries are released for reuse.
\end{tcolorbox}
\end{frame}

% Summary slide for Life of a Load
\begin{frame}
\frametitle{The Life of a Load: Summary}
\small
\vspace{-6mm}
\begin{columns}[T]
\begin{column}{0.52\textwidth}
\begin{enumerate}
    \item \textbf{Initial State}
    \vspace{-2mm}
    \begin{itemize}
        \item Load waits in Instruction Queue
    \end{itemize}

    \item \textbf{Allocation}
    \vspace{-2mm}
    \begin{itemize}
        \item Allocate ROB, RS, Load Buffer entries
        \item Rename destination in RAT
    \end{itemize}

    \item \textbf{Dispatch to AGU}
    \vspace{-2mm}
    \begin{itemize}
        \item Wait for source operands ready
        \item Dispatch address calc to AGU
        \item Release RS entry
    \end{itemize}

    \item \textbf{Address Calculation}
    \vspace{-2mm}
    \begin{itemize}
        \item AGU computes virtual address
        \item Update Load Buffer
        \item Pipeline to dTLB
    \end{itemize}
\end{enumerate}
\end{column}

\begin{column}{0.52\textwidth}
\begin{enumerate}
    \setcounter{enumi}{4}
    \item \textbf{Blocking Check \& Dispatch}
    \vspace{-2mm}
    \begin{itemize}
        \item Check memory hazards
        \item If clear, dispatch to Data Cache
    \end{itemize}

    \item \textbf{Data Return}
    \vspace{-2mm}
    \begin{itemize}
        \item Cache returns data
        \item Update ROB
        \item Forward to dependent inst. via RS
    \end{itemize}

    \item \textbf{Retire \& Release}
    \vspace{-2mm}
    \begin{itemize}
        \item Wait for all prior inst. to retire
        \item Commit load
        \item Update RAT
        \item Release Load Buffer and ROB entries
    \end{itemize}
\end{enumerate}
\end{column}
\end{columns}
\end{frame}

\subsection{The Life of a Store}

% Life of a Store - Step 1: Initial State
\begin{frame}
\frametitle{The Life of a Store: Initial State}
\begin{center}
\LoadLifecycleDiagram[
    iq1={\newentry{MEM(R2+50)$\leftarrow$R3}},
    robDst={}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
Store instruction \texttt{MEM(R2+50)$\leftarrow$R3} is waiting in the Instruction Queue, ready to be allocated.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 2: Allocation
\begin{frame}
\frametitle{The Life of a Store: Allocation}
\begin{center}
\LoadLifecycleDiagram[
    robOp={\newentry{St}},
    robValid={\newentry{1}},
    robRdy={\newentry{0}},
    robData={\newentry{N/A}},
    robDst={\newentry{N/A}},
    iq1={\removedentry{MEM(R2+50)$\leftarrow$R3}},
    rs1={\newentry{STA: R2+50}},
    rs2={\newentry{STD: RF0}},
    sb1v={\newentry{1}},
    sb1addr={\newentry{Not Vld}},
    sb1data={\newentry{Not Vld}},
    sb1snr={}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The store is allocated with one ROB entry, two RS entries (STA and STD micro-ops), and one Store Buffer entry.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 3: Dispatch STA to AGU
\begin{frame}
\frametitle{The Life of a Store: Dispatch STA to AGU}
\begin{center}
\LoadLifecycleDiagram[
    robOp={St},
    robValid={1},
    robRdy={0},
    robData={N/A},
    robDst={N/A},
    rs1={\removedentry{STA: R2+50}},
    rs2={STD: RF0},
    sb1v={1},
    sb1addr={Not Vld},
    sb1data={Not Vld},
    sb1snr={},
    agu={\newentry{R2+50}}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The STA (Store Address) micro-op dispatches to the AGU when source register R2 is ready. The RS entry is released after dispatch.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 4: Address Calculation
\begin{frame}
\frametitle{The Life of a Store: Address Calculation}
\begin{center}
\LoadLifecycleDiagram[
    robOp={St},
    robValid={1},
    robRdy={0},
    robData={N/A},
    robDst={N/A},
    rs2={STD: RF0},
    sb1v={1},
    sb1addr={\newentry{R2+50}},
    sb1data={Not Vld},
    sb1snr={},
    agu={\removedentry{R2+50}},
    arrowDTLB=1
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The AGU computes the virtual address and updates the Store Buffer. The address is pipelined to the dTLB for translation and made available to dependent loads.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 5: Dispatch STD
\begin{frame}
\frametitle{The Life of a Store: Dispatch STD}
\begin{center}
\LoadLifecycleDiagram[
    robOp={St},
    robValid={1},
    robRdy={0},
    robData={N/A},
    robDst={N/A},
    rs2={\removedentry{STD: RF0}},
    sb1v={1},
    sb1addr={R2+50},
    sb1data={\newentry{RF0}},
    sb1snr={}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The STD (Store Data) micro-op dispatches when the data source RF0 is ready. The Store Buffer is updated with the data value, which can now be forwarded to dependent loads.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 6: Mark Ready
\begin{frame}
\frametitle{The Life of a Store: Mark Ready}
\begin{center}
\LoadLifecycleDiagram[
    robOp={St},
    robValid={1},
    robRdy={\newentry{1}},
    robData={N/A},
    robDst={N/A},
    sb1v={1},
    sb1addr={R2+50},
    sb1data={RF0},
    sb1snr={}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
Once both address and data are available, the Store Buffer updates the ROB entry's Valid field to 1, indicating the store is ready to retire.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 7: Retire & Mark Senior
\begin{frame}
\frametitle{The Life of a Store: Retire \& Mark Senior}
\begin{center}
\LoadLifecycleDiagram[
    robOp={\removedentry{St}},
    robValid={\removedentry{1}},
    robRdy={\removedentry{1}},
    robData={\removedentry{N/A}},
    robDst={\removedentry{N/A}},
    sb1v={1},
    sb1addr={R2+50},
    sb1data={RF0},
    sb1snr={\newentry{1}},
    retire={\newentry{Commit Store}}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
The store retires in-order when all previous instructions have retired. The ROB entry is released, and the store is marked as a Senior Store in the Store Buffer (Snr=1).
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 8: Write to Cache
\begin{frame}
\frametitle{The Life of a Store: Write to Cache}
\begin{center}
\LoadLifecycleDiagram[
    sb1v={1},
    sb1addr={R2+50},
    sb1data={RF0},
    sb1snr={1},
    arrowStoreCache=1
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
After retirement, the Store Buffer initiates a write to the Data Cache. Only senior (committed) stores write to memory.
\end{tcolorbox}
\end{frame}

% Life of a Store - Step 9: Release
\begin{frame}
\frametitle{The Life of a Store: Release}
\begin{center}
\LoadLifecycleDiagram[
    sb1v={\removedentry{1}},
    sb1addr={\removedentry{R2+50}},
    sb1data={\removedentry{RF0}},
    sb1snr={\removedentry{1}}
]
\end{center}
\vspace{-2mm}
\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
When the cache write completes, the Store Buffer entry is freed and available for reuse.
\end{tcolorbox}
\end{frame}

% Summary slide for Life of a Store
\begin{frame}
\frametitle{The Life of a Store: Summary}
\small
\vspace{-6mm}
\begin{columns}[T]
\begin{column}{0.52\textwidth}
\begin{enumerate}
    \item \textbf{Allocation}
    \vspace{-2mm}
    \begin{itemize}
        \item 1 ROB entry
        \item 2 RS entries (STA, STD)
        \item 1 Store Buffer entry
    \end{itemize}

    \item \textbf{STA Dispatch \& Calc}
    \vspace{-2mm}
    \begin{itemize}
        \item Dispatch to AGU when ready
        \item Compute virtual address
        \item Update Store Buffer
        \item Translate via dTLB
    \end{itemize}

    \item \textbf{STD Dispatch}
    \vspace{-2mm}
    \begin{itemize}
        \item Dispatch when data ready
        \item Update Store Buffer
        \item Enable forwarding to loads
    \end{itemize}
\end{enumerate}
\end{column}

\begin{column}{0.52\textwidth}
\begin{enumerate}
    \setcounter{enumi}{3}
    \item \textbf{Mark Ready}
    \vspace{-2mm}
    \begin{itemize}
        \item Update ROB Valid=1
        \item Store ready to retire
    \end{itemize}

    \item \textbf{Retire}
    \vspace{-2mm}
    \begin{itemize}
        \item In-order retirement
        \item Release ROB entry
        \item Mark as Senior Store
    \end{itemize}

    \item \textbf{Write \& Release}
    \vspace{-2mm}
    \begin{itemize}
        \item Write to Data Cache
        \item Release Store Buffer entry
    \end{itemize}
\end{enumerate}
\end{column}
\end{columns}
\end{frame}

\section{Question: Pipeline Timing Analysis}

\begin{frame}[fragile]{Question Setup}
\textbf{Given Code:}
\begin{minted}[fontsize=\footnotesize, frame=single, bgcolor=gray!10]{nasm}
1000  ld  R2=[R1+30]   ; R2=m[R1+30]
1004  st  [R2+20]=R1   ; m[R2+20]=R1
1008  ld  R3=[R1+100]  ; R3=m[R1+100]
100C  st  [R1+40]=R3   ; m[R1+40]=R3
1010  add R1=R1+10     ; R1=R1+10
1014  blt R1,100,1000  ; if (R1<100) PC=1000
\end{minted}

\textbf{Assumptions:}
\begin{itemize}
    \item Initial state: R1=R2=R3=10, memory address N contains value N
    \item Addresses are physical (no translation needed)
    \item Numbers in base 16
\end{itemize}
\end{frame}

\begin{frame}{Processor Configuration}
\textbf{Allocation:}
\begin{itemize}
    \item 4-wide allocation (at least 4 instructions ready each cycle)
    \item ROB, MOB, and RS are large and never fill
\end{itemize}

\textbf{Execution:}
\begin{itemize}
    \item Infinite execution units
    \item Instructions enter execution when data sources are ready
    \item Blocked instructions enter execution immediately when unblocked
    \item ALU: 1 cycle, Branch: 1 cycle
    \item Misprediction: Flush at T+1, allocate correct path at T+6
\end{itemize}

\textbf{Memory:}
\begin{itemize}
    \item L1 data cache: 1 cycle (initially empty)
    \item L2 data cache: 7 cycles (contains all requested addresses)
    \item Cache line size: 0x80 bytes
    \item Write policy: no-write-allocate
\end{itemize}
\end{frame}

\begin{frame}{Load Execution Details}
\textbf{Load Execution:}
\begin{itemize}
    \item Dispatched when address calculation sources are ready
    \item \textbf{Cycle 1:} Address calculation
    \item \textbf{Cycle 2:} Virtual$\rightarrow$Physical via dTLB + dependency check
    \begin{itemize}
        \item For each prior store: Check if store address known and differs, OR addresses match and store data ready
    \end{itemize}
    \item \textbf{Cycle 3:} Data from L1 (if hit) or forwarding from MOB
    \item \textbf{Cycle 10:} Data from L2 (if L1 miss, no forwarding)
    \item If dependency check fails: Load \textbf{blocked}, re-dispatched when condition clears (restart from cycle 2, skip address calculation)
\end{itemize}
\end{frame}

\begin{frame}{Store Execution and Commit}
\textbf{Store Execution:}
\begin{itemize}
    \item Address calculation: 1 cycle, written to MOB
    \item Data: Written to MOB independently when ready
    \item Cache write occurs \textbf{after commit}
\end{itemize}

\textbf{Commit:}
\begin{itemize}
    \item Instructions commit starting the cycle after execution completes
    \item Must wait for all previous instructions to commit (in-order)
    \item No limit on commits per cycle
\end{itemize}
\end{frame}

\begin{frame}[fragile, label=timeline-frame]
\frametitle{Instruction Execution Timeline}

\begin{adjustbox}{width=\textwidth,center}
\footnotesize
\begin{tikzpicture}[remember picture, overlay,
    green circle/.style={green!70!black, very thick},
    red circle/.style={red!80!black, very thick},
    blue circle/.style={blue!70!black, very thick},
    arrow style/.style={->, thick, black}
]
% Circle positioning variables
\def\circlexshift{2mm}
\def\circleyshift{1mm}
% Green circles - can be revealed with \onslide
\onslide<17>{\draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green2) circle (9pt);}
% Red circles around Std/Sta pairs
\onslide<17>{\draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red2) circle (12pt);}
\onslide<17>{\draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red3) circle (12pt);}
% Blue circle around T exe
\onslide<17>{\draw[blue circle] ([xshift=1mm,yshift=\circleyshift] pic cs:blue1) circle (6pt);}
% Arrow from 22 to 24 in T data ready column
\onslide<17>{\draw[arrow style, very thick] ([yshift=-2mm, xshift=2mm] pic cs:arrow1start) -- node[left, font=\tiny] {\rotatebox{90}{forwarding}} ([yshift=3mm, xshift=2mm] pic cs:arrow1end);}
% Circles for slide 19 (when row 8 appears)
\onslide<19>{
    % Green circles on store addresses
    \draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green1addr) circle (9pt);
    \draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green2) circle (9pt);
    \draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green3) circle (9pt);
    % Red circle on load address
    \draw[red circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:red1) circle (9pt);
    % Red circles on store execution times
    \draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red2) circle (12pt);
    \draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red3) circle (12pt);
    \draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red4) circle (12pt);
}
\end{tikzpicture}
\begin{tabular}{|c|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}[0]{*}[-3em]{\rotatebox[origin=l]{90}{Pdst}} & \multirow{2}[0]{*}[-3em]{Instruction} & \multicolumn{3}{c|}{Reg Values} & \multicolumn{2}{c|}{Mem} & \multicolumn{4}{c|}{Decode} & \multicolumn{6}{c|}{Execution Timeline} \\
\cline{3-17}
 & & R1 & R2 & R3 & addr & data & \rotatebox{90}{T alloc} & src1 & src2 & Imm & \rotatebox{90}{T src1 rdy} & \rotatebox{90}{T src2 rdy} & \rotatebox{90}{T exe} & \rotatebox{90}{Load block} & \rotatebox{90}{T data rdy} & \rotatebox{90}{T commit} \\
\hline
    \onslide<1->{0 & \texttt{ld R2=[R1+30]} & 10 & \underline{40} & 10 & 40 & 40} & \onslide<2->{1} & \onslide<2->{R1} & \onslide<2->{-} & \onslide<2->{30} & \onslide<3->{1} & \onslide<3->{-} & \onslide<4->{2} & \onslide<4->{\tiny ready} & \onslide<6->{11} & \onslide<7->{12} \\
    \onslide<1->{1 & \texttt{st [R2+20]=R1} & - & - & - & \tikzmark{green1addr}60 & 10} & \onslide<8->{1} & \onslide<8->{P0} & \onslide<8->{R1} & \onslide<8->{20} & \onslide<9->{11} & \onslide<9->{1} & \onslide<10->{\tikzmark{red2}\makecell{\tiny Std:2\\[-4pt]\tiny Sta:12}} & \onslide<10->{-} & \onslide<11->{12} & \onslide<12->{13} \\
    \onslide<1->{2 & \texttt{ld R3=[R1+100]} & - & - & \underline{110} & 110 & 110} & \onslide<13->{1} & \onslide<13->{R1} & \onslide<13->{-} & \onslide<13->{100} & \onslide<13->{1} & \onslide<13->{-} & \onslide<13->{2} & \onslide<13->{\tiny addr blk} & \onslide<13->{21} & \onslide<13->{22} \\
    \onslide<1->{3 & \texttt{st [R1+40]=R3} & - & - & - & \tikzmark{green2}50 & 110} & \onslide<14->{1} & \onslide<14->{R1} & \onslide<14->{P2} & \onslide<14->{40} & \onslide<14->{1} & \onslide<14->{21} & \onslide<14->{\tikzmark{red3}\makecell{\tiny Std:22\\[-4pt]\tiny Sta:2}} & \onslide<14->{-} & \onslide<14->{\tikzmark{arrow1start}22} & \onslide<14->{23} \\
    \onslide<1->{4 & \texttt{add R1=R1+10} & \underline{20} & - & - & - & -} & \onslide<15->{2} & \onslide<15->{R1} & \onslide<15->{-} & \onslide<15->{10} & \onslide<15->{2} & \onslide<15->{-} & \onslide<15->{\tikzmark{blue1}3} & \onslide<15->{-} & \onslide<15->{-} & \onslide<15->{23} \\
    \onslide<1->{5 & \texttt{blt (R1<100)} & 20 & 40 & 110 & - & -} & \onslide<16->{2} & \onslide<16->{P4} & \onslide<16->{-} & \onslide<16->{100} & \onslide<16->{3} & \onslide<16->{-} & \onslide<16->{4} & \onslide<16->{-} & \onslide<16->{-} & \onslide<16->{23} \\
    \hline
    \onslide<1->{6 & \texttt{ld R2=[R1+30]} & - & \underline{110} & - & 50 & 110} & \onslide<17->{2} & \onslide<17->{P4} & \onslide<17->{-} & \onslide<17->{30} & \onslide<17->{3} & \onslide<17->{-} & \onslide<17->{4} & \onslide<17->{\makecell{\tiny addr blk\\[-4pt]\tiny data blk}} & \onslide<17->{\tikzmark{arrow1end}24} & \onslide<17->{25} \\
    \onslide<1->{7 & \texttt{st [R2+20]=R1} & - & - & - & \tikzmark{green3}130 & 20} & \onslide<18->{2} & \onslide<18->{P6} & \onslide<18->{P4} & \onslide<18->{20} & \onslide<18->{24} & \onslide<18->{3} & \onslide<18->{\tikzmark{red4}\makecell{\tiny Std:4\\[-4pt]\tiny Sta:25}} & \onslide<18->{-} & \onslide<18->{25} & \onslide<18->{26} \\
    \onslide<1->{8 & \texttt{ld R3=[R1+100]} & - & - & \underline{120} & \tikzmark{red1}120 & 120} & \onslide<19->{3} & \onslide<19->{P4} & \onslide<19->{-} & \onslide<19->{100} & \onslide<19->{3} & \onslide<19->{-} & \onslide<19->{4} & \onslide<19->{\tiny addr blk} & \onslide<19->{27} & \onslide<19->{28} \\
    \onslide<1->{9 & \texttt{st [R1+40]=R3} & - & - & - & 60 & 120} & \onslide<20->{3} & \onslide<20->{P4} & \onslide<20->{P8} & \onslide<20->{40} & \onslide<20->{3} & \onslide<20->{27} & \onslide<20->{\makecell{\tiny Sta:4\\[-4pt]\tiny Std:28}} & \onslide<20->{-} & \onslide<20->{28} & \onslide<20->{29} \\
    \onslide<1->{10 & \texttt{add R1=R1+10} & \underline{30} & - & - & - & -} & \onslide<21->{3} & \onslide<21->{P4} & \onslide<21->{-} & \onslide<21->{10} & \onslide<21->{3} & \onslide<21->{-} & \onslide<21->{4} & \onslide<21->{-} & \onslide<21->{-} & \onslide<21->{29} \\
    \onslide<1->{11 & \texttt{blt (R1<100)} & 30 & 110 & 120 & - & -} & \onslide<22->{3} & \onslide<22->{P10} & \onslide<22->{-} & \onslide<22->{100} & \onslide<22->{4} & \onslide<22->{-} & \onslide<22->{5} & \onslide<22->{-} & \onslide<22->{-} & \onslide<22->{29} \\
    \hline
\end{tabular}
\end{adjustbox}

% Blue overlay for slides 5-7 (drawn after table so it appears on top)
\onslide<5-7>{
\begin{tikzpicture}[remember picture, overlay,
    node distance=6mm,
    bluecircle/.style={circle, draw=blue!70, fill=blue!70, fill opacity=1, text=white,
                       minimum width=0.8cm, minimum height=0.8cm, font=\bfseries\scriptsize},
    bluerect/.style={rectangle, draw=blue!70, fill=blue!70, fill opacity=1, text=white,
                     font=\bfseries, minimum width=1.5cm, minimum height=0.8cm},
    label/.style={blue!90!black, text width=1.7cm, align=center, font=\scriptsize}
]
    % Yellow background first (in front of underlying text, behind pipeline elements)
    \node[fill=yellow!30, fill opacity=1, draw=yellow!50, line width=1pt, minimum width=13cm, minimum height=3.3cm, rounded corners=5mm] at ([yshift=-0.7cm]current page.center) {};

    % Main nodes
    \node[bluecircle] at ([xshift=-3cm] current page.center) (n1) {1};
    \node[bluecircle, right=of n1] (n2) {2};
    \node[bluecircle, right=of n2] (n3) {3};
    \node[bluecircle, right=of n3] (n4) {4};

    % Dots
    \node[right=of n4] (dots) {\textcolor{blue!80!black}{$\bullet$ $\bullet$ $\bullet$}};

    % Node 10
    \node[bluecircle, right=of dots] (n10) {10};

    % Labels below nodes
    \node[label, below=2mm of n1] (l1) {Addr.\\ calculation};
    \node[label, below=2mm of n2] (l2) {Memory\\ checks};
    \node[label, below=2mm of n10] (l3) {L2 Hit};
    \node[bluerect, left=of l1] (load) {Load};

    % Arrow with "7 cycles" label
    \draw[<->, thick, blue!80!black]
        ([yshift=-1.4cm]n4.south west) -- node[below] (clabel) {7 cycles}
        ([yshift=-1.4cm]n10.east |- n4.south west);
\end{tikzpicture}
}

% Store overlay for slide 13 (after row 2 appears, before row 3)
\onslide<13>{
\begin{tikzpicture}[remember picture, overlay,
    node distance=8mm,
    bluecircle/.style={circle, draw=blue!70, fill=blue!70, fill opacity=1, text=white,
                       minimum width=0.8cm, minimum height=0.8cm, font=\bfseries\scriptsize},
    bluerect/.style={rectangle, draw=blue!70, fill=blue!70, fill opacity=1, text=white,
                     font=\bfseries, minimum width=1.5cm, minimum height=0.8cm},
    label/.style={blue!90!black, text width=1.9cm, align=center, font=\scriptsize}
]
    % Yellow background - top 1cm lower
    \node[fill=yellow!30, fill opacity=1, draw=yellow!50, line width=1pt, minimum width=13cm, minimum height=4cm, rounded corners=5mm] at ([yshift=-2.5cm]current page.center) {};

    % Main cycle nodes - positioned higher (separate row from Load boxes)
    \node[bluecircle] at ([xshift=-3.5cm, yshift=-10mm] current page.center) (n11) {11};
    \node[bluecircle, right=of n11] (n12) {12};
    \node[bluecircle, right=of n12] (n13) {13};
    \node[bluecircle, right=of n13] (n14) {14};

    % Dots
    \node[right=of n14] (dots) {\textcolor{blue!80!black}{$\bullet$ $\bullet$ $\bullet$}};

    % Node 21
    \node[bluecircle, right=of dots] (n21) {21};

    % Instruction boxes positioned below cycle nodes
    \node[bluerect, below=1mm of n11.south, xshift=-20mm, anchor=north] (load1) {Load};
    \node[bluerect, below=1mm of load1] (store) {Store};
    \node[bluerect, below=1mm of store] (load2) {Load};

    % Labels positioned relative to instruction boxes
    \node[label] at (n11.south |- load1) (l11) {R2 (pb0)\\is known};
    \node[label] at (n12.south |- store) (l12) {Addr. Calc:\\PB0+20};
    \node[label] at (n13.south |- load2) (l13) {Memory\\checks};
    \node[label] at (n14.south |- load2) (l14) {L1 miss};
    \node[label] at (n21.south |- load2) (l21) {L2 Hit};
\end{tikzpicture}
}

% Explanation box for slide 17 - bottom right position
\onslide<17>{
\begin{tikzpicture}[remember picture, overlay]
    \node[fill=yellow!30, fill opacity=1, draw=yellow!50, line width=1pt, rounded corners=3mm, font=\small, text width=9cm, align=center, anchor=south east]
        at ([yshift=0.3cm, xshift=-0.3cm]current page.south east)
        {Memory dependency: Load waits for data from previous store};
\end{tikzpicture}
}

% Explanation box for slide 19 - bottom right position
\onslide<19>{
\begin{tikzpicture}[remember picture, overlay]
    \node[fill=yellow!30, fill opacity=1, draw=yellow!50, line width=1pt, rounded corners=3mm, font=\small, text width=9cm, align=center, anchor=south east]
        at ([yshift=0.3cm, xshift=-0.3cm]current page.south east)
        {No match with prior stores (60, 50, 130); blocked until 25, re-checks 26, L1 hit 27};
\end{tikzpicture}
}

\vspace{0.3cm}
\onslide<14->{
\begin{columns}[T]
\begin{column}{0.48\textwidth}
\scriptsize
\textbf{Register Renaming:}
\begin{itemize}
\item Pi: Physical register i
\item Ri: Architectural register i
\end{itemize}
\end{column}
    \begin{column}{0.48\textwidth}
    \scriptsize
    \textbf{Store Load Block Codes:}
        \begin{itemize}
        \item 0: ready
        \item 1: address blocking
        \item 2: data not ready
        \end{itemize}
    \end{column}
\end{columns}
}
\end{frame}

\begin{frame}{Question 2: Top-Down Analysis}
\small
\textbf{Goal:} Analyze RS (Reservation Station) occupancy and identify performance bottlenecks

\vspace{3mm}
\textbf{Additional Constraints:}
\begin{itemize}
    \item RS: 6 entries (freed when instruction dispatches to execution)
    \item Stores occupy 2 RS entries (STA + STD), always allocated in same cycle
    \item If RS full: stall until free entry
    \item First branch mispredicts: flush at T(exe)+1, allocate correct path at T(exe)+1
    \item Instruction queue: full until second branch, then empty
\end{itemize}
\end{frame}

\begin{frame}[fragile, label=rs-timeline-frame]
\frametitle{Top-Down Analysis - Timeline with RS Entries}

\begin{columns}[T]
% Left column - Explanations (15%)
\begin{column}{0.2\textwidth}
%\footnotesize
\scriptsize
\vspace{-2mm}
\only<5>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Key:} Inst 4 allocated at cycle 2 (T alloc=2), same cycle when 4 uops execute (T exe=2).\\[2pt]
Those 4 executing uops free their RS entries, making room for inst 4:\\[2pt]
6 (occupied) - 4 (freed) + 1 (inst 4) = 3
\end{tcolorbox}
}%
\only<7>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Note:} Instruction 6 will never commit.\\[2pt]
The first branch (inst 5, \texttt{blt}) mispredicts at T=4, causing a flush at T=5.\\[2pt]
All instructions after the branch (inst 6+) are on the wrong path and will be squashed.
\end{tcolorbox}
}%
\only<8>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Note:} Instruction 7 (store) requires 2 RS entries (STA+STD), but RS was full at cycle 2.\\[2pt]
It could only be allocated at cycle 3 when inst 4 freed its RS entry (circled T exe=3 $\rightarrow$ -1).\\[2pt]
This instruction also won't commit due to the branch misprediction.
\end{tcolorbox}
}%
\only<9>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Note:} RS was full at cycle 3 (6 entries occupied).\\[2pt]
Instruction 8 could only be allocated at cycle 4 when 3 uops freed their RS entries (circled T exe=4 $\rightarrow$ -3).\\[2pt]
This instruction also won't commit due to branch misprediction.
\end{tcolorbox}
}%
\only<10>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Note:} Instruction 9 (store) also won't commit due to the branch misprediction.
\end{tcolorbox}
}%
\only<11>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Note:} RS was full at cycle 4 (6 entries occupied).\\[2pt]
Instruction 10 allocated at cycle 5 when flush occurs.\\[2pt]
After flush, only Sta (Pdst 1) and Std (Pdst 3) remain in RS---these are from the correct path but haven't executed yet.\\[2pt]
\#RS: 2 + 1 = 3
\end{tcolorbox}
}%
\end{column}

% Right column - Table (85%)
\begin{column}{0.8\textwidth}
\centering
%\footnotesize
\tiny
\setlength{\tabcolsep}{3pt}
\begin{tabular}{|c|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}[0]{*}[-3em]{\rotatebox[origin=l]{90}{Pdst}} & \multirow{2}[0]{*}[-3em]{Instruction} & \multicolumn{3}{c|}{Reg Values} & \multicolumn{2}{c|}{Mem} & \multicolumn{4}{c|}{Decode} & \multicolumn{6}{c|}{Execution Timeline} & \multirow{2}[0]{*}{\makecell{\#RS\\Entries}} \\
\cline{3-17}
 & & R1 & R2 & R3 & addr & data & \rotatebox{90}{T alloc} & src1 & src2 & Imm & \rotatebox{90}{T src1 rdy} & \rotatebox{90}{T src2 rdy} & \rotatebox{90}{T exe} & \rotatebox{90}{Load blk} & \rotatebox{90}{T data rdy} & \rotatebox{90}{T commit} & \\
\hline
    0 & \texttt{ld R2=[R1+30]} & 10 & 40 & 10 & 40 & 40 & 1 & R1 & - & 30 & 1 & - & \tikzmarknode{texe0}{2} & {\tiny ready} & 11 & 12 & \onslide<1->{0+1=1} \\
    1 & \texttt{st [R2+20]=R1} & - & - & - & 60 & 10 & 1 & P0 & R1 & 20 & 11 & 1 & \makecell{\tiny Std:\tikzmarknode{texe1}{2}\\\tiny Sta:12} & - & 12 & 13 & \onslide<2->{+2=3} \\
    2 & \texttt{ld R3=[R1+100]} & - & - & 110 & 110 & 110 & 1 & R1 & - & 100 & 1 & - & \tikzmarknode{texe2}{2} & {\tiny addr blk} & 21 & 22 & \onslide<3->{+1=4} \\
    3 & \texttt{st [R1+40]=R3} & - & - & - & 50 & 110 & 1 & R1 & P2 & 40 & 1 & 21 & \makecell{\tiny Std:22\\\tiny Sta:\tikzmarknode{texe3}{2}} & - & 22 & 23 & \onslide<4->{+2=\textcolor{red}{6}} \\
    4 & \texttt{add R1=R1+10} & 20 & - & - & - & - & 2 & R1 & - & 10 & 2 & - & \tikzmarknode{texe4}{3} & - & - & 23 & \onslide<5->{6\tikzmarknode{minus4}{-4}+1=3} \\
    5 & \texttt{blt (R1<100)} & 20 & 40 & 110 & - & - & 2 & P4 & - & 100 & 3 & - & \tikzmarknode{texe5}{4} & - & - & 23 & \onslide<6->{+1=4} \\
    6 & \texttt{ld R2=[R1+30]} & - & 110 & - & 50 & 110 & 2 & P4 & - & 30 & 3 & - & \tikzmarknode{texe6}{4} & {\tiny \makecell{addr blk\\data blk}} & \tikzmarknode{tdata6}{24} & \tikzmarknode{tcommit6}{25} & \onslide<7->{+1=5} \\
    7 & \texttt{st [R2+20]=R1} & - & - & - & 130 & 20 & \only<1-7>{\textcolor{orange}{?}}\only<8->{\textcolor{orange}{3}} & P6 & P4 & 20 & 24 & 3 & \makecell{\tiny Std:\tikzmarknode{texe7}{4}\\\tiny Sta:25} & - & \tikzmarknode{tdata7}{25} & \tikzmarknode{tcommit7}{26} & \onslide<8->{5\tikzmarknode{minus1}{-1}+2=\textcolor{red}{6}} \\
    8 & \texttt{ld R3=[R1+100]} & - & - & 120 & 120 & 120 & \only<1-8>{\textcolor{orange}{?}}\only<9->{\textcolor{orange}{4}} & P4 & - & 100 & 4 & - & 5 & {\tiny addr blk} & \tikzmarknode{tdata8}{27} & \tikzmarknode{tcommit8}{28} & \onslide<9->{6\tikzmarknode{minus3}{-3}+1=4} \\
    9 & \texttt{st [R1+40]=R3} & - & - & - & 60 & 120 & 4 & P4 & P8 & 40 & 4 & 27 & \makecell{\tiny Sta:5\\\tiny Std:28} & - & \tikzmarknode{tdata9}{28} & \tikzmarknode{tcommit9}{29} & \onslide<10->{+2=\textcolor{red}{6}} \\
    10 & \texttt{add R1=R1+10} & 30 & - & - & - & - & \only<1-10>{\textcolor{orange}{?}}\only<11->{\textcolor{orange}{5}} & P4 & - & 10 & 5 & - & 6 & - & - & 23 & \onslide<11->{2+1=3} \\
    11 & \texttt{blt (R1<100)} & 30 & 110 & 120 & - & - & 5 & P10 & - & 100 & 6 & - & 7 & - & - & 23 & \onslide<12->{+1=4} \\
    \hline
\end{tabular}
\end{column}
\end{columns}

% TikZ overlay for circles and arrows on slide 5
\onslide<5>{
\begin{tikzpicture}[remember picture, overlay]
    \draw[red, thick] (texe0) circle (4pt);
    \draw[red, thick] (texe1) circle (4pt);
    \draw[red, thick] (texe2) circle (4pt);
    \draw[red, thick] (texe3) circle (4pt);
    \draw[->, red, thick] (texe0) -- ([yshift=1mm]minus4);
    \draw[->, red, thick] (texe1) -- ([yshift=1mm]minus4);
    \draw[->, red, thick] (texe2) -- ([yshift=1mm]minus4);
    \draw[->, red, thick] (texe3) -- ([yshift=1mm]minus4);
\end{tikzpicture}
}

% X mark on T commit for inst 6 (from slide 7 onwards)
\onslide<7->{
\begin{tikzpicture}[remember picture, overlay]
    \node at (tcommit6.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
\end{tikzpicture}
}

% X mark on T commit for inst 7 (from slide 8 onwards)
\onslide<8->{
\begin{tikzpicture}[remember picture, overlay]
    \node at (tcommit7.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
\end{tikzpicture}
}

% Circle and arrow for slide 8
\onslide<8>{
\begin{tikzpicture}[remember picture, overlay]
    \draw[red, thick] (texe4) circle (4pt);
    \draw[->, red, thick] (texe4) -- ([yshift=1mm]minus1);
\end{tikzpicture}
}

% X mark on T commit for inst 8 (from slide 9 onwards)
\onslide<9->{
\begin{tikzpicture}[remember picture, overlay]
    \node at (tcommit8.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
\end{tikzpicture}
}

% Circles and arrows for slide 9: T exe=4 of Pdst 5,6,7 free RS entries
\onslide<9>{
\begin{tikzpicture}[remember picture, overlay]
    \draw[red, thick] (texe5) circle (4pt);
    \draw[red, thick] (texe6) circle (4pt);
    \draw[red, thick] (texe7) circle (4pt);
    \draw[->, red, thick] (texe5) -- ([yshift=1mm]minus3);
    \draw[->, red, thick] (texe6) -- ([yshift=1mm]minus3);
    \draw[->, red, thick] (texe7) -- ([yshift=1mm]minus3);
\end{tikzpicture}
}

% X mark on T commit for inst 9 (from slide 10 onwards)
\onslide<10->{
\begin{tikzpicture}[remember picture, overlay]
    \node at (tcommit9.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
\end{tikzpicture}
}

% X marks on T data rdy for inst 6,7,8,9 (from slide 11 onwards) - flushed instructions
\onslide<11->{
\begin{tikzpicture}[remember picture, overlay]
    \node at (tdata6.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
    \node at (tdata7.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
    \node at (tdata8.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
    \node at (tdata9.center) {\includegraphics[width=0.4cm]{figures/noun-x-2222229.png}};
\end{tikzpicture}
}
\end{frame}

\begin{frame}{Fill the Top-Down Table}

\begin{columns}[T]
% Left column - Table
\begin{column}{0.72\textwidth}
\centering
\footnotesize
\setlength{\tabcolsep}{5pt}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
\textbf{Cycle} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} \\
\hline
\textbf{Alloc Slot 0} & \only<1->{\checkmark} & \only<2->{\checkmark} & \only<3->{\checkmark} & \only<4->{\checkmark} & \only<5->{\checkmark} \\
\hline
\textbf{Alloc Slot 1} & \only<1->{\checkmark} & \only<2->{\checkmark} & & \only<4->{\checkmark} & \only<5->{\checkmark} \\
\hline
\textbf{Alloc Slot 2} & \only<1->{\checkmark} & \only<2->{\checkmark} & & & \\
\hline
\textbf{Alloc Slot 3} & \only<1->{\checkmark} & & & & \\
\hline
\hline
\textbf{Frontend Bound} & & & & & \only<5->{2} \\
\hline
\textbf{Backend Bound} & & \only<2->{1} & \only<3->{3} & \only<4->{2} & \\
\hline
\textbf{Retiring} & \only<1->{4} & \only<2->{2} & & & \only<5->{2} \\
\hline
\textbf{Bad Speculation} & & \only<2->{1} & \only<3->{1} & \only<4->{2} & \\
\hline
\end{tabular}

\vspace{4mm}

% Summary table
\only<6->{
\footnotesize
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Bad Speculation} & \textbf{Frontend Bound} & \textbf{Backend Bound} & \textbf{Retiring} \\
\hline
$\frac{4}{20} = 20\%$ & $\frac{2}{20} = 10\%$ & $\frac{6}{20} = 30\%$ & $\frac{8}{20} = 40\%$ \\
\hline
\end{tabular}
}
\end{column}

% Right column - Explanations
\begin{column}{0.28\textwidth}
\scriptsize
\only<1>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Cycle 1:} All 4 slots used for Pdst 0--3.\\[2pt]
All on correct path $\rightarrow$ Retiring = 4
\end{tcolorbox}
}%
\only<2>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Cycle 2:} 3 slots for Pdst 4--6.\\[2pt]
Pdst 4,5 correct $\rightarrow$ Retiring = 2\\[2pt]
Pdst 6 wrong path $\rightarrow$ Bad Spec = 1\\[2pt]
RS nearly full $\rightarrow$ Backend = 1
\end{tcolorbox}
}%
\only<3>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Cycle 3:} Only 1 slot for Pdst 7 (store).\\[2pt]
Wrong path $\rightarrow$ Bad Spec = 1\\[2pt]
RS full, 3 slots blocked $\rightarrow$ Backend = 3
\end{tcolorbox}
}%
\only<4>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Cycle 4:} 2 slots for Pdst 8--9.\\[2pt]
Both wrong path $\rightarrow$ Bad Spec = 2\\[2pt]
RS still constrained $\rightarrow$ Backend = 2
\end{tcolorbox}
}%
\only<5>{%
\begin{tcolorbox}[colback=yellow!30, colframe=yellow!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Cycle 5:} Flush at this cycle!\\[2pt]
2 slots for Pdst 10--11 (correct path after recovery).\\[2pt]
Retiring = 2\\[2pt]
Frontend recovering $\rightarrow$ Frontend = 2
\end{tcolorbox}
}%
\only<6->{%
\begin{tcolorbox}[colback=green!20, colframe=green!50, boxrule=1pt, arc=3mm, left=2pt, right=2pt, top=2pt, bottom=2pt]
\textbf{Summary:}\\[2pt]
5 cycles $\times$ 4 slots = 20\\[2pt]
Only 40\% of slots did useful work (Retiring).\\[2pt]
30\% wasted on backend stalls.\\[2pt]
20\% wasted on wrong-path instructions.
\end{tcolorbox}
}%
\end{column}
\end{columns}

\end{frame}



\end{document}