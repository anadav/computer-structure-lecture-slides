\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, fit, decorations.pathreplacing, matrix, backgrounds}
\usepackage{tcolorbox}
\usepackage{array}
\usepackage{listings}
\usepackage{pgfkeys}
\usepackage{adjustbox}
\usepackage[normalem]{ulem}
\usepackage{xparse}
\usetheme{Madrid}

\title{Out-of-Order Execution: Part III}
\subtitle{Example Problem}
\author{Computer Architecture 2340267}
\date{2025, Recitation \#9}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{Reminders: P6 Memory Operations}
\begin{itemize}
    \item P6 L1 and L2 caches are \textbf{non-blocking}
    \item RS (Reservation Station) solves false register dependencies
    \item MOB (Memory Order Buffer) solves memory dependencies
    \begin{itemize}
        \item Some dependencies can be resolved statically: \texttt{store r1,a; load r2,b}
        \item Problem: Some cannot: \texttt{store r1,[r3]; load r2,b}
    \end{itemize}
    \item Stores/loads are heavily used in x86 due to limited registers
    \item \textbf{Stores are NOT executed out-of-order} (difficult to undo)
    \begin{itemize}
        \item Decomposed into 2 uops: STA (Store Address) and STD (Store Data)
    \end{itemize}
    \item \textbf{Loads ARE executed out-of-order}
    \item Previous stores may have unknown virtual addresses
\end{itemize}
\end{frame}

\section{Memory Operation Lifecycle}

\begin{frame}{The Life of a Load}
\begin{itemize}
    \item \textbf{Allocation:} 1 entry in ROB, RS, and Load Buffer + RAT rename
    \item \textbf{Dispatch:} Address calculation to AGU when source ready $\rightarrow$ Release RS
    \item \textbf{Address Calculation:} AGU updates Load Buffer, pipeline to dTLB
    \item \textbf{Blocking Check:} Load Buffer checks for hazards, dispatches to DCU
    \item \textbf{Data Return:} DCU sends result to RS and updates ROB
    \item \textbf{Retire:} When all previous instructions retired $\rightarrow$ Update RAT
    \item \textbf{Release:} LB and ROB entries freed
\end{itemize}
\end{frame}

\begin{frame}{The Life of a Store}
\begin{itemize}
    \item \textbf{Allocation:} 1 ROB entry, 2 RS entries, 1 Store Buffer entry
    \item \textbf{STA (Store Address):}
    \begin{itemize}
        \item Dispatch when address sources ready $\rightarrow$ Release RS entry
        \item AGU calculates virtual address $\rightarrow$ Update Store Buffer
        \item Pipeline to dTLB $\rightarrow$ Physical address in Store Buffer
        \item Provides address to dependent loads
    \end{itemize}
    \item \textbf{STD (Store Data):}
    \begin{itemize}
        \item Dispatch when data ready $\rightarrow$ Update Store Buffer
        \item Provides data to dependent loads via forwarding
    \end{itemize}
    \item \textbf{Retire:} Store Buffer updates ROB as valid, marks as \textbf{Senior Store}
    \item \textbf{Write:} Store Buffer initiates DCU write \textbf{after} commit
    \item \textbf{Release:} Store Buffer entry freed after write completes
\end{itemize}
\end{frame}

% Define colors for the load lifecycle diagrams
\definecolor{lightblue}{RGB}{200,230,250}
\definecolor{lightyellow}{RGB}{255,250,200}
\definecolor{lightcyan}{RGB}{200,255,255}

% pgfkeys setup for Load Lifecycle diagram
\pgfkeys{
    /LoadLife/.is family, /LoadLife,
    default/.style = {
        % RAT physical registers
        rat0 = {}, rat1 = {}, rat2 = {}, rat3 = {},
        % ROB first entry
        robNum = {}, robValid = {}, robRdy = {}, robData = {},
        % Instruction Queue (2 rows)
        iq1 = {R3$\leftarrow$MEM(R2+50)}, iq2 = {},
        % RS content (2 rows)
        rs1 = {}, rs2 = {},
        % Store Buffer (2 data rows)
        sb1 = {}, sb2 = {},
        % Load Buffer (V, Addr, BC)
        lbV = {}, lbAddr = {}, lbBC = {},
        % EXE units (second row content)
        alu = {}, agu = {},
        % Retire
        retire = {},
        % Retire box (optional box next to retire)
        retirebox = {},
        % Arrow flags (0-4)
        arrows = 0,
    },
    rat0/.estore in = \ratZero,
    rat1/.estore in = \ratOne,
    rat2/.estore in = \ratTwo,
    rat3/.estore in = \ratThree,
    robNum/.estore in = \robNum,
    robValid/.estore in = \robValid,
    robRdy/.estore in = \robRdy,
    robData/.estore in = \robData,
    iq1/.estore in = \iqOne,
    iq2/.estore in = \iqTwo,
    rs1/.estore in = \rsOne,
    rs2/.estore in = \rsTwo,
    sb1/.estore in = \sbOne,
    sb2/.estore in = \sbTwo,
    lbV/.estore in = \lbV,
    lbAddr/.estore in = \lbAddr,
    lbBC/.estore in = \lbBC,
    alu/.estore in = \aluContent,
    agu/.estore in = \aguContent,
    retire/.estore in = \retireContent,
    retirebox/.estore in = \retireBoxContent,
    arrows/.estore in = \arrowFlags,
}

% Macro for creating load lifecycle diagram using matrix of nodes
% Usage: \LoadLifecycleDiagram[key=value, ...]
% Available keys:
%   rat0, rat1, rat2, rat3 - RAT physical register mappings
%   robNum, robValid, robRdy, robData - ROB entry fields
%   iq1, iq2 - Instruction Queue entries (2 rows)
%   rs1, rs2 - Reservation Station entries (2 rows)
%   sb1, sb2 - Store Buffer entries
%   lbV, lbAddr, lbBC - Load Buffer fields (Valid, Address, Blocking Conditions)
%   alu, agu - EXE unit contents (second row; first row is hard-coded as "ALU1"/"AGU")
%   retire - Retire stage content
%   retirebox - Optional box next to retire (for additional information)
%   arrows - Arrow display flag (0-4, controls which arrows are shown)
\newcommand{\LoadLifecycleDiagram}[1][]{%
    % Set defaults and process keys
    \pgfkeys{/LoadLife,default,#1}%
\begin{tikzpicture}[
    scale=0.7,
    every node/.style={transform shape},
    cell/.style={draw, rectangle, minimum height=4.5mm, text height=1.5ex, text depth=0.25ex, font=\tiny\ttfamily},
    headerbox/.style={draw, rectangle, fill=gray!10, minimum height=4.5mm, text height=1.5ex, text depth=0.25ex, font=\tiny\ttfamily, align=center},
    smallbox/.style={draw, rectangle, minimum width=1.2cm, minimum height=0.7cm, font=\scriptsize\ttfamily, align=center},
    labelstyle/.style={font=\scriptsize\bfseries\sffamily},
    greenarrow/.style={->, very thick, green!60!black, >=stealth}
]

% RAT (Register Alias Table)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:RAT},
        nodes={cell},
        row 1/.style={nodes={headerbox, minimum height=7mm}},
        column 1/.append style={nodes={text width=0.9cm, align=center, fill=gray!10}},
        column 2/.append style={nodes={text width=0.9cm, align=center, minimum width=0.9cm}},
        ampersand replacement=\&] (rat) {
    |[align=center]| {\scriptsize\shortstack{Arch\\Reg}} \& |[align=center]| {\scriptsize\shortstack{Phys\\Reg}} \\
    R0 \& \ifx\ratZero\empty{ }\else\ratZero\fi \\
    R1 \& \ifx\ratOne\empty{ }\else\ratOne\fi \\
    R2 \& \ifx\ratTwo\empty{ }\else\ratTwo\fi \\
    R3 \& \ifx\ratThree\empty{ }\else\ratThree\fi \\
};

% ROB (Reorder Buffer)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:ROB},
        right=0.7cm of rat.north east,
        anchor=north west,
        nodes={cell, align=center},
        row 1/.style={nodes={headerbox}},
        column 1/.append style={nodes={text width=0.35cm, fill=lightblue!30}},
        column 2/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        column 3/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        column 4/.append style={nodes={text width=0.7cm, fill=lightblue!30}},
        column 5/.append style={nodes={text width=0.5cm, fill=lightblue!30}},
        ampersand replacement=\&] (rob) {
    \# \& Val \& Rdy \& Data \& DST \\
    \robNum \& \robValid \& \robRdy \& \robData \& R3 \\
    0 \& {} \& {} \& {} \& {} \\
    0 \& {} \& {} \& {} \& {} \\
    0 \& {} \& {} \& {} \& {} \\
};

% RS (Reservation Station)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:RS},
        below right=0.25cm and 0.5cm of rob.north east,
        anchor=north west,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=2.8cm}},
        ampersand replacement=\&] (rs) {
    \ifx\rsOne\empty{ }\else\rsOne\fi \\
    \ifx\rsTwo\empty{ }\else\rsTwo\fi \\
};

% Instruction Queue (above RS label)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:Instruction Q},
        above=0.6cm of rs.north,
        anchor=south,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=2.8cm}},
        ampersand replacement=\&] (instq) {
    \ifx\iqOne\empty{ }\else\iqOne\fi \\
    \ifx\iqTwo\empty{ }\else\iqTwo\fi \\
};

% MOB (Memory Order Buffer) - Load Buffer
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:Load Buffer},
        right=0.5cm of rs.north east,
        anchor=north west,
        nodes={cell, align=center},
        row 1/.style={nodes={headerbox}},
        column 1/.append style={nodes={text width=0.6cm}},
        column 2/.append style={nodes={text width=1.0cm}},
        column 3/.append style={nodes={text width=0.5cm}},
        ampersand replacement=\&] (loadbuf) {
    V \& Addr \& BC \\
    \ifx\lbV\empty{ }\else\lbV\fi \& \ifx\lbAddr\empty{ }\else\lbAddr\fi \& \ifx\lbBC\empty{ }\else\lbBC\fi \\
};

% Store Buffer (above Load Buffer, matching its width)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]above:Store Buffer},
        above=0.6cm of loadbuf.north,
        anchor=south,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=0.6cm}},
        column 2/.append style={nodes={text width=1.0cm}},
        column 3/.append style={nodes={text width=0.5cm}},
        ampersand replacement=\&] (storebuf) {
    \ifx\sbOne\empty{ }\else\sbOne\fi \& {} \& {} \\
    \ifx\sbTwo\empty{ }\else\sbTwo\fi \& {} \& {} \\
};

% MOB label and cyan background using fit
\node[labelstyle, above=0.3cm of storebuf.north] (moblabel) {MOB};
\begin{scope}[on background layer]
\node[draw, fill=lightcyan, fit=(moblabel)(storebuf)(loadbuf), inner sep=2pt] {};
\end{scope}

% Data Cache
\node[smallbox, right=0.5cm of storebuf.north east, anchor=north west] (dcache) {Data\\Cache};

% dTLB (below Data Cache)
\node[smallbox, below=0.3cm of dcache.south west, anchor=north west] (dtlb) {dTLB};

% EXE block - Individual matrices
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        below=0.7cm of rs.south,
        anchor=north,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=1.2cm}},
        ampersand replacement=\&] (alu1) {
    ALU1 \\
    \ifx\aluContent\empty{ }\else\aluContent\fi \\
};

\node[font=\large, right=0.25cm of alu1] (dots) {$\bullet\bullet\bullet$};

\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        right=0.25cm of dots,
        anchor=west,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=1.2cm}},
        ampersand replacement=\&] (agu) {
    AGU \\
    \ifx\aguContent\empty{ }\else\aguContent\fi \\
};

% EXE label and yellow background using fit
\node[labelstyle, left=0.1cm of alu1.west, anchor=east] (exelabel) {EXE};
\begin{scope}[on background layer]
\node[draw, fill=lightyellow, fit=(exelabel)(alu1)(dots)(agu), inner sep=2pt] (exeblock) {};
\end{scope}

% Retire (below EXE block, aligned with RS west edge)
\matrix[matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        inner sep=0pt,
        label={[labelstyle]left:Retire},
        below=0.4cm of exeblock.south west,
        anchor=north west,
        nodes={cell, align=center},
        column 1/.append style={nodes={text width=1.8cm}},
        ampersand replacement=\&] (retire) {
    \ifx\retireContent\empty{ }\else\retireContent\fi \\
};

% Draw green arrows based on flags
\ifnum\arrowFlags>0 \draw[greenarrow] (rat.east) -- ++(0.25,0); \fi
\ifnum\arrowFlags>1 \draw[greenarrow] (agu.north) -- (rs.south); \fi
\ifnum\arrowFlags>2 \draw[greenarrow] (agu.east) -- (dtlb.west); \fi
\ifnum\arrowFlags>3 \draw[greenarrow] (loadbuf.east) -- (dcache.west); \fi

\end{tikzpicture}%
}

% Life of a Load - Step 1: Initial State
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    iq1={R3$\leftarrow$MEM(R2+50)},
    lbAddr={Not Valid},
    arrows=0
]
\end{center}
\end{frame}

% Life of a Load - Step 2: Allocation
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robNum={Ld},
    robValid={1},
    robRdy={0},
    robData={X},
    iq1={R3$\leftarrow$MEM(R2+50)},
    rs1={RF0$\leftarrow$MEM(R2+50)},
    lbV={1},
    lbAddr={Not Valid},
    lbBC={0},
    arrows=1
]
\end{center}
\vspace{-3mm}
\scriptsize
$\bullet$ 1 entry in the ROB, RS and Load Buffer + rename in RAT
\end{frame}

% Life of a Load - Step 3: Dispatch
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robNum={Ld},
    robValid={1},
    robRdy={0},
    robData={X},
    iq1={R3$\leftarrow$MEM(R2+50)},
    lbV={1},
    lbAddr={Not Valid},
    lbBC={0},
    agu={R2+50},
    arrows=2
]
\end{center}
\vspace{-3mm}
\scriptsize
$\bullet$ Dispatch Load address calculation to AGU when source is ready -- Release RS entry
\end{frame}

% Life of a Load - Step 4: Address Calculation
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robNum={Ld},
    robValid={1},
    robRdy={0},
    robData={X},
    iq1={R3$\leftarrow$MEM(R2+50)},
    lbV={1},
    lbAddr={V(R2+50)},
    lbBC={0},
    arrows=3
]
\end{center}
\vspace{-3mm}
\scriptsize
$\bullet$ AGU updates the address in the Load buffer. Pipeline proceeds to dTLB
\end{frame}

% Life of a Load - Step 5: Dispatch to DCU
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robNum={Ld},
    robValid={1},
    robRdy={0},
    robData={X},
    iq1={R3$\leftarrow$MEM(R2+50)},
    lbV={1},
    lbAddr={V(R2+50)},
    lbBC={0},
    arrows=4
]
\end{center}
\vspace{-3mm}
\scriptsize
$\bullet$ Load Buffer checks for blocking conditions and dispatches the Load to the DCU
\end{frame}

% Life of a Load - Step 6: Data Return
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    rat3={RF0},
    robNum={Ld},
    robValid={1},
    robRdy={1},
    robData={data},
    iq1={R3$\leftarrow$MEM(R2+50)},
    lbV={1},
    lbAddr={V(R2+50)},
    lbBC={0},
    arrows=4
]
\end{center}
\vspace{-3mm}
\scriptsize
$\bullet$ DCU sends the result to RS and updates the ROB with the load result
\end{frame}

% Life of a Load - Step 7: Retire
\begin{frame}
\frametitle{The Life of a Load\ldots}
\begin{center}
\LoadLifecycleDiagram[
    iq1={R3$\leftarrow$MEM(R2+50)},
    lbV={1},
    lbAddr={V(R2+50)},
    lbBC={0},
    arrows=0
]
\end{center}
\vspace{-3mm}
\scriptsize
$\bullet$ Load will retire as any other instruction (when all previous instructions have retired) -- RAT updated\\
$\bullet$ LB and ROB entry are released
\end{frame}

\section{Example Problem}

\begin{frame}[fragile]{Problem Setup}
\textbf{Given Code:}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
1000  ld  R2=[R1+30]   ; R2=m[R1+30]
1004  st  [R2+20]=R1   ; m[R2+20]=R1
1008  ld  R3=[R1+100]  ; R3=m[R1+100]
100C  st  [R1+40]=R3   ; m[R1+40]=R3
1010  add R1=R1+10     ; R1=R1+10
1014  blt R1,100,1000  ; if (R1<100) PC=1000
\end{lstlisting}

\textbf{Assumptions:}
\begin{itemize}
    \item Initial state: R1=R2=R3=10, memory address N contains value N
    \item Addresses are physical (no translation needed)
    \item Numbers in base 16
\end{itemize}
\end{frame}

\begin{frame}{Processor Configuration}
\textbf{Allocation:}
\begin{itemize}
    \item 4-wide allocation (at least 4 instructions ready each cycle)
    \item ROB, MOB, and RS are large and never fill
\end{itemize}

\textbf{Execution:}
\begin{itemize}
    \item Infinite execution units
    \item Instructions enter execution when data sources are ready
    \item Blocked instructions enter execution immediately when unblocked
    \item ALU: 1 cycle, Branch: 1 cycle
    \item Misprediction: Flush at T+1, allocate correct path at T+6
\end{itemize}

\textbf{Memory:}
\begin{itemize}
    \item L1 data cache: 1 cycle (initially empty)
    \item L2 data cache: 7 cycles (contains all requested addresses)
    \item Cache line size: 0x80 bytes
    \item Write policy: no-write-allocate
\end{itemize}
\end{frame}

\begin{frame}{Load/Store Execution Details}
\textbf{Load Execution:}
\begin{itemize}
    \item Dispatched when address calculation sources are ready
    \item \textbf{Cycle 1:} Address calculation
    \item \textbf{Cycle 2:} Virtual$\rightarrow$Physical via dTLB + dependency check
    \begin{itemize}
        \item For each prior store: Check if store address known and differs, OR addresses match and store data ready
    \end{itemize}
    \item \textbf{Cycle 3:} Data from L1 (if hit) or forwarding from MOB
    \item \textbf{Cycle 10:} Data from L2 (if L1 miss, no forwarding)
    \item If dependency check fails: Load \textbf{blocked}, re-dispatched when condition clears (restart from cycle 1)
\end{itemize}

\textbf{Store Execution:}
\begin{itemize}
    \item Address calculation: 1 cycle, written to MOB
    \item Data: Written to MOB independently when ready
    \item Cache write occurs \textbf{after commit}
\end{itemize}

\textbf{Commit:}
\begin{itemize}
    \item Instructions commit starting the cycle after execution completes
    \item Must wait for all previous instructions to commit (in-order)
    \item No limit on commits per cycle
\end{itemize}
\end{frame}

\begin{frame}[fragile, label=timeline-frame]
\frametitle{P6 $\mu$Architecture - Instruction Execution Timeline}

\begin{adjustbox}{width=\textwidth,center}
\footnotesize
\begin{tikzpicture}[remember picture, overlay,
    green circle/.style={green!70!black, very thick},
    red circle/.style={red!80!black, very thick},
    blue circle/.style={blue!70!black, very thick},
    arrow style/.style={->, thick, black}
]
% Circle positioning variables
\def\circlexshift{2mm}
\def\circleyshift{1mm}
% Green circles - can be revealed with \onslide
\onslide<15->{\draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green1addr) circle (9pt);}
\onslide<16->{\draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green2) circle (9pt);}
\onslide<17->{\draw[green circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:green3) circle (9pt);}
\onslide<24->{\draw[green circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red4) circle (12pt);}
% Red circle on address
\onslide<18->{\draw[red circle] ([xshift=\circlexshift,yshift=\circleyshift] pic cs:red1) circle (9pt);}
% Red circles around Std/Sta pairs
\onslide<19->{\draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red2) circle (12pt);}
\onslide<20->{\draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red3) circle (12pt);}
\onslide<21->{\draw[red circle] ([xshift=3mm,yshift=\circleyshift] pic cs:red4) circle (12pt);}
% Blue circle around T exe
\onslide<22->{\draw[blue circle] ([xshift=1mm,yshift=\circleyshift] pic cs:blue1) circle (9pt);}
% Arrow from 21 to 24 in T data ready column
\onslide<23->{\draw[arrow style, very thick] ([yshift=-2mm, xshift=2mm] pic cs:arrow1start) -- ([yshift=3mm, xshift=2mm] pic cs:arrow1end);}
\end{tikzpicture}
\begin{tabular}{|c|l|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\#} & \multirow{2}{*}{Instruction} & \multicolumn{3}{c|}{Reg Values} & \multicolumn{2}{c|}{Mem} & \multicolumn{10}{c|}{Execution Timeline} \\
\cline{3-17}
 & & R1 & R2 & R3 & addr & data & \rotatebox{90}{T alloc} & src1 & src2 & Imm & \rotatebox{90}{T src1 rdy} & \rotatebox{90}{T src2 rdy} & \rotatebox{90}{T exe} & \rotatebox{90}{Load block} & \rotatebox{90}{T data rdy} & \rotatebox{90}{T commit} \\
\hline
    \onslide<1->{0 & \texttt{ld R2=[R1+30]} & 10 & \underline{40} & 10 & 40 & 40} & \onslide<2->{1} & \onslide<2->{R1} & \onslide<2->{-} & \onslide<2->{30} & \onslide<3->{1} & \onslide<3->{-} & \onslide<4->{2} & \onslide<4->{\tiny ready} & \onslide<6->{11} & \onslide<7->{12} \\
    \onslide<1->{1 & \texttt{st [R2+20]=R1} & - & - & - & \tikzmark{green1addr}\underline{60} & 10} & \onslide<8->{1} & \onslide<8->{P0} & \onslide<8->{R1} & \onslide<8->{20} & \onslide<9->{11} & \onslide<9->{1} & \onslide<10->{\tikzmark{red2}\makecell{\tiny Std:2\\[-4pt]\tiny Sta:12}} & \onslide<10->{-} & \onslide<11->{12} & \onslide<12->{13} \\
    \onslide<1->{2 & \texttt{ld R3=[R1+100]} & - & - & \underline{110} & \underline{110} & 110} & \onslide<25->{1} & \onslide<25->{R1} & \onslide<25->{-} & \onslide<25->{100} & \onslide<25->{1} & \onslide<25->{-} & \onslide<25->{2} & \onslide<25->{\tiny addr blk} & \onslide<25->{21} & \onslide<25->{22} \\
    \onslide<1->{3 & \texttt{st [R1+40]=R3} & - & - & - & \tikzmark{green2}50 & 110} & \onslide<25->{1} & \onslide<25->{R1} & \onslide<25->{P2} & \onslide<25->{40} & \onslide<25->{1} & \onslide<25->{21} & \onslide<25->{\tikzmark{red3}\makecell{\tiny Std:22\\[-4pt]\tiny Sta:2}} & \onslide<25->{-} & \onslide<25->{\tikzmark{arrow1start}22} & \onslide<25->{23} \\
    \onslide<1->{4 & \texttt{add R1=R1+10} & \underline{20} & - & - & - & -} & \onslide<25->{2} & \onslide<25->{R1} & \onslide<25->{-} & \onslide<25->{10} & \onslide<25->{2} & \onslide<25->{-} & \onslide<25->{\tikzmark{blue1}3} & \onslide<25->{-} & \onslide<25->{-} & \onslide<25->{23} \\
    \onslide<1->{5 & \texttt{blt (R1<100)} & 20 & 40 & 110 & - & -} & \onslide<25->{2} & \onslide<25->{P4} & \onslide<25->{-} & \onslide<25->{100} & \onslide<25->{3} & \onslide<25->{-} & \onslide<25->{4} & \onslide<25->{-} & \onslide<25->{-} & \onslide<25->{23} \\
    \hline
    \onslide<1->{6 & \texttt{ld R2=[R1+30]} & - & \underline{110} & - & \underline{50} & 110} & \onslide<25->{2} & \onslide<25->{P4} & \onslide<25->{-} & \onslide<25->{30} & \onslide<25->{3} & \onslide<25->{-} & \onslide<25->{4} & \onslide<25->{\makecell{\tiny addr blk\\[-4pt]\tiny data blk}} & \onslide<25->{\tikzmark{arrow1end}24} & \onslide<25->{25} \\
    \onslide<1->{7 & \texttt{st [R2+20]=R1} & - & - & - & \tikzmark{green3}130 & 20} & \onslide<25->{2} & \onslide<25->{P6} & \onslide<25->{P4} & \onslide<25->{20} & \onslide<25->{24} & \onslide<25->{3} & \onslide<25->{\tikzmark{red4}\makecell{\tiny Std:4\\[-4pt]\tiny Sta:25}} & \onslide<25->{-} & \onslide<25->{25} & \onslide<25->{26} \\
    \onslide<1->{8 & \texttt{ld R3=[R1+100]} & - & - & \underline{120} & \tikzmark{red1}120 & 120} & \onslide<25->{3} & \onslide<25->{P4} & \onslide<25->{-} & \onslide<25->{100} & \onslide<25->{3} & \onslide<25->{-} & \onslide<25->{4} & \onslide<25->{\tiny addr blk} & \onslide<25->{27} & \onslide<25->{28} \\
    \onslide<1->{9 & \texttt{st [R1+40]=R3} & - & - & - & 60 & 120} & \onslide<25->{3} & \onslide<25->{P4} & \onslide<25->{P8} & \onslide<25->{40} & \onslide<25->{3} & \onslide<25->{27} & \onslide<25->{\makecell{\tiny Sta:4\\[-4pt]\tiny Std:28}} & \onslide<25->{-} & \onslide<25->{28} & \onslide<25->{29} \\
    \onslide<1->{10 & \texttt{add R1=R1+10} & \underline{30} & - & - & - & -} & \onslide<25->{3} & \onslide<25->{P4} & \onslide<25->{-} & \onslide<25->{10} & \onslide<25->{3} & \onslide<25->{-} & \onslide<25->{4} & \onslide<25->{-} & \onslide<25->{-} & \onslide<25->{29} \\
    \onslide<1->{11 & \texttt{blt (R1<100)} & 30 & 110 & 120 & - & -} & \onslide<25->{3} & \onslide<25->{P10} & \onslide<25->{-} & \onslide<25->{100} & \onslide<25->{4} & \onslide<25->{-} & \onslide<25->{5} & \onslide<25->{-} & \onslide<25->{-} & \onslide<25->{29} \\
    \hline
\end{tabular}
\end{adjustbox}

% Blue overlay for slides 5-7 (drawn after table so it appears on top)
\onslide<5-7>{
\begin{tikzpicture}[remember picture, overlay,
    node distance=6mm,
    bluecircle/.style={circle, draw=blue!70, fill=blue!70, fill opacity=1, text=white, 
                       minimum width=0.8cm, minimum height=0.8cm, font=\bfseries\scriptsize},
    bluerect/.style={rectangle, draw=blue!70, fill=blue!70, fill opacity=1, text=white, 
                     font=\bfseries, minimum width=1.5cm, minimum height=0.8cm},
    label/.style={blue!90!black, text width=1.7cm, align=center, font=\scriptsize}
]
    % Yellow background first (in front of underlying text, behind pipeline elements)
    \node[fill=yellow!30, fill opacity=1, draw=yellow!50, line width=1pt, minimum width=13cm, minimum height=3.3cm, rounded corners=5mm] at ([yshift=-0.7cm]current page.center) {};
    
    % Main nodes
    \node[bluecircle] at ([xshift=-3cm] current page.center) (n1) {1};
    \node[bluecircle, right=of n1] (n2) {2};
    \node[bluecircle, right=of n2] (n3) {3};
    \node[bluecircle, right=of n3] (n4) {4};
    
    % Dots
    \node[right=of n4] (dots) {\textcolor{blue!80!black}{$\bullet$ $\bullet$ $\bullet$}};
    
    % Node 10
    \node[bluecircle, right=of dots] (n10) {10};
    
    % Labels below nodes
    \node[label, below=2mm of n1] (l1) {Addr.\\ calculation};
    \node[label, below=2mm of n2] (l2) {Memory\\ checks};
    \node[label, below=2mm of n10] (l3) {L2 Hit};
    \node[bluerect, left=of l1] (load) {Load};
    
    % Arrow with "7 cycles" label
    \draw[<->, thick, blue!80!black] 
        ([yshift=-1.4cm]n4.south west) -- node[below] (clabel) {7 cycles} 
        ([yshift=-1.4cm]n10.east |- n4.south west);
\end{tikzpicture}
}

\vspace{0.3cm}
\onslide<14->{
\begin{columns}[T]
\begin{column}{0.48\textwidth}
\scriptsize
\textbf{Register Renaming:}
\begin{itemize}
\item Pi: Physical register i
\item Ri: Architectural register i
\end{itemize}
\end{column}
    \begin{column}{0.48\textwidth}
    \scriptsize
    \textbf{Store Load Block Codes:}
        \begin{itemize}
        \item 0: ready
        \item 1: address blocking
        \item 2: data not ready
        \end{itemize}
    \end{column}
\end{columns}
}
\end{frame}

% Againframe to continue without overlay
\againframe<8->[noframenumbering]{timeline-frame}



\begin{frame}{Fill the top-down table}

% Second table (main table)
\begin{table}
\centering
\small
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{Cycle} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{5} & \textbf{6} & \textbf{7} & \textbf{8} & \textbf{9} & \textbf{10} & \textbf{11} \\
\hline
\textbf{Backend Stall} & 0 & \only<2->{} & \only<4->{} & \only<6->{} & \only<8->{} & \only<10->{1} & \only<10->{1} & \only<10->{1} & \only<10->{1} & \only<10->{0} & \only<10->{0} \\
\hline
\textbf{Alloc Slot 0} & & \only<2->{\checkmark} & \only<4->{\checkmark} & \only<6->{\checkmark} & \only<8->{\checkmark} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} \\
\hline
\textbf{Alloc Slot 1} & & \only<2->{\checkmark} & \only<4->{\checkmark} & \only<6->{\checkmark} & \only<8->{\checkmark} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} \\
\hline
\textbf{Alloc Slot 2} & & \only<2->{\checkmark} & \only<4->{\checkmark} & \only<6->{} & \only<8->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} \\
\hline
\textbf{Alloc Slot 3} & & \only<2->{\checkmark} & \only<4->{} & \only<6->{} & \only<8->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} \\
\hline
\hline
\textbf{Frontend Bound} & & \only<3->{} & \only<5->{} & \only<7->{} & \only<9->{} & \only<10->{2} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \\
\hline
\textbf{Backend Bound} & & \only<3->{} & \only<5->{} & \only<7->{} & \only<9->{} & \only<10->{1} & \only<10->{3} & \only<10->{} & \only<10->{2} & \only<10->{} & \\
\hline
\textbf{Retiring} & & \only<3->{4} & \only<5->{2} & \only<7->{2} & \only<9->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \only<10->{} & \\
\hline
\textbf{Bad Speculation} & & \only<3->{} & \only<5->{1} & \only<7->{} & \only<9->{} & \only<10->{1} & \only<10->{} & \only<10->{} & \only<10->{2} & \only<10->{} & \\
\hline
\end{tabular}
\end{table}

\vspace{0.5cm}

% First table (summary)
\only<11->{
\begin{table}
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Bad Speculation} & \textbf{Frontend Bound} & \textbf{Backend Bound} & \textbf{Retiring} \\
\hline
$\frac{4}{20} = 20\%$ & $\frac{2}{20} = 10\%$ & $\frac{6}{20} = 30\%$ & $\frac{8}{20} = 40\%$ \\
\hline
\end{tabular}
\end{table}
}

\end{frame}



\end{document}