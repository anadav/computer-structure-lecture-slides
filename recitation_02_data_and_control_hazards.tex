\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{bytefield}
\usepackage{tikz}
\usepackage{circuitikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, automata, matrix}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{minted}
\usepackage{pifont}
\usetheme{Madrid}

\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={(*@}{@*)},
}

\newcommand{\xmark}{\ding{55}} % Cross mark

% Define colors for pipeline diagrams
\definecolor{normalexec}{RGB}{46, 125, 50}
\definecolor{stallcolor}{RGB}{255, 193, 7}
\definecolor{flushcolor}{RGB}{211, 47, 47}
\definecolor{emptycolor}{RGB}{238, 238, 238}

% Program code - can't be in macro due to lstlisting limitations

% 4-state machine macro
\newcommand{\fourstatemachine}[1][0.6]{
\begin{tikzpicture}[scale=#1, node distance=2.5cm, auto]
    \node[state, fill=red!20] (00) {00};
    \node[state, fill=orange!20, draw=blue, thick, right of=00] (01) {01};
    \node[state, fill=yellow!20, right of=01] (10) {10};
    \node[state, fill=green!20, right of=10] (11) {11};
    
    \path[->] 
    (00) edge[loop left] node{\tiny NT} (00)
    (00) edge[above, bend left] node{\tiny T} (01)
    (01) edge[below, bend left] node{\tiny NT} (00)
    (01) edge[above, bend left] node{\tiny T} (10)
    (10) edge[below, bend left] node{\tiny NT} (01)
    (10) edge[above, bend left] node{\tiny T} (11)
    (11) edge[below, bend left] node{\tiny NT} (10)
    (11) edge[loop right] node{\tiny T} (11);
\end{tikzpicture}
}

% Prediction table macro with progressive revelation
\newcommand{\predictiontable}{
\begin{table}
\centering
\scriptsize
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\textbf{Cycle} & \textbf{R1} & \textbf{R2} & \textbf{Current} & \textbf{Prediction} & \textbf{Actual} & \textbf{Next} & \textbf{Misprediction} \\
 & & & \textbf{State} & & & \textbf{State} & \\
\hline
Loop1 & 2 & 2 & & & & & \\
\hline
\pause BNEQ & 2 & 1 & 01 & not taken & taken & 10 & \checkmark \\
\hline
\pause BNEQ & 2 & 0 & 10 & taken & not taken & 01 & \checkmark \\
\hline
\pause Loop1 & 3 & 3 & & & & & \\
\hline
\pause BNEQ & 3 & 2 & 01 & not taken & taken & 10 & \checkmark \\
\hline
\pause BNEQ & 3 & 1 & 10 & taken & taken & 11 & \\
\hline
\pause BNEQ & 3 & 0 & 11 & taken & not taken & 10 & \checkmark \\
\hline
\end{tabular}
\end{table}
}

% BTB Structure diagram macro
\newcommand{\btbdiagram}{
\begin{tikzpicture}[scale=0.8]
    % BTB table as matrix using your style
    \matrix[matrix of nodes,
            column sep=-\pgflinewidth,
            row sep=-\pgflinewidth,
            inner sep=0pt,
            anchor=north,
            nodes in empty cells,
            nodes={draw, align=center},
            column 1/.append style={nodes={text width=1.8cm, minimum height=0.25cm}},
            column 2/.append style={nodes={text width=1.8cm, minimum height=0.25cm}},
            column 3/.append style={nodes={text width=1.2cm, minimum height=0.25cm}},
            ampersand replacement=\&
        ] (btb) {
        \& \& \\
        \& \& \\
        \& \& \\
        \& \& \\
        \& \& \\
        \& \& \\
        \& \& \\
        \& \& \\
    };
    
    \node[draw, rectangle, above=8mm of btb-1-1.north, xshift=-8mm, font=\scriptsize] (pc) {PC of instruction to fetch};
    % Table headers positioned relative to matrix columns
    \node[above=1mm of btb-1-1.north, text depth=0ex, font=\scriptsize] {Look up};
    \node[above=1mm of btb-1-2.north, text depth=0ex, font=\scriptsize] {Predicted PC};
    
    % BTB label positioned relative to matrix left
    \node[rotate=90, left=5mm of btb.north west, font=\tiny, anchor=north east] {$\leftarrow$ \# of entries $\rightarrow$};
    
    % Comparator positioned relative to first column bottom
    \node[circle, draw, inner sep=1pt, font=\tiny] (comp) at ($ (btb-8-1.south) + (0, -0.4) $) {=};
    
    % Arrows using relative positioning
    \draw[->] (pc) -- (btb-1-1.north -| pc);
    \draw[->] ([xshift=2mm]pc.south west) |- (comp.west);
    \draw[->] (btb-8-1.south) -- (comp);

    \node[right=8mm of comp, font=\tiny, align=left, text=red] (no) {not predicted\\to be branch.\\ $\Rightarrow$ Proceed};

    % Output logic positioned relative to comparator
    \draw[->] (comp.east) -- node[above, font=\tiny]{no} (no);

    \node[below=4mm of comp, font=\tiny, align=left, text=green] (yes) {predicted to\\be branch.\\ $\Rightarrow$ Use target};
    \draw[->] (comp.south) -- node[left, font=\tiny]{yes} (yes);
    
    % Prediction output from third column
    \draw[->] ([xshift=3mm]btb-8-3.south) -- ++(0, -8mm) node[below, align=center, font=\tiny] {Branch prediction\\Taken/Not taken};
\end{tikzpicture}
}

% Boolean flags for pipeline processor configuration
\newif\ifshowforwarding
\newif\ifshowhdu

% Pipeline processor macro with configurable HDU and forwarding
% Parameters: #1 = show stage labels (true/false), #2 = show forwarding (true/false), #3 = show HDU (true/false)
\newif\ifshowstagelabels

\newcommand{\pipelineprocessor}[3][false]{%
% Set the boolean flags based on parameters
\csname showforwarding#2\endcsname
\csname showhdu#3\endcsname
\csname showstagelabels#1\endcsname
\begin{circuitikz}[remember picture, scale=0.7, transform shape,
    % Component styles - avoid using scale
    component/.style={draw, thick, minimum height=0.8cm},
    pipeline_reg/.style={draw, thick, fill=gray!20, minimum width=6mm, minimum height=6.8cm},
    stage_label/.style={draw, thick, fill=blue!60, text=white, font=\bfseries, minimum width=0.8cm, minimum height=0.5cm},
    control_block/.style={draw, thick, fill=orange!30, rounded corners=3pt, font=\scriptsize,
                          ellipse, minimum height=0.5cm, minimum width=0.5cm},
    hazard_unit/.style={muxdemux, muxdemux def={Lh=1, NL=3, Rh=1, NR=3, NB=6, w=2.5, square pins=1}, 
                       external pins width=0, fill=red!60, text=white},
    memory_block/.style={muxdemux, muxdemux def={Lh=5, NL=5, Rh=5, NR=1, NT=5, w=3, square pins=1}, 
                        external pins width=0, align=center, text depth=9ex, fill=yellow!20},
    imem_block/.style={muxdemux, muxdemux def={Lh=4, NL=3, Rh=4, NR=3, w=3.6, square pins=1}, 
                        external pins width=0, align=center, text depth=6ex, fill=yellow!20},
    regfile/.style={muxdemux, muxdemux def={Lh=5.5, NL=5, Rh=5.5, NR=2, NB=1, NT=3, w=3.2, square pins=1}, 
                    external pins width=0, fill=cyan!20, align=center},
    alu_style/.style={muxdemux, muxdemux def={Lh=2.6, Rh=1.5, NL=2, NR=5, NB=1, w=1.3, inset w=0.5, inset Lh=2, inset Rh=0, square pins=1},
                     external pins width=0, fill=green!20, font=\scriptsize},
    adder/.style={muxdemux, muxdemux def={Lh=2, NL=2, Rh=0.7, NR=1, w=1.2, inset w=0.5, inset Lh=1, inset Rh=0, square pins=1},
                     external pins width=0, fill=cyan!20, font=\scriptsize},
    mux2/.style={muxdemux, muxdemux def={Lh=2.2, Rh=1.1, NL=2, NR=1, NB=1, NT=1, w=0.8}, 
                 external pins width=0},
    mux2r/.style={muxdemux, muxdemux def={Lh=1.3, Rh=2.4, NL=1, NR=2, NB=1, NT=1, w=0.8}, fill=cyan!20,
                 external pins width=0},
    mux3/.style={muxdemux, muxdemux def={Lh=2, Rh=1, NL=3, NR=1, NB=1, NT=1, w=0.8}, 
                 external pins width=0},
    mux4/.style={muxdemux, muxdemux def={Lh=2, Rh=1, NL=4, NR=1, NB=1, NT=1, w=0.8}, 
                 external pins width=0},
    mux2b/.style={muxdemux, muxdemux def={Lh=1.4, Rh=0.7, NL=2, NR=1, NB=1, NT=1, w=0.8}, 
                 external pins width=0},
    arrow/.style={->, >=stealth, thick},
    data_path/.style={arrow, black},
    control_path/.style={arrow, orange!70},
    hazard_path_input/.style={arrow, red!70},
    hazard_path/.style={arrow, red!70, dashed},
    forward_path/.style={arrow, orange!50},
    forward_path_a/.style={arrow, blue},
    forward_path_b/.style={arrow, green},
    control_signal/.style={draw, thick, fill=orange!30, minimum width=6mm, minimum height=0.3cm, inner sep=1pt, font=\tiny},
    data_latch/.style={draw, thick, fill=cyan!20, minimum width=6mm, minimum height=0.3cm, inner sep=1pt, font=\tiny},
    % Connector circles
    data_connector/.style={circle, fill, inner sep=1.2pt},
    control_connector/.style={data_connector, orange!30},
    hazard_connector/.style={data_connector, red!70},
    forward_connector_a/.style={data_connector, blue},
    forward_connector_b/.style={data_connector, green},
    % Path labels
    path_label/.style={font=\tiny, midway, above, yshift=-3},
    control_label/.style={path_label, text=orange!70},
    forward_path_a/.style={path_label, text=blue},
    node distance=5mm and 5mm,
]

% Define origin
\coordinate (origin) at (0,0);

% IF Stage Components
\node[component, fill=yellow!30, minimum width=0.8cm] (PC) {PC};
\node[imem_block, right=of PC, anchor=blpin 3] (IMem) {Instruction\\Memory};
\node[adder, above=3mm of IMem.north east, anchor=south east] (PCadder) {+};
\node[mux2r, anchor=south east] (PCSrcMux) at ([xshift=-9mm, yshift=0mm]PCadder.north west) {};
\node[pipeline_reg, right=of IMem.brpin 3, yshift=8mm] (IFID) {};
\node[data_latch] (Instruction) at (IMem.rpin 3 -| IFID) {\rotatebox{90}{instruction}};
\node[data_latch] (IFNewPC) at (PCadder.brpin 1 -| IFID) {\rotatebox{90}{NewPC}};
\node[font=\scriptsize, left=5mm of PCadder.blpin 2] (four) {4};

% ID Stage Components
\node[regfile] (RegFile) at ([yshift=2mm, xshift=3cm]IFID)  {\rotatebox{90}{Register File}};
\node[align=left, xshift=3mm, font=\tiny] at (RegFile.blpin 1) {read\\reg 1};
\node[align=left, xshift=3mm, font=\tiny] at (RegFile.blpin 2) {read\\reg 2};
\node[align=left, xshift=3mm, font=\tiny] at (RegFile.blpin 3) {write\\reg};
\node[align=left, xshift=3mm, font=\tiny] at (RegFile.blpin 4) {write\\data};
\node[align=left, xshift=3mm, font=\tiny, text=orange] at (RegFile.blpin 5) {write\\enable};
% Create coordinates for RegFile outputs with y-shifts
\coordinate (RegFile_out2) at ([yshift=1mm]RegFile.brpin 2);

% Create pipeline register first to establish positions
\node[pipeline_reg, anchor=west] (IDEX) at ([xshift=4mm]RegFile.east |- IFID) {};

% Control signal blocks in pipeline registers - define early for positioning
\coordinate (WB1_pos) at (IDEX.north);
\node[control_signal, anchor=north] (WB1) at (WB1_pos) {WB};
\node[control_signal] (M1) at (WB1.south) [anchor=north, yshift=-0.1cm] {M};
\node[control_signal] (EX1) at (M1.south) [anchor=north, yshift=-0.1cm] {EX};

% Control Unit - now M1 exists
\ifshowhdu
\node[control_block, above=3mm of RegFile.btpin 1, inner sep=1pt] (Control) {\rotatebox{90}{Control}};
\else
\node[control_block, inner sep=1pt] (Control) at (RegFile.btpin 1 |- M1) {\rotatebox{90}{Control}};
\fi

\ifshowhdu
    % Hazard Detection Unit
    \node[hazard_unit, above=of Control.north west, yshift=-3mm, xshift=-8mm] (HDU) {HDU};
    % AND gate for HDU control
    \node[and port, anchor=bin 2, fill=red!60, scale=0.5, external pins width=0] (HDU_AND) at ([xshift=5mm]Control.east) {};
\fi

% EX Stage Components
\ifshowforwarding
    % With forwarding - use mux3 for ForwardA and mux4 for ForwardB
    \coordinate (RegFile_out1) at ([yshift=-2mm]RegFile.brpin 1);
    \node[mux3, fill=orange!20, anchor=blpin 1] (ForwardA) at ([xshift=15mm]IDEX.east |- RegFile_out1) {};
    \node[mux4, fill=orange!20, anchor=blpin 1] (ForwardB) at ([xshift=11mm]IDEX.east |- RegFile_out2) {};
% ALU
    \node[alu_style, right=5mm of ForwardA.brpin 1, anchor=blpin 1] (ALU) {};
\else
    % Without forwarding - use simple mux2 only for immediate
    \node[mux2, fill=cyan!20, anchor=blpin 1] (ImmMux) at ([xshift=11mm]IDEX.east |- RegFile_out2) {};
% ALU
    \node[alu_style, anchor=blpin 2] (ALU) at ([xshift=25mm]IDEX.east |- ImmMux.brpin 1) {};
    \coordinate (RegFile_out1) at (RegFile.brpin 1 |- ALU.blpin 1);
\fi

% Labels for register file outputs is here because of dependency
\node[align=left, xshift=-3.5mm, font=\tiny] at (RegFile_out1) {read\\data 1};
\node[align=left, xshift=-3.5mm, font=\tiny] at (RegFile_out2) {read\\data 2};


\node[font=\scriptsize, below right=-2mm of ALU.blpin 1] {\rotatebox{-45}{ALU}};
\node[font=\tiny, left=-1mm of ALU.brpin 3, align=right] {zero};
\node[font=\tiny, left=-1mm of ALU.brpin 4, align=right] {res};

% Addr and SHL
\node[adder, anchor=blpin 1] (EXPCAddr) at (ALU |- IFNewPC) {+};
\node[ellipse, draw, thick, fill=cyan!20, minimum width=0.3cm, minimum height=0.2cm, inner sep=1pt,
      left=3mm of EXPCAddr.blpin 2, font=\tiny] (SHLTwo) {\rotatebox{90}{SHL2}};

% Register fields in IDEX latch (bottom to top)
\node[data_latch, anchor=south] (Rd_field) at (IDEX.south) {Rd};
\ifshowforwarding
    \node[mux2b, fill=cyan!20, anchor=blpin 2] (RegDstMux) at ([xshift=-3mm]ForwardB.blpin 2 |- Rd_field.east) {};
\else
    \node[mux2b, fill=cyan!20, anchor=blpin 2] (RegDstMux) at ([xshift=-3mm]ImmMux.blpin 2 |- Rd_field.east) {};
\fi
\node[data_latch] (Rt_field) at (RegDstMux.lpin 1 -| Rd_field) {Rt};
\node[data_latch, above=2.3mm of Rt_field] (Imm_field) {Imm};
\node[data_latch, above=2.3mm of Imm_field] (Rs_field) {Rs};

\node[ellipse, draw, thick, fill=cyan!20, minimum width=0.3cm, minimum height=0.2cm, inner sep=0pt,
      font=\tiny] (SignExt) at ([xshift=-8mm]Imm_field) {\rotatebox{90}{SignExt}};

% ALU Control
\node[ellipse, draw, thick, fill=cyan!20, minimum width=0.3cm, minimum height=0.2cm, inner sep=1pt,
      font=\tiny, anchor=east] (ALUCtrl) at ([xshift=-5mm]ALU.east |- Imm_field.east) {\rotatebox{90}{ALUctrl}};

\ifshowforwarding
    % Forwarding Unit
    \node[muxdemux, muxdemux def={Lh=1.6, NL=4, Rh=1.6, NR=4, NT=4, w=3, square pins=1}, 
          external pins width=0, fill=orange!30, font=\scriptsize, align=center, below right=5mm of RegDstMux.east] (FwdUnit) {Forwarding\\Unit};
\fi

\node[pipeline_reg] (EXMEM) at ([xshift=10mm]ALU.east |- IDEX) {};
\node[data_latch] (EXNewPC) at (EXPCAddr.brpin 1 -| EXMEM) {\rotatebox{90}{NewPC}};

% MEM Stage Components
\node[memory_block, anchor=west, align=center] (DMem) at ([xshift=8mm]EXMEM.east |- ALU.brpin 4) {Data\\Memory};
\node[align=left, font=\tiny] at ([xshift=3mm]DMem.blpin 3) {write\\addr};
\node[align=left, font=\tiny] at ([xshift=3mm]DMem.blpin 4) {read\\addr};
\node[align=left, font=\tiny] at ([xshift=3mm]DMem.blpin 5) {write\\data};
\node[align=right, font=\tiny] at ([xshift=-3mm]DMem.brpin 1) {read\\data};

\node[and port, anchor=south west, fill=cyan!20, scale=0.5, external pins width=0] (MemAnd) at ([xshift=0mm, yshift=1mm]DMem.north west) {};

\node[pipeline_reg] (MEMWB) at ([xshift=8mm]DMem.east |- EXMEM) {};

% WB Stage Components
\node[mux2, fill=cyan!20, anchor=blpin 1] (WBMux) at ([xshift=5mm]MEMWB.east |- DMem.rpin 1) {};

% Additional control signal blocks in pipeline registers (WB1, M1, EX1 already defined)
\node[control_signal] (WB2) at (WB1 -| EXMEM.center) {WB};
\node[control_signal] (M2) at (WB2.south) [anchor=north, yshift=-0.1cm] {M};

\node[control_signal] (WB3) at (WB1 -| MEMWB.center) {WB};

% Register fields in EXMEM and MEMWB latches
\node[data_latch] (EXMEM_RtRd) at (EXMEM |- RegDstMux.rpin 1) {\rotatebox{90}{Rt/Rd}};
\node[data_latch] (MEMWB_RtRd) at (MEMWB |- EXMEM_RtRd) {\rotatebox{90}{Rt/Rd}};

\node[data_latch, above=1mm of MEMWB_RtRd] (ALUresult) {\rotatebox{90}{ALUresult}};

% Main data paths
% PC to Instruction Memory
\draw[data_path] (PC.east) -- (IMem.blpin 3);
\draw[data_path] ([xshift=2mm]PC.east) node[data_connector] {} |- (PCadder.blpin 1);
\draw[data_path] (four.east) -- (PCadder.blpin 2);
\draw[data_path] (PCadder.brpin 1) -- (IFNewPC.west);
\draw[data_path] ([xshift=3mm]PCadder.brpin 1) node[data_connector] {} |- (PCSrcMux.brpin 2);
\draw[data_path] (PCSrcMux.blpin 1) -| ([xshift=-3mm]PC.west) -- (PC.west);
% Instruction Memory to IF/ID
\draw[data_path] (IMem.brpin 3) -- (IFID.west |- IMem.brpin 3);
\node[align=left, font=\tiny] at ([xshift=3mm]IMem.blpin 3) {read\\addr};

% IF/ID to Register File
\draw[data_path] ([xshift=3mm]Instruction.east |- RegFile.blpin 1) node[data_connector] {}
    -- node[path_label, pos=0.9] {Rs} (RegFile.blpin 1);
\draw[data_path] ([xshift=3mm]Instruction.east |- RegFile.blpin 2) node[data_connector] {}
    -- node[path_label, pos=0.9] {Rt} (RegFile.blpin 2);
\draw[data_path] (Instruction.east) -- ++(0.3,0) 
    |- node[path_label, pos=0.8] {[15--11]} (Rd_field.west);
\draw[data_path] ([xshift=3mm]Instruction.east |- SignExt) node[data_connector] {}
    |- node[path_label, pos=0.9] {[15--0]} (SignExt.west);

\draw[data_path] ([xshift=-9mm]RegFile.blpin 1) node[data_connector] {}
                    |- node[path_label, pos=0.8] {Rs} (Rs_field.west);  
\draw[data_path] ([xshift=-10mm]RegFile.blpin 2) node[data_connector] {}
                    |- node[path_label, pos=0.8] {[20--16]} (Rt_field.west);  

% SignExt to Imm field
\draw[data_path] (SignExt.east) -- (Imm_field.west);

\draw[data_path] (Instruction.east) -- ++(0.3,0) |- (Control.west);

% PC
\draw[data_path] (IFNewPC.east) --  (IDEX.west |- IFNewPC);

% Register File outputs to ID/EX
\draw[data_path] (RegFile_out1) -- (RegFile_out1 -| IDEX.west);
\draw[data_path] (RegFile_out2) -- (RegFile_out2 -| IDEX.west);

% ID/EX to EX stage
\ifshowforwarding
    % With forwarding
    \draw[data_path] (IDEX.east |- RegFile_out1) -- (ForwardA.blpin 1);
    \draw[data_path] (IDEX.east |- RegFile_out2) -- (ForwardB.blpin 1);
    \draw[data_path] ([xshift=2mm]IDEX.east |- RegFile_out2) node[data_connector] {} 
        |- (DMem.blpin 5 -| EXMEM.west);
    \draw[control_path] ([yshift=1mm]EX1.east) -|  node[control_label, pos=0.67, sloped] {ALUSrc} (ForwardB.btpin 1);
\else
    % Without forwarding
    \draw[data_path] (IDEX.east |- RegFile_out1) -- (ALU.blpin 1);
    \draw[data_path] (IDEX.east |- RegFile_out2) -- (ImmMux.blpin 1);
    \draw[data_path] ([xshift=2mm]IDEX.east |- RegFile_out2) node[data_connector] {} 
        |- (DMem.blpin 5 -| EXMEM.west);
    \draw[control_path] ([yshift=1mm]EX1.east) -|  node[control_label, pos=0.67, sloped] {ALUSrc} (ImmMux.btpin 1);
\fi

\draw[control_path] (EX1.east) -- ++(9mm, 0) |- node[control_label, pos=0.1, sloped] {ALUop} ([yshift=2mm]ALUCtrl.west);
\draw[control_path] ([yshift=-1mm]EX1.east)
    -| node[control_label, pos=0.58, sloped] {RegDst} ([yshift=3mm, xshift=-3mm]RegDstMux.btpin 1)
    -| (RegDstMux.btpin 1);

% Connect to ALU
\ifshowforwarding
    % With forwarding muxes
    \draw[data_path] (ForwardA.brpin 1) -- (ALU.blpin 1);
    \draw[data_path] (ForwardB.brpin 1) -- (ALU.blpin 2);
\else
    % Without forwarding
    \draw[data_path] (ImmMux.brpin 1) -- (ALU.blpin 2);
\fi

% Register destination paths
\draw[data_path] (Rt_field.east) -- (RegDstMux.blpin 1);
\draw[data_path] (Rd_field.east) -- (RegDstMux.blpin 2);
\coordinate (ImmTurn) at ($(Imm_field.east |- SHLTwo.west) + (0.4,0)$);
\draw[data_path] (Imm_field.east) -| (ImmTurn) -- (SHLTwo.west);

\ifshowforwarding
    \draw[data_path] (ImmTurn |-  ForwardB.blpin 4) node[data_connector] {} -- (ForwardB.blpin 4);
\else
    \draw[data_path] (ImmTurn |-  ImmMux.blpin 2) node[data_connector] {} -- (ImmMux.blpin 2);
\fi

\draw[data_path] (RegDstMux.brpin 1) --  (EXMEM_RtRd.west);
\draw[data_path] (EXMEM_RtRd.east) -- node[path_label] {RegDst} (MEMWB_RtRd.west);
\coordinate (RegDstEast) at ([xshift=5mm]MEMWB_RtRd.east);

\ifshowforwarding
    \coordinate (RegDstSouth) at ([yshift=-9mm]FwdUnit.south);
\else
    \coordinate (RegDstSouth) at ([yshift=-15mm]RegDstMux.south);
\fi

\draw[data_path]
  (MEMWB_RtRd.east) -- (RegDstEast)
  |- (RegDstSouth)
  -| node[path_label, above right]{RegDst} ([xshift=-8mm]RegFile.blpin 3)
  -- node[path_label]{RegDst}
     (RegFile.blpin 3);

% EX PC Addr
\draw[data_path] (IDEX.east |- IFNewPC) -- (EXPCAddr.blpin 1);
\draw[data_path] (SHLTwo.east) -- (EXPCAddr.blpin 2);
\draw[data_path] (EXPCAddr.brpin 1) -- (EXNewPC.west);

\ifshowhdu
    \draw[data_path] (EXNewPC.east) -- ++(0.2,0)
        |- ([yshift=1mm, xshift=10mm]HDU.north -| PCSrcMux.brpin 1)
        |- (PCSrcMux.brpin 1);
\else
    \draw[data_path] (EXNewPC.east) -- ++(0.2,0)
        |- (PCSrcMux.brpin 1);
\fi

% ALU Control
\draw[data_path] (IDEX.east |- Imm_field) -- (ALUCtrl.west);
\draw[data_path] (ALUCtrl.east) -| (ALU.bbpin 1);

% ALU to EX/MEM
\draw[data_path] (ALU.brpin 4) -- (EXMEM.west |- ALU.brpin 4);
\draw[control_path] (ALU.brpin 3) -- (EXMEM.west |- ALU.brpin 3);

% EX/MEM to Data Memory
\draw[data_path] (EXMEM.east |- ALU.brpin 4) -- (DMem.blpin 3);
\draw[data_path] ([xshift=5mm]EXMEM.east |- ALU.brpin 4)  node[data_connector] (DmemConnector) {} |- (ALUresult.west);
\draw[data_path] (DmemConnector |- DMem.blpin 4) node[data_connector] {} |- (DMem.blpin 4);

% Read Data 2 to Write Data
\draw[data_path] (EXMEM.east |- DMem.blpin 5) -- (DMem.blpin 5);

\draw[control_path] ([yshift=1]M2.east) -| node[control_label, near end, sloped] {MemRead} (DMem.btpin 5);
\draw[control_path] ([yshift=-1]M2.east) -| node[control_label, near end, sloped] {MemWrite} (DMem.btpin 4);
\draw[control_path] ([yshift=-3]M2.east) -- ++(0.6, 0) |- node[control_label, near start, sloped] {Branch} (MemAnd.bin 1);
\draw[control_path] (EXMEM.east |- ALU.brpin 3) -- ++(0.6, 0)
    |- node[control_label, near start, sloped] {} (MemAnd.bin 2);

\ifshowhdu
    \draw[control_path] (MemAnd.bout) -| ++(0.3, 2)
        |- node[control_label, pos=0.53, below, yshift=2mm] {PCSrc} ([yshift=2mm]PCSrcMux.btpin 1 |- HDU.north)
        -- (PCSrcMux.btpin 1);
\else
    \draw[control_path] (MemAnd.bout) -| ++(0.3, 2)
        |- node[control_label, pos=0.53, below, yshift=2mm] {PCSrc} ([yshift=8mm]PCSrcMux.btpin 1)
        -- (PCSrcMux.btpin 1);
\fi

% Data Memory to MEM/WB
\draw[data_path] (DMem.brpin 1) -- (MEMWB.west |- DMem.brpin 1);

% MEM/WB to WB Mux
\draw[data_path] (MEMWB.east |- DMem.rpin 1) -- (WBMux.blpin 1);
\draw[data_path] (ALUresult.east) -- ++(0.3,0) |- (WBMux.blpin 2);
\draw[control_path] ([yshift=1]WB3.east) -| node[control_label, near end, sloped] {MemtoReg} (WBMux.btpin 1);

\coordinate (WBMuxEast) at ([xshift=5mm]WBMux.east);

\ifshowforwarding
    \coordinate (WrDataSouth) at ([yshift=-5mm]FwdUnit.south);
\else
    \coordinate (WrDataSouth) at ([yshift=-11mm]RegDstMux.south);
\fi

% Write back path
\draw[data_path]
  (WBMux.brpin 1) -- (WBMuxEast)
  |- (WrDataSouth)
  -| node[path_label, above right]{WrData} ([xshift=-7mm]RegFile.blpin 4)
  -- node[path_label]{WrData}
     (RegFile.blpin 4);

% Control paths
\ifshowhdu
    \draw[control_path] (HDU_AND.bout) -- ++(0.3, 0) node[control_connector] {} |- (WB1.west);
    \draw[control_path] ([xshift=3mm]HDU_AND.bout) |- (EX1.west);
    \draw[control_path] ([xshift=3mm]HDU_AND.bout |- M1.west) node[control_connector] {}  -- (M1.west);
    \draw[control_path] (Control.east) -- (HDU_AND.bin 2);
\else
    \draw[control_path] (Control.east) -- ++(5mm, 0) |- (WB1.west);
    \draw[control_path] ([xshift=5mm]Control.east) node[control_connector] {} |- (EX1.west);
    \draw[control_path] ([xshift=5mm]Control.east |- M1.west) node[control_connector] {} -- (M1.west);
\fi

\draw[control_path] (Control.south) -- (RegFile.btpin 1);
\draw[control_path] (WB1.east) -- (WB2.west);
\draw[control_path] (M1.east) -- (M2.west);
\draw[control_path] (WB2.east) -- (WB3.west);

\ifshowforwarding
    \coordinate (RegWriteSouth) at ([yshift=-2mm]FwdUnit.south);
\else
    \coordinate (RegWriteSouth) at ([yshift=-7mm]RegDstMux.south);
\fi

\draw[control_path]
    ([yshift=-3]WB3.east) -- ++(0.2, 0)
    |- node[control_label, pos=0.1, sloped] {RegWrite} (RegWriteSouth)
    -| node[control_label, above right] {RegWrite} ([xshift=-4mm]RegFile.blpin 5)
    -- (RegFile.blpin 5);

% Hazard detection paths (only if HDU is enabled)
\ifshowhdu
    \draw[hazard_path] (HDU.brpin 3) -- ++(6mm, 0) |- (HDU_AND.bin 1);
    \draw[hazard_path] (HDU.blpin 1) -| (PC.north);
    \draw[hazard_path] (HDU.blpin 2) -| (IFID.north);
    \draw[hazard_path_input] (RegFile.blpin 2 -| HDU.bbpin 3) node[hazard_connector] {} -- (HDU.bbpin 3);
    \draw[hazard_path_input] (RegFile.blpin 1 -| HDU.bbpin 4) node[hazard_connector] {} -- (HDU.bbpin 4);
    \draw[hazard_path_input] ([xshift=-1cm]M2.west) node[hazard_connector] {} |- (HDU.brpin 2);
    \draw[hazard_path_input] ([xshift=-3mm]EXMEM_RtRd.west) node[hazard_connector] {} |- (HDU.brpin 1);
\fi

% Forwarding paths (only if forwarding is enabled)
\ifshowforwarding
    \draw[forward_path] (FwdUnit.btpin 1) 
        |- ([yshift=-3mm]ForwardA.bbpin 1)
        -- (ForwardA.bbpin 1);
    
    \draw[forward_path] (FwdUnit.blpin 2) -| (ForwardB.bbpin 1);
    
    \draw[data_path] ([xshift=1mm]EXMEM_RtRd.east) node[data_connector] {} |- (FwdUnit.brpin 1);
    \draw[data_path] (RegDstEast |- FwdUnit.brpin 3) node[data_connector] {} |- node[path_label, pos=0.7] {RegDst} (FwdUnit.brpin 3);
    
    \draw[data_path] (Rs_field.east) -- ++(0.3,0) |- (FwdUnit.blpin 3);
    \draw[data_path] ([xshift=2mm]Rt_field.east) node[data_connector] {}  |- (FwdUnit.blpin 4);
    \draw[control_path] ([xshift=5mm]RegWriteSouth 
        -| FwdUnit.brpin 4) node[control_connector] {}
        |- (FwdUnit.brpin 4);
    
    \draw[control_path] ([yshift=-5]M2.east) -- ++(0.3, 0) |- node[control_label, pos=0.05, sloped] {RegWrite} (FwdUnit.brpin 2);
    
    % Special Forwarding Paths
    \draw[arrow, blue, very thick] (ALUresult -| DmemConnector) node[data_connector] {} 
        |- ([yshift=-3]FwdUnit.south)
        -| ([xshift=-14]ForwardB.blpin 2) coordinate (ForwardB_junction1)
        |- (ForwardA.blpin 2);
    
    \node[forward_connector_a] at (ForwardB_junction1) {};
    \draw[arrow, blue] (ForwardB_junction1) |- (ForwardB.blpin 2);
    
    \draw[arrow, green, very thick]
        ([xshift=-2]WrDataSouth -| ForwardB_junction1) node[data_connector] {}
        |- (ForwardA.blpin 3);
    \draw[arrow, green, very thick] (ForwardB.blpin 3 -| ForwardB_junction1) node[data_connector] {}
        |- (ForwardB.blpin 3);
\fi

% Stage labels (only if enabled)
\ifshowstagelabels
    % ID stage label - use midpoint between IFID and IDEX (define first for reference)
    \node[stage_label, remember picture] (ID_label) at ($ (IFID.north)!0.5!(IDEX.north) + (0,3mm) $) {ID};

    % IF stage label - align with ID label Y-position
    \node[stage_label, remember picture] (IF_label) at (PC.north |- ID_label) {IF};

    % EX stage label - use midpoint between IDEX and EXMEM
    \node[stage_label, remember picture] (EX_label) at ($ (IDEX.north)!0.5!(EXMEM.north) + (0,3mm) $) {EX};

    % MEM stage label - use midpoint between EXMEM and MEMWB
    \node[stage_label, remember picture] (MEM_label) at ($ (EXMEM.north)!0.5!(MEMWB.north) + (0,3mm) $) {MEM};

    % WB stage label - align with ID label Y-position
    \node[stage_label, remember picture] (WB_label) at (WBMux.north |- ID_label) {WB};
\fi

\end{circuitikz}
}

% Wrapper for use within frame's custom TikZ - just calls the pipeline at origin
% Use this inside a frame when you want to add custom overlays
\newcommand{\drawpipelineprocessor}[3][false]{%
\csname showforwarding#2\endcsname
\csname showhdu#3\endcsname
\csname showstagelabels#1\endcsname
\pipelineprocessor[#1]{#2}{#3}
}

\title{Data and Control Hazards}
\author{Compuetr Architecture 2360267}
\date{2025, Recitation \#2}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Review: Pipeline Basics}

\begin{frame}{Basic Pipeline Processor}
\centering
\pipelineprocessor[true]{false}{false}  % Show stage labels, no forwarding, no HDU
\end{frame}

\begin{frame}{Pipeline Stages Overview}
\vspace{-7mm}
\begin{columns}[t]
\column{0.48\textwidth}
\begin{enumerate}
    \item \textbf{IF (Instruction Fetch):}
    \begin{itemize}
        \item Fetch instruction from instruction memory
        \item Update PC (Program Counter)
    \end{itemize}

    \item \textbf{ID (Instruction Decode):}
    \begin{itemize}
        \item Decode instruction
        \item Read register operands from register file
        \item Control unit generates control signals
    \end{itemize}

    \item \textbf{EX (Execute):}
    \begin{itemize}
        \item ALU performs computation
        \item Calculate branch target address
        \item Determine branch outcome
    \end{itemize}
\end{enumerate}

\column{0.48\textwidth}
\begin{enumerate}
    \setcounter{enumi}{3}
    \item \textbf{MEM (Memory):}
    \begin{itemize}
        \item Access data memory for loads/stores
        \item Finalize branch decision
    \end{itemize}

    \item \textbf{WB (Write Back):}
    \begin{itemize}
        \item Write result back to register file
    \end{itemize}
\end{enumerate}
\end{columns}
\end{frame}

\section{Review: Data Hazards}

\begin{frame}{Review: RAW Data Hazard - Read After Write}
\centering
\pipelineprocessor[true]{false}{false}

\begin{tikzpicture}[remember picture, overlay,
    instr_box/.style={draw, thick, minimum height=0.5cm, align=center, font=\ttfamily\footnotesize, inner sep=2pt}
]
    % Instruction boxes aligned with stage labels from the pipeline
    \node[instr_box, fill=orange!20]
          at ($(ID_label) + (0, -6.5)$) {SUB \$4$\leftarrow$\textcolor{red}{\$1},\$5};

    \node[instr_box, fill=green!20]
          at ($(EX_label) + (0, -6.5)$) {ADD \textcolor{red}{\$1}$\leftarrow$\$2,\$3};

    % Problem text in bottom left
    \node[draw, thick, fill=yellow!20, align=left, font=\small,
          anchor=south west, inner sep=4pt, text width=4cm]
          at ($(current page.south west) + (0.2, 1)$)
          {\textbf{Problem:} SUB needs the value of \$1, but ADD hasn't written it yet!};
\end{tikzpicture}
\end{frame}

\begin{frame}{Review: Understanding RAW Data Hazards}
\textbf{What is a RAW (Read After Write) Hazard?}

A data hazard occurs when an instruction depends on the result of a previous instruction that hasn't completed yet.

\vspace{0.3cm}
\textbf{Example:}
\vspace{-0.6cm}
\begin{center}
\begin{tabular}{ll}
\texttt{ADD \textcolor{red}{\$1} $\leftarrow$ \$2, \$3} & \textit{(produces \$1)} \\
\texttt{SUB \$4 $\leftarrow$ \textcolor{red}{\$1}, \$5} & \textit{(needs \$1)} \\
\end{tabular}
\end{center}

\vspace{0.3cm}
\textbf{The Problem:}
\begin{itemize}
    \item ADD writes \$1 in WB stage (cycle 5)
    \item SUB reads \$1 in ID stage (cycle 3)
    \item SUB reads \textbf{stale data} from register file!
\end{itemize}

\vspace{0.3cm}
\textbf{Solutions:}
\begin{enumerate}
    \item \textbf{Stalling:} Insert bubbles to wait for the result
    \item \textbf{Forwarding (Bypassing):} Forward result directly from pipeline stages
\end{enumerate}
\end{frame}

\begin{frame}{Review: Solution - Stalling to Resolve Data Hazard}
\centering
\pipelineprocessor[true]{false}{false}

\begin{tikzpicture}[remember picture, overlay,
    instr_box/.style={draw, thick, minimum height=0.5cm, align=center, font=\ttfamily\footnotesize, inner sep=2pt},
    bubble_box/.style={draw, thick, minimum height=0.5cm, align=center, font=\ttfamily\scriptsize, inner sep=2pt, fill=gray!20}
]
    % Instruction boxes aligned with stage labels from the pipeline
    \node[instr_box, fill=orange!20] (sub_instr)
          at ($(ID_label) + (0, -6.5)$) {SUB \$4$\leftarrow$\textcolor{red}{\$1},\$5};

    % Bubbles (stalls) in EX and MEM - same height as SUB
    \node[bubble_box]
          at ($(EX_label) + (0, -6.5)$) {BUBBLE};

    \node[bubble_box]
          at ($(MEM_label) + (0, -6.5)$) {BUBBLE};

    % ADD instruction - aligned to right edge of page at same height as SUB
    \node[instr_box, fill=green!20, anchor=east] (add_instr)
          at ($(current page.east |- sub_instr) + (-0.3, 0)$) {ADD \textcolor{red}{\$1}$\leftarrow$\$2,\$3};

    % Solution text in bottom left
    \node[draw, thick, fill=yellow!20, align=left, font=\small,
          anchor=south west, inner sep=4pt, text width=4cm]
          at ($(current page.south west) + (0.2, 1)$)
          {\textbf{Solution:} Insert stalls (bubbles) until ADD writes \$1 in WB stage.};
\end{tikzpicture}
\end{frame}

\begin{frame}{Review: Forwarding - MEM to EX}
\centering
\pipelineprocessor[true]{true}{false}

\begin{tikzpicture}[remember picture, overlay,
    instr_box/.style={draw, thick, minimum height=0.5cm, align=center, font=\ttfamily\footnotesize, inner sep=2pt}
]
    % ADD in MEM stage, SUB in EX stage
    \node[instr_box, fill=green!20] (add_instr)
          at ($(MEM_label) + (0, -6.5)$) {ADD \textcolor{red}{\$1}$\leftarrow$\$2,\$3};

    \node[instr_box, fill=orange!20] (sub_instr)
          at ($(EX_label) + (0, -6.5)$) {SUB \$4$\leftarrow$\textcolor{red}{\$1},\$5};

    % Blue forwarding line from ADD to SUB (MEM to EX) - between boxes
    \draw[->, very thick, blue] (add_instr.west) -- (sub_instr.east);

    % Solution text in bottom left
    \node[draw, thick, fill=yellow!20, align=left, font=\small,
          anchor=south west, inner sep=4pt, text width=4.5cm]
          at ($(current page.south west) + (0.2, 1)$)
          {\textbf{MEM $\rightarrow$ EX Forwarding:} Result forwarded from MEM stage to EX stage (blue path).};
\end{tikzpicture}
\end{frame}

\begin{frame}{Review: Forwarding - WB to EX}
\centering
\pipelineprocessor[true]{true}{false}

\begin{tikzpicture}[remember picture, overlay,
    instr_box/.style={draw, thick, minimum height=0.5cm, align=center, font=\ttfamily\footnotesize, inner sep=2pt}
]
    % ADD in WB stage, SUB in EX stage
    \node[instr_box, fill=green!20, anchor=east] (add_instr)
          at ($(current page.east |- EX_label) + (-0.3, -6.5)$) {ADD \textcolor{red}{\$1}$\leftarrow$\$2,\$3};

    \node[instr_box, fill=orange!20] (sub_instr)
          at ($(EX_label) + (0, -6.5)$) {SUB \$4$\leftarrow$\textcolor{red}{\$1},\$5};

    % Green forwarding line from ADD to SUB (WB to EX) - between boxes
    \draw[->, very thick, green] (add_instr.west) -- (sub_instr.east);

    % Solution text in bottom left
    \node[draw, thick, fill=yellow!20, align=left, font=\small,
          anchor=south west, inner sep=4pt, text width=4.5cm]
          at ($(current page.south west) + (0.2, 1)$)
          {\textbf{WB $\rightarrow$ EX Forwarding:} Result forwarded from WB stage to EX stage (green path).};
\end{tikzpicture}
\end{frame}

\begin{frame}{Review: Forwarding Unit - Inputs \& Outputs}
\textbf{Inputs:}
\begin{itemize}
    \item \textbf{ID/EX.Rs, ID/EX.Rt:} Source register numbers in EX stage
    \item \textbf{EX/MEM.Rd:} Destination register from MEM stage
    \item \textbf{MEM/WB.Rd:} Destination register from WB stage
    \item \textbf{EX/MEM.RegWrite:} Will MEM stage write to register?
    \item \textbf{MEM/WB.RegWrite:} Will WB stage write to register?
\end{itemize}

\vspace{0.5cm}
\textbf{Outputs:}
\begin{itemize}
    \item \textbf{ForwardA, ForwardB:} Mux control signals for ALU inputs
    \begin{itemize}
        \item 00: Use value from Register File (no forwarding)
        \item 10: Forward from EX/MEM (MEM $\rightarrow$ EX)
        \item 01: Forward from MEM/WB (WB $\rightarrow$ EX)
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Review: Forwarding Unit - Logic}
\small
\textbf{ForwardA Logic} (similar for ForwardB using Rt instead of Rs):

\begin{minted}[fontsize=\scriptsize, frame=single, bgcolor=gray!10]{c}
// Priority 1: MEM->EX (most recent)
if (EX/MEM.RegWrite && EX/MEM.Rd != 0 && EX/MEM.Rd == ID/EX.Rs)
    ForwardA = 10;  // Forward from EX/MEM

// Priority 2: WB->EX
else if (MEM/WB.RegWrite && MEM/WB.Rd != 0 && MEM/WB.Rd == ID/EX.Rs)
    ForwardA = 01;  // Forward from MEM/WB

// No forwarding needed
else
    ForwardA = 00;  // Use Register File
\end{minted}

\textbf{Key Points:}
\begin{itemize}
    \item MEM $\rightarrow$ EX has priority (newer data)
    \vspace{-0.2cm}
    \item Check Rd $\neq$ 0 (R0 is hardwired to zero)
    \vspace{-0.2cm}
    \item Check RegWrite to ensure destination will be written
\end{itemize}
\end{frame}

\begin{frame}{Review: Pipeline Processor with Hazard Detection (No Forwarding)}
\centering
\pipelineprocessor[false]{false}{true}  % No stage labels, no forwarding, show HDU
\end{frame}

\begin{frame}{Review: Pipeline Processor with Hazard Detection and Forwarding}
\centering
\pipelineprocessor[false]{true}{true}  % No stage labels, show forwarding and HDU
\end{frame}



\section{Review: Control Hazards}

\begin{frame}{Review: Branch Target Buffer (BTB)}
\textbf{Direction Prediction (Taken/Not Taken):}
\begin{columns}
\column{0.5\textwidth}
\begin{itemize}
    \item Remembers branch behavior from recent executions
    \item If taken recently, predict taken again
    \item Uses state machines for history
\end{itemize}

\column{0.5\textwidth}
\begin{tikzpicture}[scale=0.8, node distance=2.5cm]
    \node[state, fill=red!20, minimum size=1.8cm, align=center] (nt) {Not\\Taken};
    \node[state, fill=green!20, minimum size=1.8cm, align=center, right of=nt] (t) {Taken};
    
    \path[->] 
    (nt) edge[bend left, above] node{taken} (t)
    (t) edge[bend left, below] node{not taken} (nt)
    (nt) edge[loop left] node[below, align=center, near start] {not\\taken} (nt)
    (t) edge[loop right] node[above, align=center, near start]{taken} (t);
\end{tikzpicture}
\end{columns}
\vspace{0.5cm}
\textbf{Target Address Prediction:}
\begin{itemize}
    \item Also remembers the jump target address
\end{itemize}

\begin{tcolorbox}[colback=yellow!10]
\small
Note: Initial state is "not taken" because on first encounter with a branch instruction, the target address is unknown. Only after the branch jumps for the first time can we store its target address.
\end{tcolorbox}
\end{frame}

\begin{frame}{Review: Enhanced Prediction with 2-bit State Machine}
\textbf{More reliable prediction using 4-state machine:}

\begin{center}
\begin{tikzpicture}[scale=1, node distance=3cm, auto]
    % Define states with minimum size
    \node[state, fill=red!20, align=center, minimum size=1.8cm, font=\scriptsize] (00) {00\\Not\\Taken};
    \node[state, fill=orange!20, right of=00, align=center, minimum size=1.8cm, font=\scriptsize] (01) {01\\Not\\Taken};
    \node[state, fill=yellow!20, right of=01, align=center, minimum size=1.8cm, font=\scriptsize] (10) {10\\Taken};
    \node[state, fill=green!20, right of=10, align=center, minimum size=1.8cm, font=\scriptsize] (11) {11\\Taken};
    
    % Add transitions with loops on left and right
    \path[->]
    % From 00
    (00) edge[loop left] node{NT} (00)
    (00) edge[above, bend left=20] node{T} (01)
    % From 01
    (01) edge[below, bend left=20] node{NT} (00)
    (01) edge[above, bend left=20] node{T} (10)
    % From 10
    (10) edge[below, bend left=20] node{NT} (01)
    (10) edge[above, bend left=20] node{T} (11)
    % From 11
    (11) edge[below, bend left=20] node{NT} (10)
    (11) edge[loop right] node{T} (11);
    
    % Add direction arrows
   % \draw[thick, ->, blue] (0, -1.5) -- (12, -1.5) node[right, align=center] {Taken};
   % \draw[thick, ->, red] (0, -2) -- (12, -2) node[right, align=center] {Not\\Taken};
\end{tikzpicture}
\end{center}

\textbf{Key advantages:}
\begin{itemize}
    \item States 00 and 11 are stable states
    \item Transition to opposite prediction only after TWO consecutive mispredictions
    \item Reduces impact of irregular jumps/exceptions
    \item Initial state set to 01 (not taken, unstable)
\end{itemize}
\end{frame}

\begin{frame}{Review: BTB Structure - Overview}
\begin{columns}
\column{0.5\textwidth}
\centering
\btbdiagram

\column{0.5\textwidth}

\vspace{0.3cm}
\textbf{Lookup Process:}
\begin{enumerate}
    \item Compare PC with stored addresses/tags
    \item If match found: use prediction and target
    \item If no match: assume not a branch
\end{enumerate}

\vspace{0.3cm}
\textbf{Limitation:}
\begin{itemize}
    \item May store partial addresses (tags) to save space
    \item Can cause \textcolor{red}{false matches} $\Rightarrow$ mispredictions
\end{itemize}
\end{columns}
\end{frame}

\begin{frame}{Review: BTB Structure - Components}
\begin{columns}
\column{0.5\textwidth}
\centering
\btbdiagram

\column{0.5\textwidth}
\textbf{BTB Fields:}
\begin{itemize}
    \item \textbf{Left field:} Branch address/tag
    \begin{itemize}
        \item May use hash or partial address
        \item \textcolor{red}{Tag conflicts} can cause errors
    \end{itemize}
    \item \textbf{Middle field:} Target address
    \begin{itemize}
        \item Populated after first branch execution
        \item Used when prediction is "taken"
    \end{itemize}
    \item \textbf{Right field:} Prediction state
    \begin{itemize}
        \item 2-bit state machine (00, 01, 10, 11)
        \item Tracks taken/not taken history
    \end{itemize}
\end{itemize}

\vspace{0.3cm}
\textbf{Trade-off:} Smaller tags save space but increase collision risk
\end{columns}
\end{frame}



\section{Question 1: Branch Prediction}

\begin{frame}[fragile]{Q1: Branch Prediction}
\begin{columns}
\column{0.4\textwidth}
\begin{minted}[fontsize=\scriptsize, frame=single, bgcolor=gray!10]{nasm}
    MOVI R1,2
loop1:
    MOV R2,R1
loop2:
    DEC R2
    BNEQ R2,R0,loop2
    INC R1
    BLT R1,4,loop1
\end{minted}

\column{0.6\textwidth}
\textbf{Given:}
\begin{itemize}
    \item 5-stage pipeline (IF, ID, EX, MEM, WB)
    \item BTB with 2-bit predictor
    \item Initial state: 01
\end{itemize}
\end{columns}

\textbf{Question:} What will be the prediction each time BNEQ is executed? How many mispredictions?

\centering
\begin{columns}
\column{0.8\textwidth}
\fourstatemachine[0.7]
\end{columns}
\end{frame}

\begin{frame}[fragile]{Q1: Branch Prediction Analysis}
% Top half with program and state machine
\begin{columns}
\column{0.3\textwidth}
%\textbf{Program:}
\begin{minted}[fontsize=\scriptsize, frame=single, bgcolor=gray!10]{nasm}
    MOVI R1,2
loop1:
    MOV R2,R1
loop2:
    DEC R2
    BNEQ R2,R0,loop2
    INC R1
    BLT R1,4,loop1
\end{minted}

\column{0.7\textwidth}
\textbf{2-bit Predictor (Initial: 01):}
\centering
\fourstatemachine[0.5]
\end{columns}

%\vspace{0.5cm}

% Bottom half with prediction table
%\textbf{Prediction Analysis:}
\predictiontable
\end{frame}

\section{Question 2: Clock Cycles Wasted in Branch Prediction}

\begin{frame}{Q2: How Many Cycles Wasted for Correct vs. Misprediction?}
\textbf{Assumptions:}
\begin{itemize}
    \item BTB lookup performed in ID stage
    \item Branch resolution in EX stage
    \item On BTB hit with "Taken" prediction, target instruction fetched in next cycle
    \item Pipeline flush on misprediction
\end{itemize}

\begin{center}
  \scalebox{0.7}{%
  \begin{tikzpicture}[
    stage/.style={draw=blue!40, line width=1pt, minimum height=1cm, minimum width=1.5cm, fill=blue!10, font=\large, text=blue!80, rounded corners=2pt},
    latch/.style={draw=black!70, thick, fill=yellow!30, minimum width=0.25cm, minimum height=4.5cm},
    component/.style={draw=black!80, line width=1pt, fill=cyan!20, font=\small},
    btb/.style={draw=black!80, line width=1.5pt, minimum height=1cm, minimum width=1.2cm, fill=green!40, font=\small\bfseries, align=center},
    arrow/.style={->, >=stealth, thick},
    data_connector/.style={circle, fill, inner sep=1.2pt}
  ]

    % Instruction Memory - starting point (1.5x bigger)
    \node[muxdemux, muxdemux def={Lh=3, Rh=3, w=3, NL=1, NR=1},
          external pins width=0, fill=cyan!20] (imem) {};
    \node[font=\small, align=center] at (imem.center) {Instruction\\Memory};

    % Latch L1 - to the right of Instruction Memory
    \node[latch, anchor=west] at ([xshift=5mm]imem.rpin 1) (L1) {};

    % Register File - to the right of L1 (1.5x bigger)
    \node[muxdemux, muxdemux def={Lh=3, Rh=3, w=3, NL=4, NR=2},
          external pins width=0, fill=cyan!20, anchor=lpin 2] at ([xshift=6mm]L1.east |- imem.rpin 1) (regfile) {};
    \node[font=\small, align=center] at (regfile.center) {Register\\File};

    % Latch L2 - to the right of Register File
    \node[latch, anchor=west] at ([xshift=5mm]regfile.rpin 1 |- L1) (L2) {};

    % ALU - to the right of L2 (1.5x bigger)
    \node[muxdemux, muxdemux def={Lh=7.5, NL=2, Rh=3, NR=1, NB=2, NT=1, w=3, inset w=1.5, inset Lh=3, inset Rh=0, square pins=1},
          external pins width=0, scale=0.4, fill=cyan!20, anchor=lpin 1] at ([xshift=10mm]L2.east |- regfile.rpin 1) (alu) {};
    \node[rotate=90, font=\small] at ([xshift=1mm]alu.center) {ALU};

    % Latch L3 - to the right of ALU
    \node[latch, anchor=west] at ([xshift=5mm]alu.east |- L1) (L3) {};

    % Data Memory - to the right of L3 (1.5x bigger)
    \node[muxdemux, muxdemux def={Lh=3, Rh=3, w=3, NL=3, NR=1},
          external pins width=0, fill=cyan!20, anchor=lpin 1] at ([xshift=5mm]L3.east |- alu.rpin 1) (dmem) {};
    \node[font=\small, align=center] at (dmem.center) {Data\\Memory};

    % Latch L4 - to the right of Data Memory
    \node[latch, anchor=west] at ([xshift=5mm]dmem.rpin 1 |- L1) (L4) {};

    % WB Mux - to the right of L4 (1.5x bigger)
    \node[muxdemux, muxdemux def={Lh=6, Rh=3, NL=2, NR=1, w=1.5},
          external pins width=0, scale=0.6, fill=cyan!20, anchor=lpin 1] at ([xshift=8mm]L4.east |- dmem.rpin 1) (wb_mux) {};

    % Pipeline stages at top - north aligned with latches

    \node[stage, anchor=north] (id_stage) at ($(L1.north)!0.5!(L2.north)$) {ID};
    \node[stage, anchor=north] (if_stage) at (id_stage.north -| imem) {IF};
    \node[stage, anchor=north] (ex_stage) at ($(L2.north)!0.5!(L3.north)$) {EX};
    \node[stage, anchor=north] (mem_stage) at ($(L3.north)!0.5!(L4.north)$) {MEM};
    \node[stage, anchor=north] (wb_stage) at (mem_stage.north -| wb_mux) {WB};

    % BTB - positioned below Register File (ID stage)
    \node[btb, below=0.2cm of regfile] (btb) {BTB\\Read};

    % Main wiring
    % IF to L1
    \draw[arrow] (imem.east) -- (L1.west);

    % L1 to Register File
    \draw[arrow] (L1.east) -- ++(0.3,0) |- (regfile.lpin 1);
    \draw[arrow] (L1.east) -- (regfile.lpin 2);

    % Register File to L2f
    \draw[arrow] (regfile.rpin 1) -- (L2.west |- alu.lpin 1);
    \draw[arrow] (regfile.rpin 2) -- (L2.west |- regfile.rpin 2);

    % L2 to ALU
    \draw[arrow] (L2.east |- regfile.rpin 1) -- (alu.lpin 1);
    \draw[arrow] (L2.east |- regfile.rpin 2) -- ++(0.3,0) |- (alu.lpin 2);

    % L2 to L3
    \node[data_connector] at ([xshift=3mm]L2.east |- alu.lpin 2) (alu_conn) {};
    \draw[arrow] (alu_conn) |- (L3.west |- dmem.lpin 3);
    %\draw[arrow] (L2.east |- alu.lpin 1) -- (L3.west);

    % ALU to L3
    \draw[arrow] (alu.rpin 1) -- (L3.west |- alu.rpin 1);

    % L3 to Data Memory
    \draw[arrow] (L3.east |- alu.rpin 1) -- (dmem.lpin 1);
    \node[data_connector] at ([xshift=2mm]L3.east |- alu.rpin 1) (dmem_conn) {};
    \draw[arrow] (dmem_conn) |- (dmem.lpin 2);
    \draw[arrow] (L3.east |- dmem.lpin 3) -- (dmem.lpin 3);

    % Data Memory to L4
    \draw[arrow] (dmem.rpin 1) -- (L4.west |- wb_mux.lpin 1);
    \node[data_connector] at ([xshift=2mm]L3.east |- dmem.lpin 2) (dmem_conn2) {};
    \draw[arrow] (dmem_conn2) |- (L4.west |- wb_mux.lpin 2);

    % L4 to WB Mux
    \draw[arrow] (L4.east |- dmem.rpin 1) -- (wb_mux.lpin 1);
    \draw[arrow] (L4.east |- wb_mux.lpin 2) -- (wb_mux.lpin 2);

    % WB Mux output with feedback to Register File
    \draw[arrow] (wb_mux.brpin 1) -- ++(0.5,0)
                     |- ([yshift=-3mm,xshift=-3mm]L1.south -| regfile.west)
                     |- (regfile.lpin 4);

  \end{tikzpicture}
  }
\end{center}

\textbf{Question:} How many clock cycles are wasted for correct prediction vs. misprediction?
\end{frame}

\begin{frame}{Q2: Pipeline Timing Analysis - Correct Predictions}
%\textbf{Branch Prediction: When We Get It Right}
\scriptsize
\vspace{0.3cm}

% Case 1: Correct Prediction - Not Taken (BEST CASE)
\begin{center}
\colorbox{green!10}{
\begin{minipage}{0.95\textwidth}
\textbf{Case 1: Correct Prediction - Not Taken} \hfill \textcolor{green!70!black}{\textbf{0 cycle penalty} $\checkmark$}
\vspace{0.1cm}

\begin{tabular}{l|c|c|c|c|c|c}
\textbf{Instruction} & \textbf{C1} & \textbf{C2} & \textbf{C3} & \textbf{C4} & \textbf{C5} & \textbf{C6} \\
\hline
beq & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB & \\
next & & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB \\
\end{tabular}

\vspace{0.05cm}
\footnotesize \textbf{Optimal:} No stall - same as original MIPS pipeline
\end{minipage}
}
\end{center}

\vspace{0.4cm}

% Case 2: Correct Prediction - Taken
\begin{center}
\colorbox{green!10}{
\begin{minipage}{0.95\textwidth}
\textbf{Case 2: Correct Prediction - Taken} \hfill \textcolor{orange!70!black}{\textbf{1 cycle penalty}}
\vspace{0.1cm}

\begin{tabular}{l|c|c|c|c|c|c|c}
\textbf{Instruction} & \textbf{C1} & \textbf{C2} & \textbf{C3} & \textbf{C4} & \textbf{C5} & \textbf{C6} & \textbf{C7} \\
\hline
beq & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB & & \\
\textit{bubble} & & \cellcolor{stallcolor!40}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \\
target & & & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB \\
\end{tabular}

\vspace{0.05cm}
\footnotesize \textbf{Good:} One bubble while waiting for target address from EX stage
\end{minipage}
}
\end{center}

\vspace{0.3cm}

\begin{tikzpicture}[remember picture, overlay]
    \node[anchor=south east, inner sep=15pt, yshift=12mm] at (current page.south east) {
        \begin{tabular}{ll}
        \footnotesize
        \cellcolor{normalexec!40} & Normal execution \\
        \cellcolor{stallcolor!40} & Stall/Bubble \\
        \cellcolor{emptycolor}--- & Empty stage \\
        \end{tabular}
    };
\end{tikzpicture}

\begin{center}
\large
\textcolor{green!70!black}{\textbf{When prediction is correct, penalty is minimal (0-1 cycles)}}
\end{center}

\end{frame}

% Second frame for mispredictions
\begin{frame}{Q2: Pipeline Timing Analysis - Mispredictions}
%\textbf{Branch Prediction: When We Get It Wrong}
\scriptsize
\vspace{0.1cm}

% Case 3: Misprediction - Predicted Not Taken, Actually Taken
\begin{center}
\colorbox{red!10}{
\begin{minipage}{0.95\textwidth}
\textbf{Case 3: Misprediction - Predicted Not Taken $\rightarrow$ Actually Taken} \hfill \textcolor{red!70!black}{\textbf{2 cycle penalty} \xmark}
\vspace{0.1cm}

\begin{tabular}{l|c|c|c|c|c|c|c|c}
\textbf{Instruction} & \textbf{C1} & \textbf{C2} & \textbf{C3} & \textbf{C4} & \textbf{C5} & \textbf{C6} & \textbf{C7} & \textbf{C8} \\
\hline
beq & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB & & & \\
\textcolor{red}{next (wrong)} & & \cellcolor{normalexec!40}IF & \cellcolor{flushcolor!40}ID & \cellcolor{flushcolor!40}\textsf{X} & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \\
\textcolor{red}{next+1 (wrong)} & & & \cellcolor{flushcolor!40}IF & \cellcolor{flushcolor!40}\textsf{X} & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \\
target (correct) & & & & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB \\
\end{tabular}

\vspace{0.05cm}
\footnotesize \textbf{Bad:} 2 instructions fetched incorrectly and must be flushed
\end{minipage}
}
\end{center}

\vspace{0.2cm}

% Case 4: Misprediction - Predicted Taken, Actually Not Taken
\begin{center}
\colorbox{red!10}{
\begin{minipage}{0.95\textwidth}
\textbf{Case 4: Misprediction - Predicted Taken $\rightarrow$ Actually Not Taken} \hfill \textcolor{red!70!black}{\textbf{2 cycle penalty} \xmark}
\vspace{0.1cm}

\begin{tabular}{l|c|c|c|c|c|c|c|c}
\textbf{Instruction} & \textbf{C1} & \textbf{C2} & \textbf{C3} & \textbf{C4} & \textbf{C5} & \textbf{C6} & \textbf{C7} & \textbf{C8} \\
\hline
beq & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB & & & \\
\textit{bubble} & & \cellcolor{stallcolor!40}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & & \\
\textcolor{red}{target (wrong)} & & & \cellcolor{normalexec!40}IF & \cellcolor{flushcolor!40}ID & \cellcolor{flushcolor!40}\textsf{X} & \cellcolor{emptycolor}--- & \cellcolor{emptycolor}--- & \\
next (correct) & & & & \cellcolor{normalexec!40}IF & \cellcolor{normalexec!40}ID & \cellcolor{normalexec!40}EX & \cellcolor{normalexec!40}MEM & \cellcolor{normalexec!40}WB \\
\end{tabular}

\vspace{0.05cm}
\footnotesize \textbf{Bad:} 1 stall cycle + 1 incorrectly fetched instruction flushed
\end{minipage}
}
\end{center}

\vspace{0.1cm}

\begin{tikzpicture}[remember picture, overlay]
    \node[anchor=south east, inner sep=15pt, yshift=12mm] at (current page.south east) {
        \begin{tabular}{ll}
        \footnotesize
        \cellcolor{normalexec!40} & Normal execution \\
        \cellcolor{stallcolor!40} & Stall/Bubble \\
        \cellcolor{flushcolor!40}\textsf{X} & Flushed \\
        \cellcolor{emptycolor}--- & Empty stage \\
        \end{tabular}
    };
\end{tikzpicture}

\begin{center}
\large
\textcolor{red!70!black}{\textbf{Mispredictions are costly - always 2+ cycle penalty}}
\end{center}

\end{frame}

\begin{frame}{Q2: Optimization - Avoiding Stalls on Correct Prediction}
\textbf{Problem:} One cycle stall even on correct "Taken" prediction

\pause
\textbf{Solution 1: Store Previous Instruction Address}
\begin{itemize}
    \item Store address of instruction BEFORE the branch in BTB
    \item When that instruction reaches ID, start BTB lookup
    \item Branch instruction will be in IF stage
    \item Achieves optimal timing (no stall on correct prediction)
\end{itemize}

\pause
\textbf{Challenge:} Programs may reach branch from different locations

\vspace{0.1cm}
\begin{center}
\begin{tikzpicture}[
    every node/.style={font=\small\ttfamily},
    box/.style={draw, rectangle, minimum height=0.6cm, text width=3cm, align=center}
]
    \node[box] (j1) {200: Jump 100};
    \node[box, below=0.1cm of j1] (j2) {280: Jump 100};
    \node[box, below=0.1cm of j2] (j3) {300: Jump 100};
    \node[box, fill=blue!20, right=1.5cm of j2] (target) {100: Jump 1000};
    \node[box, fill=green!20, text width=2cm, right=1.5cm of target] (dest) {1000: ...};

    \draw[->, thick] (j1.east) -- (target.north west);
    \draw[->, thick] (j2.east) -- (target.west);
    \draw[->, thick] (j3.east) -- (target.south west);
    \draw[->, thick] (target.east) -- (dest.west);
\end{tikzpicture}
\end{center}
\vspace{0.1cm}

\pause
\textbf{Solution 2:} Store target instruction itself in BTB (saves IF stage)

\pause
\textbf{Solution 3:} Move BTB lookup to IF stage with specialized hardware
\end{frame}

\section{Question 3: Calculating Loop Iterations and State Machine Design}

\begin{frame}[fragile]{Q3a: BTB and Pipeline Timing}
\begin{columns}
\column{0.5\textwidth}
\begin{minted}[fontsize=\scriptsize, frame=single, bgcolor=gray!10]{nasm}
place2:
    ADDI R4,R4,#2
    ADDI R4,R4,#2
    LD R10,R4(128)
    ADDI R9,R9,#0
    BEQ R10,R1,place1
    ADDI R7,R7,#1
place1:
    BNEQ R10,R1,place2
    ADDI R8,R8,#1
\end{minted}

\column{0.5\textwidth}
\textbf{Given:}
\begin{itemize}
    \item MIPS-like processor
    \item Branch decision in EX stage
    \item BTB lookup in IF stage
    \item BTB contains both branch instructions
    \item Predictions are correct
    \item BNEQ is taken
\end{itemize}
\end{columns}

\vspace{0.3cm}
\textbf{Question:} How many cycles for first iteration starting from place2?

\textbf{Answer:} 7 cycles (7 instructions in the iteration)
\end{frame}

\begin{frame}{Q3b: Finding Number of Executions}
\textbf{\ding{193}} If the entire code takes 33 cycles, how many times was LD executed?

\textbf{Analysis:}
\begin{itemize}
    \item Last iteration: BNEQ not taken $\Rightarrow$ BEQ taken
    \item Each iteration has 7 instructions
    \item Each misprediction costs 2 cycles
    \item Pipeline fill needs 4 cycles
\end{itemize}

\textbf{Formula:}
$$7 \times \text{\#iterations} + 2 \times \text{\#mispredictions} + 4 = 33$$

Since each iteration has 2 branch instructions:
$$2 \times \text{\#iterations} \geq \text{\#mispredictions}$$

\textbf{Solution:} \#iterations = 3, \#mispredictions = 4
$\Rightarrow$ LD executed \textbf{3 times}
\end{frame}

\begin{frame}{Q3c: State Machine Configuration}
\textbf{\ding{194}} Design a state machine that produces 4 mispredictions in 6 branch executions (3~iterations)

\pause
\begin{center}
\begin{tikzpicture}[scale=0.8, node distance=2.5cm]
    % State machine for demonstration
    \node[state, fill=red!20] (nt) at (0, 0) {NT};
    \node[state, fill=green!20] (t) at (3, 0) {T};
    
    \path[->] 
    (nt) edge[bend left, above] node{T} (t)
    (t) edge[bend left, below] node{NT} (nt)
    (nt) edge[loop left] node{NT} (nt)
    (t) edge[loop right] node{T} (t);
    
    % Initial states on the left
    \node[align=left] at (-5.5, 0) {\textbf{Initial states:}\\BEQ: T\\BNEQ: NT};
\end{tikzpicture}
\end{center}
\begin{columns}
\column{0.12\textwidth}
\column{0.10\textwidth}
\textbf{Execution Trace:}
\column{0.65\textwidth}
\begin{table}
\centering
\scriptsize
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Iteration} & \textbf{Instruction} & \textbf{Prediction} & \textbf{Actual} \\
\hline
1 & BEQ & T & NT \\
1 & BNEQ & NT & T \\
2 & BEQ & NT & NT \\
2 & BNEQ & T & T \\
3 & BEQ & NT & T \\
3 & BNEQ & T & NT \\
\hline
\end{tabular}
\end{table}
\end{columns}

Result: 4 mispredictions, 2 correct predictions
\end{frame}

\begin{frame}{Summary}
\textbf{Key Concepts:}
\begin{itemize}
    \item \textbf{BTB (Branch Target Buffer)} stores:
    \begin{itemize}
        \item Branch instruction addresses
        \item Target addresses
        \item Prediction state (1-bit or 2-bit)
    \end{itemize}
    \item \textbf{2-bit predictors} provide better accuracy by requiring two consecutive mispredictions to change stable state
    \item \textbf{Pipeline integration} affects performance:
    \begin{itemize}
        \item BTB lookup stage determines stall cycles
        \item Branch resolution stage determines misprediction penalty
    \end{itemize}
    \item \textbf{Optimizations} can eliminate stalls on correct predictions
\end{itemize}

\textbf{Performance Impact:}
\begin{itemize}
    \item Correct prediction (Taken): 0-1 cycle penalty
    \item Correct prediction (Not Taken): 0 cycle penalty
    \item Misprediction: 2+ cycle penalty (depends on pipeline depth)
\end{itemize}
\end{frame}

\end{document}