\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{bytefield}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc}
\usepackage{tcolorbox}
\usetheme{Madrid}

\title{Computer Architecture}
\subtitle{Exercise 1: Performance Evaluation Parameters \& Amdahl's Law}
\author{Course 234267}
\date{}

\begin{document}

\frame{\titlepage}

%======================================
\begin{frame}{Course Information}
\begin{itemize}
    \item \textbf{Course Grading:}
    \begin{itemize}
        \item 3 mandatory exercises
        \item Submission in pairs
        \item Final exam
    \end{itemize}
    \item \textbf{Important:} Attend lectures and tutorials!
    \begin{itemize}
        \item Exam material includes all content from lectures and tutorials
        \item Slides don't contain everything
    \end{itemize}
    \item \textbf{Course website:}\\
    \url{http://webcourse.cs.technion.ac.il/234267/}
\end{itemize}
\end{frame}

%======================================
\begin{frame}{Architecture vs. Microarchitecture}
\begin{columns}
\column{0.5\textwidth}
\textbf{Architecture}
\begin{itemize}
    \item Interface between user (compiler/programmer) and processor
    \item Instruction set (instruction types, number of operands, addressing modes, etc.)
    \item Different processors can have different architectures
\end{itemize}

\column{0.5\textwidth}
\textbf{Microarchitecture}
\begin{itemize}
    \item Internal structure of the processor
    \item Implementation details
    \item How the architecture is realized in hardware
\end{itemize}
\end{columns}
\end{frame}

%======================================
\begin{frame}{CPU Performance and Time - Basic Concepts}
\begin{itemize}
    \item \textbf{CPU}: Central Processing Unit - synchronous component (operates according to internal clock signal)
    \item \textbf{ALU}: Part of CPU that performs arithmetic calculations
    \item \textbf{Clock Rate (CR)}: Number of clock cycles per second
    \begin{itemize}
        \item Measured in Hz (MHz = million cycles/second)
    \end{itemize}
    \item \textbf{Clock Cycle (CC)}: Time between two consecutive clock ticks
    \begin{itemize}
        \item Measured in seconds (1 nanosec = $10^{-9}$ sec)
    \end{itemize}
\end{itemize}

\begin{block}{Relationship}
$$\text{Clock Rate} = \frac{1}{\text{Clock Cycle}}$$
\end{block}
\end{frame}

%======================================
\begin{frame}{Key Performance Metrics}
\begin{itemize}
    \item \textbf{Instruction Count (IC)}: Number of machine instructions in a program
    \item \textbf{CPI (Cycles Per Instruction)}: Average number of clock cycles required to execute each instruction
    \item \textbf{CPI$_i$}: Clock cycles required for instruction type $i$
    \item \textbf{CPU Execution Time}: Time processor takes to execute a program
\end{itemize}

\begin{block}{CPU Time Formula}
$$\text{CPU Time} = \text{IC} \times \text{CPI} \times \text{CC}$$
$$\text{CPU Time} = \frac{\text{IC} \times \text{CPI}}{\text{Clock Rate}}$$
\end{block}
\end{frame}

%======================================
\begin{frame}{Calculating CPI for Benchmark Programs}
\begin{itemize}
    \item $n_i$ = Number of times instruction $i$ is executed
    \item $\text{IC} = \sum n_i$ = Total instructions executed
    \item Frequency of instruction $i$: $f_i = \frac{n_i}{\text{IC}}$
\end{itemize}

\begin{block}{Average CPI Calculation}
$$\text{CPI} = \frac{\text{Total Clock Cycles}}{\text{IC}} = \frac{\sum(n_i \times \text{CPI}_i)}{\sum n_i} = \sum(f_i \times \text{CPI}_i)$$
\end{block}

\begin{alertblock}{Question}
Does lower CPI necessarily mean faster computer?
\end{alertblock}

\end{frame}

%======================================
\begin{frame}{CPU Time Formula - Dimensional Analysis}
\centering
\begin{alertblock}{Question}
Does lower CPI necessarily mean faster computer?
\end{alertblock}
$$\text{CPU time}\left[\frac{\text{sec}}{\text{program}}\right] = 
\text{CC}\left[\frac{\text{sec}}{\tikzmark{cyc1}\text{cycle}\tikzmark{cyc2}}\right] \times
\text{CPI}\left[\frac{\tikzmark{cyc3}\text{cycle}\tikzmark{cyc4}}{\tikzmark{ins1}\text{instruction}\tikzmark{ins2}}\right] \times
\text{IC}\left[\frac{\tikzmark{ins3}\text{instruction}\tikzmark{ins4}}{\text{program}}\right]$$

% Add diagonal strikethrough lines using TikZ
\begin{tikzpicture}[remember picture, overlay]
    % Diagonal strike through "cycle" in CC term
    \draw[red, line width=1.5pt] ([shift={(-0.1,0)}]pic cs:cyc1) -- ([shift={(0.1,0.5ex)}]pic cs:cyc2);
    
    % Diagonal strike through "cycle" in CPI term numerator
    \draw[red, line width=1.5pt] ([shift={(-0.1,0)}]pic cs:cyc3) -- ([shift={(0.1,0.5ex)}]pic cs:cyc4);
    
    % Diagonal strike through "instruction" in CPI term denominator
    \draw[red, line width=1.5pt] ([shift={(-0.1,0)}]pic cs:ins1) -- ([shift={(0.1,0.5ex)}]pic cs:ins2);
    
    % Diagonal strike through "instruction" in IC term numerator
    \draw[red, line width=1.5pt] ([shift={(-0.1,0)}]pic cs:ins3) -- ([shift={(0.1,0.5ex)}]pic cs:ins4);
\end{tikzpicture}

\vspace{1cm}
\normalsize
\begin{block}{Result}
$$\text{CPU time} = \text{CC} \times \text{CPI} \times \text{IC}$$
Units simplify to: $\left[\frac{\text{seconds}}{\text{program}}\right]$
\end{block}
\end{frame}

%======================================
\begin{frame}{Performance Comparison}
\begin{block}{Speedup Formula}
$$\text{Speedup} = \frac{\text{CPU Time}_\text{old}}{\text{CPU Time}_\text{new}}= \frac{\text{IC}_\text{old} \times \text{CPI}_\text{old} \times \text{CC}_\text{old}}{\text{IC}_\text{new} \times \text{CPI}_\text{new} \times \text{CC}_\text{new}}$$
\end{block}

\begin{itemize}
    \item $\text{Speedup} > 1$: Performance improvement
    \item $\text{Speedup} < 1$: Performance degradation
    \item Consider all three factors: IC, CPI, and CC
\end{itemize}
\end{frame}

%======================================
\begin{frame}{MIPS Metric}
\textbf{MIPS = Millions of Instructions Per Second}

\begin{block}{MIPS Formula}
$$\text{MIPS} = \frac{\text{Instruction Count}}{\text{Execution Time} \times 10^6} = \frac{\text{Clock Rate}}{\text{CPI} \times 10^6}$$
\end{block}

\textbf{Problem with MIPS:}
\begin{itemize}
    \item Depends on instruction set and program composition
    \item Complex instructions may execute fewer instructions but take longer
    \item Can be misleading when comparing different architectures
\end{itemize}
\end{frame}

%======================================
\begin{frame}{MFLOPS Metric}
\textbf{MFLOPS = Millions of Floating Point Operations Per Second}

\begin{block}{MFLOPS Formula}
$$\text{MFLOPS} = \frac{\text{FP Operations Count}}{\text{Execution Time} \times 10^6}$$
\end{block}

\textbf{Issues:}
\begin{enumerate}
    \item Depends on compiler optimization
    \item Different FP operations take different times (add vs. divide)
\end{enumerate}

\textbf{Solution: Weighted MFLOPS}
\begin{itemize}
    \item Weight operations by execution time
    \item Example weights: Add/Sub/Mult = 1, Div/Sqrt = 4, Exp/Sin = 8
\end{itemize}
\end{frame}

%======================================
\begin{frame}{Benchmark Programs}
\textbf{Common problem:} Both MIPS and MFLOPS depend on chosen benchmark

\vspace{0.5em}
\textbf{Types of Benchmarks:}
\begin{itemize}
    \item \textbf{Real benchmarks}: Actual applications (word processors, spreadsheets, compilers)
    \item \textbf{Synthetic benchmarks}: Instruction collections representing "average" programs
    \item \textbf{Combined benchmarks}: Weighted collection of real and synthetic programs
\end{itemize}

\vspace{0.5em}
\textbf{Best practice:}
\begin{itemize}
    \item Compare processors under similar conditions
    \item Same benchmark, same compiler
    \item Run multiple programs and weight results
    \item Best metric: Actual execution time comparison
\end{itemize}
\end{frame}

%======================================
\begin{frame}{Example 1: Adding New Instruction (Part 1)}
\textbf{Given:} Computer with register-to-register operations, load/store memory access

\begin{table}[h]
\centering
\begin{tabular}{lcc}
\toprule
Instruction & Frequency & CPI \\
\midrule
ALU & 40\% & 1 \\
LOAD & 20\% & 2 \\
STORE & 10\% & 2 \\
BRANCH & 30\% & 2 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Observation:} 25\% of ALU instructions use data from previous LOAD

\textbf{Proposal:} Add ALU-MEM instruction (direct operation between register and memory)
\begin{itemize}
    \item CPI = 2 for ALU-MEM
    \item Increases BRANCH CPI to 3
\end{itemize}
\end{frame}

%======================================
\begin{frame}{Example 1: Solution - Before Change}
\textbf{Calculate original CPI:}
$$\text{CPI}_\text{old} = 0.4 \times 1 + 0.2 \times 2 + 0.1 \times 2 + 0.3 \times 2$$
$$= 0.4 + 0.4 + 0.2 + 0.6 = 1.6$$

\vspace{1em}
\textbf{CPU Time:}
$$\text{CPU Time}_\text{old} = \text{CPI}_\text{old} \times \text{IC}_\text{old} \times \text{CC}_\text{old}$$
$$= 1.6 \times \text{IC}_\text{old} \times \text{CC}_\text{old}$$
\end{frame}

%======================================
\begin{frame}{Example 1: Solution - After Change}
\textbf{New instruction counts:}
\begin{itemize}
    \item ALU: $0.75 \times 0.4 \times \text{IC}_\text{old} = 0.3 \times \text{IC}_\text{old}$
    \item ALU-MEM: $0.25 \times 0.4 \times \text{IC}_\text{old} = 0.1 \times \text{IC}_\text{old}$
    \item LOAD: $0.2 \times \text{IC}_\text{old} - 0.1 \times \text{IC}_\text{old} = 0.1 \times \text{IC}_\text{old}$
    \item STORE: $0.1 \times \text{IC}_\text{old}$ (unchanged)
    \item BRANCH: $0.3 \times \text{IC}_\text{old}$ (unchanged)
\end{itemize}

\textbf{Total:} $\text{IC}_\text{new} = 0.9 \times \text{IC}_\text{old}$

\textbf{New CPI:} 
$$\text{CPI}_\text{new} = \frac{0.3 \times 1 + 0.1 \times 2 + 0.1 \times 2 + 0.1 \times 2 + 0.3 \times 3}{0.9} = 2$$
\end{frame}

%======================================
\begin{frame}{Example 1: Performance Analysis}
\textbf{CPU Time after change:}
$$\text{CPU Time}_\text{new} = 0.9 \times \text{IC}_\text{old} \times 2 \times \text{CC}$$
$$= 1.8 \times \text{IC}_\text{old} \times \text{CC}$$

\vspace{1em}
\textbf{Speedup:}
$$\text{Speedup} = \frac{\text{CPU Time}_\text{old}}{\text{CPU Time}_\text{new}} = \frac{1.6 \times \text{IC}_\text{old} \times \text{CC}}{1.8 \times \text{IC}_\text{old} \times \text{CC}}$$
$$= \frac{1.6}{1.8} = 0.889$$

\begin{alertblock}{Result}
The "improvement" actually causes a slowdown! ($\text{Speedup} < 1$)
\end{alertblock}
\end{frame}

%======================================
\begin{frame}{Amdahl's Law}
\textbf{Question:} How much can we improve overall performance by optimizing a portion of the system?

\begin{block}{Amdahl's Law Formula}
$$\text{Speedup}_\text{overall} = \frac{1}{(1 - \text{Fraction}) + \frac{\text{Fraction}}{\text{Speedup}_\text{enhanced}}}$$
\end{block}

Where:
\begin{itemize}
    \item \textbf{Fraction}: Portion of execution time that can be enhanced
    \item \textbf{Speedup$_\text{enhanced}$}: Speedup of the enhanced portion
\end{itemize}

\textbf{Note:} Fraction refers to time portion, not instruction count!
\end{frame}

%======================================
\begin{frame}{Amdahl's Law - Example}
\textbf{Processor enhancements:}
\begin{itemize}
    \item Floating point operations: 2.5× faster
    \item Memory operations: 3× faster
    \item Integer add/subtract: 1.5× slower
\end{itemize}

\textbf{Benchmark program profile:}
\begin{itemize}
    \item Floating point: 15\% of execution time
    \item Memory operations: 20\%
    \item Integer add/subtract: 40\%
\end{itemize}

\textbf{Calculate overall speedup}
\end{frame}

%======================================
\begin{frame}{Amdahl's Law - Solution}
\textbf{New execution time calculation:}

Original time = 1 (normalized)

New time components:
\begin{itemize}
    \item FP operations: $\frac{0.15}{2.5} = 0.06$
    \item Memory operations: $\frac{0.20}{3} = 0.067$
    \item Integer operations: $\frac{0.40}{1/1.5} = 0.40 \times 1.5 = 0.60$
    \item Other operations: $0.25$ (unchanged)
\end{itemize}

\textbf{Total new time:} $0.06 + 0.067 + 0.60 + 0.25 = 0.977$

\textbf{Overall speedup:} $\frac{1}{0.977} = 1.024$ (2.4\% improvement)
\end{frame}

%======================================
\begin{frame}{Key Takeaways}
\begin{enumerate}
    \item \textbf{Performance metrics have limitations}
    \begin{itemize}
        \item MIPS can be misleading
        \item MFLOPS depends on operation mix
        \item Actual execution time is the best metric
    \end{itemize}
    
    \item \textbf{Amdahl's Law insights}
    \begin{itemize}
        \item Limited benefit from optimizing small portions
        \item Must consider the entire system
        \item Bottlenecks limit overall improvement
    \end{itemize}
    
    \item \textbf{Performance analysis requires}
    \begin{itemize}
        \item Understanding all factors: IC, CPI, Clock rate
        \item Careful consideration of trade-offs
        \item Real benchmarks for accurate comparison
    \end{itemize}
\end{enumerate}
\end{frame}

%======================================
\begin{frame}{Questions for Practice}
\begin{enumerate}
    \item If Computer A runs a program faster than Computer B, and both run the same assembly code, what can we conclude about their MIPS ratings?
    
    \item Why might adding a new instruction type actually slow down overall performance?
    
    \item According to Amdahl's Law, if 90\% of a program can be parallelized perfectly (infinite speedup), what is the maximum overall speedup?
    
    \item What are the trade-offs between complex instructions (high CPI, low IC) and simple instructions (low CPI, high IC)?
\end{enumerate}
\end{frame}

%======================================
\begin{frame}{Example 2: MFP vs NMFP Computers}
\textbf{Given:} Two computers with 100 MHz clock rate running same benchmark

\begin{columns}
\column{0.5\textwidth}
\textbf{Computer MFP:}
\begin{itemize}
    \item Has dedicated FP hardware
    \item Different clock cycles per FP operation
\end{itemize}

\begin{table}[h]
\small
\begin{tabular}{lc}
\toprule
Operation & Clock Cycles \\
\midrule
FP Multiply & 6 \\
FP Add & 4 \\
FP Divide & 20 \\
INT ops & 2 \\
\bottomrule
\end{tabular}
\end{table}

\column{0.5\textwidth}
\textbf{Computer NMFP:}
\begin{itemize}
    \item No FP hardware
    \item Emulates FP in software
    \item Each FP → multiple INT operations
\end{itemize}

\begin{table}[h]
\small
\begin{tabular}{lc}
\toprule
FP Operation & INT ops needed \\
\midrule
FP Multiply & 30 \\
FP Add & 20 \\
FP Divide & 50 \\
\bottomrule
\end{tabular}
\end{table}
\end{columns}
\end{frame}

%======================================
\begin{frame}{Example 2: Benchmark Program Profile}
\textbf{High-level language program composition:}

\begin{table}[h]
\centering
\begin{tabular}{lc}
\toprule
Operation Type & Frequency \\
\midrule
FP Multiply & 10\% \\
FP Add & 15\% \\
FP Divide & 5\% \\
INT operations & 70\% \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Task:} Compare the performance of both computers
\end{frame}

%======================================
\begin{frame}{Example 2: Part (a) - MIPS Calculation}
\textbf{Calculate MIPS for both machines:}

\vspace{0.3cm}
\begin{columns}[T]
\begin{column}{0.48\textwidth}
\centering
\textbf{MFP Computer}
\vspace{0.2cm}

\small
\begin{align*}
\text{CPI}_{\text{MFP}} &= 0.10 \times 6 \\
&+ 0.15 \times 4 \\
&+ 0.05 \times 20 \\
&+ 0.70 \times 2 \\
&= 0.6 + 0.6 + 1.0 + 1.4 \\
&= 3.6
\end{align*}

$$\text{MIPS}_{\text{MFP}} = \frac{100 \text{ MHz}}{3.6} = 27.78$$
\end{column}

\begin{column}{0.48\textwidth}
\centering
\textbf{NMFP Computer}
\vspace{0.2cm}

\small
\begin{align*}
\text{CPI}_{\text{NMFP}} &= 2 \\
&\text{(all operations} \\
&\text{executed as INT)}
\end{align*}

\vspace{0.5cm}
$$\text{MIPS}_{\text{NMFP}} = \frac{100 \text{ MHz}}{2} = 50$$
\end{column}
\end{columns}

\vspace{0.5cm}
\begin{alertblock}{Note}
NMFP has higher MIPS (50 vs 27.78) but may not be faster for FP-heavy programs!
\end{alertblock}
\end{frame}

%======================================
\begin{frame}{Example 2: Part (b) - Instruction Count}
\textbf{If MFP executes $3 \times 10^6$ instructions, how many for NMFP?}

\begin{table}[h]
\centering
\small
\begin{tabular}{lccc}
\toprule
Operation & Frequency & MFP Instructions & NMFP Instructions \\
\midrule
FP Multiply & 10\% & $3 \times 10^5$ & $3 \times 10^5 \times 30 = 9 \times 10^6$ \\
FP Add & 15\% & $4.5 \times 10^5$ & $4.5 \times 10^5 \times 20 = 9 \times 10^6$ \\
FP Divide & 5\% & $1.5 \times 10^5$ & $1.5 \times 10^5 \times 50 = 7.5 \times 10^6$ \\
INT ops & 70\% & $2.1 \times 10^6$ & $2.1 \times 10^6 \times 1 = 2.1 \times 10^6$ \\
\midrule
\textbf{Total} & & $3 \times 10^6$ & $27.6 \times 10^6$ \\
\bottomrule
\end{tabular}
\end{table}

NMFP needs 9.2× more instructions!
\end{frame}

%======================================
\begin{frame}{Example 2: Part (c) - Execution Time}
\textbf{Calculate execution time for both computers:}

\textbf{MFP Computer:}
$$\text{CPU Time}_{\text{MFP}} = \text{IC} \times \text{CPI} \times \text{CC}$$
$$= 3 \times 10^6 \times 3.6 \times 10^{-8} = 0.108 \text{ seconds}$$

\textbf{NMFP Computer:}
$$\text{CPU Time}_{\text{NMFP}} = 27.6 \times 10^6 \times 2 \times 10^{-8}$$
$$= 0.552 \text{ seconds}$$

\begin{block}{Result}
MFP is 5.1× faster despite lower MIPS!
$$\text{Speedup} = \frac{0.552}{0.108} = 5.11$$
\end{block}
\end{frame}

%======================================
\begin{frame}{Example 2: Part (d) - MFLOPS Comparison}
\textbf{Calculate MFLOPS for both computers:}

Number of FP operations (same for both):
$$\text{FP ops} = (0.10 + 0.15 + 0.05) \times 3 \times 10^6 = 0.9 \times 10^6$$

\textbf{MFP:}
$$\text{MFLOPS}_{\text{MFP}} = \frac{0.9 \times 10^6}{0.108 \times 10^6} = 8.33$$

\textbf{NMFP:}
$$\text{MFLOPS}_{\text{NMFP}} = \frac{0.9 \times 10^6}{0.552 \times 10^6} = 1.63$$

\begin{alertblock}{Observation}
MFP has higher MFLOPS (correctly reflecting FP performance) unlike MIPS metric
\end{alertblock}
\end{frame}

%======================================
\begin{frame}{Alternative Solution Method for Example 1}
\textbf{More intuitive approach using 100 instructions:}

\vspace{1em}

\begin{columns}
\column{0.5\textwidth}
\centering
\textbf{Before change}
\vspace{-0.5em}
\begin{table}[h]
\scriptsize
\begin{tabular}{lcc}
\toprule
Instruction & Count & CPI \\
\midrule
ALU & 40 & 1 \\
LOAD & 20 & 2 \\
STORE & 10 & 2 \\
BRANCH & 30 & 2 \\
\midrule
Total & 100 & - \\
\bottomrule
\end{tabular}
\end{table}

\centering $\rightarrow$ Clock cycles = 160

\column{0.5\textwidth}
\centering
\textbf{After change:}
\vspace{-0.5em}
\begin{table}[h]
\scriptsize
\begin{tabular}{lcc}
\toprule
Instruction & Count & CPI \\
\midrule
ALU & 30 & 1 \\
LOAD & 10 & 2 \\
STORE & 10 & 2 \\
BRANCH & 30 & 3 \\
ALU-MEM & 10 & 2 \\
\midrule
Total & 90 & - \\
\bottomrule
\end{tabular}
\end{table}

\vspace{-0.5em}
\centering $\rightarrow$ Clock cycles = 180
\end{columns}

\vspace{1em}
Clock rate unchanged $\rightarrow$ comparing cycles is sufficient: $\text{Speedup} = \frac{160}{180} = 0.889$
\end{frame}

%======================================
\begin{frame}{Extended Amdahl's Law for CPI}
When instruction count doesn't change, we can apply Amdahl's Law to CPI:

\begin{block}{CPI-based Amdahl's Law}
$$\text{CPI}_{\text{new}} = \text{CPI}_{\text{old}} \times \left[(1 - \text{Fraction}) + \frac{\text{Fraction}}{\text{Improvement}}\right]$$
\end{block}

\textbf{Conditions:}
\begin{itemize}
    \item Instruction count remains constant
    \item Fraction must be valid in both cases
    \item Clock rate unchanged
\end{itemize}

\textbf{Example application:}
If 40\% of cycles can be improved by 2×:
$$\text{Speedup} = \frac{1}{(1 - 0.4) + \frac{0.4}{2}} = \frac{1}{0.8} = 1.25$$
\end{frame}

%======================================
\begin{frame}{Practice Questions - Part 1}
\textbf{Question 1:} A high-level program contains 20 FP operations and runs faster on Computer A than Computer B. Which statements are necessarily true?

\begin{enumerate}
    \item Computer A has MIPS $\geq$ Computer B's MIPS
    \item Computer A has MFLOPS $\geq$ Computer B's MFLOPS
    \item Computer A's CPI $\geq$ Computer B's CPI
    \item Computer A's CPI $\leq$ Computer B's CPI
    \item Computer A's clock rate $\geq$ Computer B's clock rate
    \item Computer B's cycle time $\geq$ Computer A's cycle time
    \item None of the above can be determined with certainty
\end{enumerate}\end{frame}

%======================================
\begin{frame}{Practice Questions - Part 1: Explanation}
\scriptsize
\textbf{Given:} High-level program with 20 FP ops, runs faster on Computer A than B

\begin{enumerate}
    \item Computer A has MIPS $\geq$ Computer B's MIPS\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Different compilers may generate different IC
    \pause
    
    \item Computer A has MFLOPS $\geq$ Computer B's MFLOPS\\
    \pause
    \hspace{1em}\colorbox{green!20}{\textcolor{green!50!black}{\textbf{TRUE}}} - MFLOPS = FP ops / Time, same FP ops + less time = higher MFLOPS
    \pause
    
    \item Computer A's CPI $\geq$ Computer B's CPI\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Could have lower CPI but slower clock
    \pause
    
    \item Computer A's CPI $\leq$ Computer B's CPI\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Could have higher CPI but faster clock
    \pause
    
    \item Computer A's clock rate $\geq$ Computer B's clock rate\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Could have slower clock but better CPI/IC
    \pause
    
    \item Computer B's cycle time $\geq$ Computer A's cycle time\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Cycle time = 1/Clock rate, unrelated to execution time
\end{enumerate}

\pause
\begin{alertblock}{Answer: 2}
Only MFLOPS can be determined with certainty
\end{alertblock}
\end{frame}

%======================================
\begin{frame}{Practice Questions - Part 2}
\textbf{Question 2:} What if the same assembly program runs on both computers?

\begin{enumerate}
    \item Computer A has MIPS $\geq$ Computer B's MIPS
    \item Computer A has MFLOPS $\geq$ Computer B's MFLOPS
    \item Computer A's CPI $\geq$ Computer B's CPI
    \item Computer A's CPI $\leq$ Computer B's CPI
    \item Computer A's clock rate $\geq$ Computer B's clock rate
    \item Computer B's cycle time $\geq$ Computer A's cycle time
    \item None of the above can be determined with certainty
\end{enumerate}\end{frame}

%======================================
\begin{frame}{Practice Questions - Part 2: Explanation}
\scriptsize
\textbf{Given:} Same assembly program on both computers, A runs faster than B

\begin{enumerate}
    \scriptsize
    \item Computer A has MIPS $\geq$ Computer B's MIPS\\
    \pause
    \hspace{1em}\colorbox{green!20}{\textcolor{green!50!black}{\textbf{TRUE}}} - MIPS = IC/(Time$\times 10^6$), same IC + less time = higher MIPS
    \pause
    
    \item Computer A has MFLOPS $\geq$ Computer B's MFLOPS\\
    \pause
    \hspace{1em}\colorbox{green!20}{\textcolor{green!50!black}{\textbf{TRUE}}} - Same FP operations + less time = higher MFLOPS
    \pause
    
    \item Computer A's CPI $\geq$ Computer B's CPI\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Time = IC $\times$ CPI $\times$ CC; A could have lower CPI, slower clock
    \pause
    
    \item Computer A's CPI $\leq$ Computer B's CPI\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - A could have higher CPI, faster clock
    \pause
    
    \item Computer A's clock rate $\geq$ Computer B's clock rate\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - A could have slower clock, lower CPI
    \pause
    
    \item Computer B's cycle time $\geq$ Computer A's cycle time\\
    \pause
    \hspace{1em}\colorbox{red!20}{\textcolor{red}{\textbf{FALSE}}} - Cycle time depends on clock rate, not execution time
\end{enumerate}

\pause
\begin{alertblock}{Answer: 1 and 2}
With same IC, both MIPS and MFLOPS must be higher for faster execution
\end{alertblock}
\end{frame}

%======================================
\begin{frame}{Summary: Performance Metrics Comparison}
\begin{table}[h]
\centering
\scriptsize
\begin{tabular}{lll}
\toprule
\textbf{Metric} & \textbf{Pros} & \textbf{Cons} \\
\midrule
\textbf{Execution Time} & Most accurate & Program-specific \\
& Direct measurement & Need actual run \\
\midrule
\textbf{MIPS} & Easy to understand & ISA dependent \\
& Single number & Misleading for different ISAs \\
\midrule
\textbf{MFLOPS} & Good for FP-intensive & Only considers FP ops \\
& Normalized metric & Compiler dependent \\
\midrule
\textbf{CPI} & Architecture insight & Needs IC and clock rate \\
& Useful for analysis & Program dependent \\
\bottomrule
\end{tabular}
\end{table}

\begin{block}{Remember}
$$\text{Performance} = \frac{1}{\text{Execution Time}}$$
Everything else is just an approximation!
\end{block}
\end{frame}

%======================================
\begin{frame}{Summary: Key Takeaways}
\begin{enumerate}
    \item \textbf{CPU Performance Equation is Fundamental}
    \begin{itemize}
        \item CPU Time = IC $\times$ CPI $\times$ Clock Cycle
        \item All three factors must be considered together
        \item Improving one may hurt others
    \end{itemize}
    
    \item \textbf{Performance Metrics Have Limitations}
    \begin{itemize}
        \item MIPS: Can be misleading (higher MIPS $\neq$ faster)
        \item MFLOPS: Only meaningful for FP-intensive programs
        \item Execution time is the only true measure
    \end{itemize}
    
    \item \textbf{Amdahl's Law: Focus on the Common Case}
    \begin{itemize}
        \item Overall speedup limited by unimproved portions
        \item Example: 90\% parallelizable $\rightarrow$ max speedup = 10×
        \item Optimize the bottlenecks first
    \end{itemize}
    
    \item \textbf{Beware of "Improvements"}
    \begin{itemize}
        \item Adding complex instructions may reduce IC but increase CPI
        \item Net effect can be negative (as in ALU-MEM example)
        \item Always measure actual performance
    \end{itemize}
\end{enumerate}
\end{frame}

%======================================
\begin{frame}{Final Thoughts}
\centering
\Large

\vspace{1cm}
\textbf{Remember the Iron Law of Performance:}

\vspace{0.5cm}
\huge
$$\text{Time} = \frac{\text{Instructions}}{\text{Program}} \times \frac{\text{Cycles}}{\text{Instruction}} \times \frac{\text{Time}}{\text{Cycle}}$$

\vspace{1cm}
\Large
\textcolor{blue}{All three factors matter equally!}

\vspace{1cm}
\normalsize
\begin{block}{Golden Rule}
When evaluating performance improvements:\\
\textbf{Measure, don't assume!}
\end{block}
\end{frame}

\end{document}