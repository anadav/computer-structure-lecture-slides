\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{array}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{bytefield}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, automata, backgrounds, matrix, shapes.gates.logic.US, decorations.pathreplacing}
\usepackage[siunitx, RPvoltages]{circuitikz}
\usepackage{tcolorbox}

% Define colors
\definecolor{myblue}{RGB}{0,0,255}
\definecolor{mypurple}{RGB}{128,0,128}
\definecolor{mygreen}{RGB}{0,128,0}
\definecolor{myorange}{RGB}{255,140,0}
\definecolor{lightblue}{RGB}{173,216,230}
\definecolor{peach}{RGB}{255,218,185}
\definecolor{lightpurple}{RGB}{230,230,250}

\usetheme{Madrid}
\setbeamertemplate{navigation symbols}{}

\title{Branch Prediction}
\author{Computer Architecture 2340267}
\date{2025, Lecture \#6}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Overview}

\begin{frame}
\frametitle{Branch Prediction Unit in the Pipeline}
\label{frame:bpu_pipeline}

% TODO: Add pipeline diagram showing BPU integration
% See PDF page 2 for reference diagram
\begin{center}
\textcolor{red}{[PLACEHOLDER: Pipeline diagram with BPU, showing Fetch/Decode/Execute/Memory/WB stages]}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{Lookup BPU in parallel to I\$}
    \begin{itemize}
        \item BPU provides the predicted target and direction at fetch
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{itemize}
    \item \textbf{At Execute stage}
    \begin{itemize}
        \item Verify direction (T/NT) and target (if taken)
        \item Flush if mis-predict
        \item Update/allocate BPU
    \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Branches and Performance}
\label{frame:branches_performance}

\begin{itemize}
    \item \textbf{Misprediction Rate (MPR) vs. Misprediction Per Instruction (MPI)}
\end{itemize}

\vspace{0.3cm}

\begin{center}
\begin{tabular}{ccc}
$\text{MPR} = \dfrac{\text{\# mis-predicted jumps}}{\text{total \# jump}}$ & \hspace{1cm} & $\text{MPI} = \dfrac{\text{\# mis-predicted jumps}}{\text{total \# instructions}}$
\end{tabular}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item MPI correlates better with performance since it takes into account jumps frequency
\end{itemize}

\vspace{0.2cm}

\begin{itemize}
    \item \textbf{Assume}
    \begin{itemize}
        \item MPI = 1\% (1 flush every 100 instructions on average)
        \item IPC=2 \hspace{0.5cm} (2 instructions per cycle on average)
        \item Flush penalty of 10 cycles
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{itemize}
    \item \textbf{We get:}
    \begin{itemize}
        \item MPI = 1\% $\Rightarrow$ 1 flush every 100 instructions on average
        \item IPC=2 $\Rightarrow$ 1 flush every 50 cycles
        \item 10 cycles flush penalty every 50 cycles
        \item 20\% in performance
    \end{itemize}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{What/Who/When We Predict/Fix/Allocate}
\label{frame:predict_fix_allocate}

\begin{tikzpicture}[scale=0.85, transform shape,
    box/.style={rectangle, draw=black, thick, minimum height=0.8cm, text width=4.2cm, align=left, font=\footnotesize},
    greenbox/.style={box, fill=green!30},
    yellowbox/.style={box, fill=yellow!60},
    arrow/.style={->, thick, >=stealth}
]

% Column headers
\node[font=\normalsize, anchor=south] at (2.1, 5.8) {\underline{Fetch}};
\node[font=\normalsize, anchor=south] at (7.5, 5.8) {\underline{Decode}};
\node[font=\normalsize, anchor=south] at (12.9, 5.8) {\underline{Execute}};

% Fetch column
\node[greenbox] (ta) at (2.1, 4.5) {
    \textbf{Target Array}\\
    $\diamond$ Branch type\\
    \hspace{0.3cm}$\triangleright$ conditional direct\\
    \hspace{0.3cm}$\triangleright$ unconditional direct\\
    \hspace{0.3cm}$\triangleright$ unconditional indirect\\
    \hspace{0.3cm}$\triangleright$ call\\
    \hspace{0.3cm}$\triangleright$ return\\
    $\diamond$ Branch target
};

\node[yellowbox] (cbp) at (2.1, 2.3) {
    \textbf{Cond. Branch Predictor}\\
    $\diamond$ Predict conditional T/NT
};

\node[greenbox] (rsb) at (2.1, 0.7) {
    \textbf{Return Stack Buffer}\\
    $\diamond$ Predict return target
};

\node[greenbox] (ita) at (2.1, -1.0) {
    \textbf{Indirect Target Array}\\
    $\diamond$ Predict indirect target\\
    \hspace{0.3cm}$\triangleright$ override TA target
};

% Decode column
\node[greenbox] (dec1) at (7.5, 4.5) {
    $\diamond$ Fix TA miss\\
    $\diamond$ Allocate TA\\
    $\diamond$ Fix wrong direct target
};

\node[yellowbox] (dec2) at (7.5, 2.3) {
    on TA miss for cond. br, use\\
    pred from cond. br. predictor
};

\node[greenbox] (dec3) at (7.5, 0.7) {
    on TA miss for RET,\\
    use prediction from RSB
};

\node[greenbox] (dec4) at (7.5, -1.0) {
    on TA miss for ind branch,\\
    use prediction from ITA
};

% Execute column
\node[greenbox] (exe1) at (12.9, 4.5) {
    $\diamond$ Allocate TA
};

\node[yellowbox] (exe2) at (12.9, 2.3) {
    Fix wrong cond. br\\
    prediction + allocate
};

\node[greenbox] (exe3) at (12.9, 0.7) {
    Fix wrong RET\\
    prediction
};

\node[greenbox] (exe4) at (12.9, -1.0) {
    Fix wrong indirect\\
    prediction + allocate
};

% Arrows between columns
\draw[arrow] (ta.east) -- (dec1.west);
\draw[arrow] (cbp.east) -- (dec2.west);
\draw[arrow] (rsb.east) -- (dec3.west);
\draw[arrow] (ita.east) -- (dec4.west);

\draw[arrow] (dec1.east) -- (exe1.west);
\draw[arrow] (dec2.east) -- (exe2.west);
\draw[arrow] (dec3.east) -- (exe3.west);
\draw[arrow] (dec4.east) -- (exe4.west);

% Vertical dashed lines
\draw[dashed, gray] (0, -2) -- (0, 6);
\draw[dashed, gray] (4.3, -2) -- (4.3, 6);
\draw[dashed, gray] (10.7, -2) -- (10.7, 6);
\draw[dashed, gray] (15.1, -2) -- (15.1, 6);

% Left annotation
\node[draw, rounded corners, thick, text width=2.5cm, align=center, font=\footnotesize] at (-2.2, 1.5) {
    85\% of jumps,\\
    with big\\
    misprediction\\
    penalty
};
\draw[thick] (-1.0, 1.5) -- (-0.2, 2.3);


% Red flush arrows (arrow ends just before the text)
\draw[arrow, red, very thick] (9.7, -1.8) -- (0.2, -1.8);
\node[red, font=\normalsize, anchor=west] at (9.75, -1.8) {\textbf{Dec Flush}};

\draw[arrow, red, very thick] (14.2, -2.3) -- (0.2, -2.3);
\node[red, font=\normalsize, anchor=west] at (14.25, -2.3) {\textbf{Exe Flush}};

\end{tikzpicture}

\end{frame}

\section{The Target Array}

\begin{frame}
\frametitle{Target Array}
\label{frame:target_array}

\begin{columns}[T]
\begin{column}{0.58\textwidth}
\begin{itemize}
    \item \textbf{The TA is accessed using the branch address (branch IP)}
    \begin{itemize}
        \item Implemented as an $n$-way set associative cache
    \end{itemize}
\end{itemize}

\vspace{0.15cm}

\begin{itemize}
    \item \textbf{The TA predicts the following}
    \begin{itemize}
        \item Instruction is a branch
        \item Predicted target
        \item Branch type
        \begin{itemize}
            \item Conditional: jump to target if predict taken
            \item Unconditional direct: take target
            \item Unconditional Indirect: if ITA hits, use its target
            \item Return: get target from Return Stack Buffer
        \end{itemize}
    \end{itemize}
\end{itemize}

\vspace{0.15cm}

\begin{itemize}
    \item \textbf{The TA is allocated/updated at Decode / EXE}
\end{itemize}

\vspace{0.15cm}

\begin{itemize}
    \item \textbf{Tags are usually partial}
    \begin{itemize}
        \item Trade-off space, can get false hits
        \item Few branches aliased to same entry
        \item No \textit{correctness}, only \textit{performance}
    \end{itemize}
\end{itemize}
\end{column}

\begin{column}{0.42\textwidth}
\vspace{0.5cm}
\begin{center}
\begin{tikzpicture}[scale=0.9]
    % Define dimensions
    \def\tablewidth{5.5}
    \def\tableheight{3.5}
    \def\headerheight{0.6}
    \def\tagwidth{1.3}
    \def\targetwidth{2.7}
    \def\typewidth{1.5}
    
    % Draw the main table structure with colored columns
    % Tag column background
    \fill[lightblue!30] (0,0) rectangle (\tagwidth, -\tableheight);
    % Target column background  
    \fill[green!15] (\tagwidth,0) rectangle (\tagwidth+\targetwidth, -\tableheight);
    % Type column background
    \fill[peach!40] (\tagwidth+\targetwidth,0) rectangle (\tablewidth, -\tableheight);
    
    % Draw header row with stronger colors
    \fill[lightblue!50] (0,0) rectangle (\tagwidth, -\headerheight);
    \fill[green!30] (\tagwidth,0) rectangle (\tagwidth+\targetwidth, -\headerheight);
    \fill[peach!60] (\tagwidth+\targetwidth,0) rectangle (\tablewidth, -\headerheight);
    
    % Draw the table border
    \draw[thick, black] (0,0) rectangle (\tablewidth, -\tableheight);
    
    % Draw column dividers
    \draw[thick] (\tagwidth, 0) -- (\tagwidth, -\tableheight);
    \draw[thick] (\tagwidth+\targetwidth, 0) -- (\tagwidth+\targetwidth, -\tableheight);
    
    % Draw header separator
    \draw[thick] (0, -\headerheight) -- (\tablewidth, -\headerheight);
    
    % Add some row lines to show it's a table
    \foreach \y in {1.2, 1.9, 2.6} {
        \draw[gray, thin] (0, -\y) -- (\tablewidth, -\y);
    }
    
    % Header labels
    \node[myblue, font=\small\bfseries] at (\tagwidth/2, -\headerheight/2) {tag};
    \node[myblue, font=\small\bfseries] at (\tagwidth+\targetwidth/2, -\headerheight/2) {target};
    \node[myblue, font=\small\bfseries] at (\tagwidth+\targetwidth+\typewidth/2, -\headerheight/2) {type};
    
    % Branch IP label and arrow pointing to table
    \node[myblue, font=\small\bfseries] at (-1.2, -1.5) {Branch IP};
    \draw[->, thick, myblue] (-0.3, -1.5) -- (0, -1.5);
    
    % Output arrows and labels below the table
    \draw[->, thick] (\tagwidth/2, -\tableheight) -- (\tagwidth/2, -\tableheight-0.7);
    \node[align=center, font=\tiny, myblue] at (\tagwidth/2, -\tableheight-1.0) {hit/miss\\(indicates\\a branch)};
    
    \draw[->, thick] (\tagwidth+\targetwidth/2, -\tableheight) -- (\tagwidth+\targetwidth/2, -\tableheight-0.7);
    \node[align=center, font=\tiny, myblue] at (\tagwidth+\targetwidth/2, -\tableheight-1.0) {predicted\\target};
    
    \draw[->, thick] (\tagwidth+\targetwidth+\typewidth/2, -\tableheight) -- (\tagwidth+\targetwidth+\typewidth/2, -\tableheight-0.7);
    \node[align=center, font=\tiny, myblue] at (\tagwidth+\targetwidth+\typewidth/2, -\tableheight-1.0) {predicted\\type};
\end{tikzpicture}
\end{center}
\end{column}
\end{columns}

\end{frame}




\begin{frame}{The Target Array}
\begin{columns}[T,onlytextwidth]
  \begin{column}{0.63\textwidth}
    \begin{itemize}
      \item The TA is accessed using the branch address (branch IP)
      \begin{itemize}
        \item Implemented as an $n$-way set associative cache
      \end{itemize}

      \item The TA predicts the following
      \begin{itemize}
        \item Instruction is a branch
        \item Predicted target
        \item Branch type
        \begin{itemize}
          \item Conditional: jump to target if predict taken
          \item Unconditional direct: take target
          \item Unconditional indirect: if iTA hits, use its target
          \item Return: get target from Return Stack Buffer
        \end{itemize}
      \end{itemize}

      \item The TA is allocated/updated at Decode / EXE

      \item Tags are usually partial
      \begin{itemize}
        \item Trade-off space, can get false hits
        \item Few branches aliased to same entry
        \item No correctness, only performance
      \end{itemize}
    \end{itemize}
  \end{column}

  \begin{column}{0.37\textwidth}
    \centering
    \begin{tikzpicture}[>=Stealth, node distance=2mm]
      % Sizes
      \def\W{4.2}   % total width
      \def\H{4.2}   % total height
      \def\tagw{1.0}
      \def\targetw{2.6}
      \def\typew{0.6}

      % Background column tints
      \fill[blue!12]   (0,-\H) rectangle (\tagw,0);
      \fill[green!12]  (\tagw,-\H) rectangle (\tagw+\targetw,0);
      \fill[orange!18] (\tagw+\targetw,-\H) rectangle (\W,0);

      % Outer box
      \draw[rounded corners=1pt, line width=0.8pt] (0,0) rectangle (\W,-\H);

      % Column dividers
      \draw (\tagw,0) -- (\tagw,-\H);
      \draw (\tagw+\targetw,0) -- (\tagw+\targetw,-\H);

      % Header separator
      \draw (0,-0.8) -- (\W,-0.8);

      % Header labels
      \node[font=\small\bfseries,blue]   at ($(0,0)!0.5!(\tagw,0)+(0,-0.4)$) {tag};
      \node[font=\small\bfseries,blue]   at ($(\tagw,0)!0.5!(\tagw+\targetw,0)+(0,-0.4)$) {target};
      \node[font=\small\bfseries,blue]   at ($(\tagw+\targetw,0)!0.5!(\W,0)+(0,-0.4)$) {type};

      % Branch IP input (left)
      \node[align=left, blue] (bp) at (-1.5,-0.6) {\small Branch IP};
      \draw[->,blue,thick] (bp.east) -- (-0.02,-1.0);

      % Bottom outputs
      \node[align=center, font=\scriptsize, blue!70!black] (hit) at (\tagw/2,-\H-0.9) {hit / miss\\(indicates\\a branch)};
      \draw[->] (\tagw/2,-\H) -- (hit.north);

      \node[align=center, font=\scriptsize, blue!70!black] (pt) at (\tagw+\targetw/2,-\H-0.7) {predicted\\target};
      \draw[->] (\tagw+\targetw/2,-\H) -- (pt.north);

      \node[align=center, font=\scriptsize, blue!70!black] (ty) at (\tagw+\targetw+\typew/2,-\H-0.7) {predicted\\type};
      \draw[->] (\tagw+\targetw+\typew/2,-\H) -- (ty.north);
    \end{tikzpicture}
  \end{column}
\end{columns}
\end{frame}

\section{Conditional Branch Direction Prediction}

\subsection{Bimodal Predictors}

\begin{frame}
\frametitle{Bimodal Predictor}
\label{frame:bimodal_predictor_cont}

\vspace{-0.2cm}

\begin{center}
\textcolor{myblue}{\textbf{2-bit-sat counter array}}
\end{center}

\vspace{0.2cm}

\begin{center}
\begin{tikzpicture}[scale=0.7]
    % Draw the counter array
    \fill[lightblue] (0,0) rectangle (1,4.5);
    \draw[thick] (0,0) rectangle (1,4.5);
    
    % Draw array divisions
    \foreach \y in {0.5,1,1.5,2,2.5,3,3.5,4} {
        \draw (0,\y) -- (1,\y);
    }
    
    % Highlight the second cell from top (the one being accessed)
    \fill[lightblue!60] (0,3.5) rectangle (1,4);
    
    % Labels and arrows - pointing to second cell from top
    \node[mygreen,anchor=east,font=\small] at (-0.8,3.75) {l.s. bits of branch IP};
    \draw[->,thick,mygreen] (-0.2,3.75) -- (0,3.75);
    
    \node[mypurple,anchor=west,font=\small] at (1.8,3.75) {Prediction = msb of counter};
    \draw[->,thick,mypurple] (1,3.75) -- (1.3,3.75);
    
    % Curved arrow for update - starting low and curving up to second cell
    \draw[->,thick,myblue] (1.1,1.5) .. controls (2.5,1.5) and (2.5,3.5) .. (1,3.5);
    \node[myblue,align=left,anchor=west,font=\footnotesize] at (1.8,0.9) {Update counter\\with branch outcome\\(at execution)};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \small\textbf{2-bit predictor avoids a double mistake in loops / glitches from the pattern}
\end{itemize}

\vspace{0.1cm}

{\footnotesize
\begin{tabular}{@{}ll@{}}
Branch Outcome & \texttt{0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1} \\
Prediction & \texttt{?~0 0 0 0 \textcolor{red}{0} 0 0 0 0 0 \textcolor{red}{0} 0 0 0 0 0 0} \\
\end{tabular}
}

\end{frame}


\begin{frame}
\frametitle{Bimodal (2-Bit) Predictor}
\label{frame:bimodal_2bit}

%\vspace{-0.3cm}

\begin{itemize}
    \item \textbf{A 2-bit counter avoids the double mistake in glitches}
    \begin{itemize}
        \item Need "more evidence" to change prediction
    \end{itemize}
\end{itemize}

\vspace{-0.2cm}

\begin{center}
\begin{tikzpicture}[
    state/.style={circle,draw,thick,minimum size=1.2cm,font=\footnotesize,align=center},
    arrow/.style={->,>=stealth,thick},
    scale=0.9
]
    % Distinct background shades for prediction regions
    \begin{scope}[on background layer]
        \fill[peach!50] (-2.5,-1.5) rectangle (3.75,2); % Predict not-taken region
        \fill[lightpurple!70] (3.75,-1.5) rectangle (10,2); % Predict taken region, extended further right
    \end{scope}
    
    % States (LSB in black)
    \node[state,fill=peach!30] (SNT) at (0,0) {\textcolor{myorange}{0}\textcolor{black}{0}\\SNT};
    \node[state,fill=peach!20] (WNT) at (2.5,0) {\textcolor{myorange}{0}\textcolor{black}{1}\\WNT};
    \node[state,fill=lightpurple!40] (WT) at (5,0) {\textcolor{mypurple}{1}\textcolor{black}{0}\\WT};
    \node[state,fill=lightpurple!50] (ST) at (7.5,0) {\textcolor{mypurple}{1}\textcolor{black}{1}\\ST};
    
    % Self loop for SNT: from top left to bottom left, label on two lines
    \draw[arrow] (SNT) .. controls (-0.7,0.8) and (-0.7,-0.8) .. node[left,mygreen,font=\scriptsize,align=center] {not-\\taken} (SNT);
    % Self loop for ST: from top right to bottom right
    \draw[arrow] (ST) .. controls (8.5,0.8) and (8.5,-0.8) .. node[right,mygreen,font=\scriptsize,align=center] {taken} (ST);
    
    % Transitions between states
    \draw[arrow] (SNT) to[bend left=30] node[above,mygreen,font=\scriptsize] {taken} (WNT);
    \draw[arrow] (WNT) to[bend left=30] node[below,mygreen,font=\scriptsize] {not-taken} (SNT);
    
    \draw[arrow] (WNT) to[bend left=30] node[above,mygreen,font=\scriptsize] {taken} (WT);
    \draw[arrow] (WT) to[bend left=30] node[below,mygreen,font=\scriptsize] {not-taken} (WNT);
    
    \draw[arrow] (WT) to[bend left=30] node[above,mygreen,font=\scriptsize] {taken} (ST);
    \draw[arrow] (ST) to[bend left=30] node[below,mygreen,font=\scriptsize] {not-taken} (WT);
    
    % Prediction labels
    \node[myorange,font=\small] at (1.25,-1.2) {Predict not-taken};
    \node[mypurple,font=\small] at (6.25,-1.2) {Predict taken};
\end{tikzpicture}
\end{center}

\vspace{0.1cm}

\begin{itemize}
    \item Initial state: weakly-taken (most branches are taken)
\end{itemize}

\begin{itemize}
    \item \textbf{Update (at execution)}
    \begin{itemize}
        \item Branch was actually taken: increment counter (saturate at 11)
        \item Branch was actually not-taken: decrement counter (saturate at 00)
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item \textbf{Predict according to m.s.bit of counter (0=NT, 1=taken)}
    \item \textbf{Does not predict well branches with patterns like 010101...}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Bimodal Predictor Example}
\label{frame:bimodal_example}

\begin{columns}[T]
\begin{column}{0.62\textwidth}

% Br1 prediction with tabular and vertical arrows
\begin{itemize}
\item \textbf{Br1 prediction}
\end{itemize}
\begin{tikzpicture}[baseline=(current bounding box.center),every node/.style={anchor=base}]
    % Table for alignment
    \matrix[matrix of nodes,nodes={minimum width=0.5cm,anchor=center},column sep=0.4cm,row sep=0.2cm,ampersand replacement=\&] (m) {
        1 \& 0 \& 1 \& 0 \& 1 \& 0 \\
        2 \& 3 \& 2 \& 3 \& 2 \& 3 \\
        \textcolor{mygreen}{1} \& \textcolor{red}{1} \& \textcolor{mygreen}{1} \& \textcolor{red}{1} \& \textcolor{mygreen}{1} \& \textcolor{red}{1} \\
    };
    % Arrows from pattern to counter
    \foreach \i in {1,...,6} {
        \draw[->,thick] (m-1-\i.south) -- (m-2-\i.north);
        \draw[->,thick] (m-2-\i.south) -- (m-3-\i.north);
    }
    % Labels
    \node[left=0.2cm of m-1-1,align=right] {Pattern:};
    \node[left=0.2cm of m-2-1,align=right] {Counter:};
    \node[left=0.2cm of m-3-1,align=right] {Prediction:};
\end{tikzpicture}

\vspace{0.2cm}
% Br2 prediction with tabular and vertical arrows
\begin{itemize}
\item \textbf{Br2 prediction}
\end{itemize}
\begin{tikzpicture}[baseline=(current bounding box.center),every node/.style={anchor=base}]
    % Table for alignment
    \matrix[matrix of nodes,nodes={minimum width=0.5cm,anchor=center},column sep=0.4cm,row sep=0.2cm,ampersand replacement=\&] (m) {
        0 \& 1 \& 0 \& 1 \& 0 \& 1 \\
        2 \& 1 \& 2 \& 1 \& 2 \& 1 \\
        \textcolor{red}{1} \& \textcolor{mygreen}{0} \& \textcolor{red}{1} \& \textcolor{mygreen}{0} \& \textcolor{red}{1} \& \textcolor{mygreen}{0} \\
    };
    % Arrows from pattern to counter
    \foreach \i in {1,...,6} {
        \draw[->,thick] (m-1-\i.south) -- (m-2-\i.north);
        \draw[->,thick] (m-2-\i.south) -- (m-3-\i.north);
    }
    % Labels
    \node[left=0.2cm of m-1-1,align=right] {Pattern:};
    \node[left=0.2cm of m-2-1,align=right] {Counter:};
    \node[left=0.2cm of m-3-1,align=right] {Prediction:};
\end{tikzpicture}

\vspace{0.2cm}
% Br3 prediction with tabular and vertical arrows
\begin{itemize}
\item \textbf{Br3 prediction}
\end{itemize}
\begin{tikzpicture}[baseline=(current bounding box.center),every node/.style={anchor=base}]
    % Table for alignment
    \matrix[matrix of nodes,nodes={minimum width=0.5cm,anchor=center},column sep=0.4cm,row sep=0.2cm,ampersand replacement=\&] (m) {
        1 \& 1 \& 1 \& 1 \& 1 \& 0 \\
        2 \& 3 \& 3 \& 3 \& 3 \& 3 \\
        \textcolor{mygreen}{1} \& \textcolor{mygreen}{1} \& \textcolor{mygreen}{1} \& \textcolor{mygreen}{1} \& \textcolor{mygreen}{1} \& \textcolor{red}{1} \\
    };
    % Arrows from pattern to counter
    \foreach \i in {1,...,6} {
        \draw[->,thick] (m-1-\i.south) -- (m-2-\i.north);
        \draw[->,thick] (m-2-\i.south) -- (m-3-\i.north);
    }
    % Labels
    \node[left=0.2cm of m-1-1,align=right] {Pattern:};
    \node[left=0.2cm of m-2-1,align=right] {Counter:};
    \node[left=0.2cm of m-3-1,align=right] {Prediction:};
\end{tikzpicture}

\end{column}

\begin{column}{0.38\textwidth}
\vspace{1cm}
\begin{tcolorbox}[
    colback=lightblue!10,
    colframe=myblue,
    boxrule=1pt,
    arc=2mm,
    left=3mm,
    right=3mm,
    top=3mm,
    bottom=3mm,
    fontupper=\footnotesize\ttfamily
]
\textbf{\normalfont\small Code:}

\vspace{0.2cm}
int n = 6;

\vspace{0.2cm}
Loop: \hspace{0.3cm} ....

\vspace{0.2cm}
br1: if (n\%2) \{ ... \}

\vspace{0.2cm}
br2: if ((n+1)\%2) \{ ... \}

\vspace{0.3cm}
\hspace{0.5cm} n{-}{-};

\vspace{0.2cm}
br3: JNZ n, Loop
\end{tcolorbox}
\end{column}
\end{columns}

\end{frame}

% Section title - Conditional Branch Direction Prediction
\begin{frame}
\begin{center}
\vspace{2cm}
{\Huge\textcolor{myblue}{\textbf{Conditional Branch}}}

\vspace{0.3cm}

{\Huge\textcolor{myblue}{\textbf{Direction Prediction}}}
\end{center}
\end{frame}

% One-Bit Predictor
\begin{frame}
\frametitle{One-Bit Predictor}
\label{frame:one_bit_predictor}

\begin{center}
\begin{tikzpicture}[scale=0.8]
    % Draw the bit array
    \fill[lightblue] (0,0) rectangle (1,4.5);
    \draw[thick] (0,0) rectangle (1,4.5);

    % Draw array divisions
    \foreach \y in {0.5,1,1.5,2,2.5,3,3.5,4} {
        \draw (0,\y) -- (1,\y);
    }

    % Highlight one cell
    \fill[lightblue!60] (0,3.5) rectangle (1,4);

    % Labels and arrows
    \node[mygreen,anchor=east,font=\small] at (-0.3,3.75) {l.s. bits of Branch IP};
    \draw[->,thick,mygreen] (-0.1,3.75) -- (0,3.75);

    \node[mypurple,anchor=west,font=\small] at (1.3,3.75) {Prediction (at fetch):};
    \node[mypurple,anchor=west,font=\small] at (1.3,3.35) {previous branch outcome};
    \draw[->,thick,mypurple] (1,3.75) -- (1.2,3.75);

    % Curved arrow for update
    \draw[->,thick,myblue] (1.1,1.5) .. controls (2.5,1.5) and (2.5,3.3) .. (1,3.3);
    \node[myblue,align=center,anchor=west,font=\footnotesize] at (1.8,0.9) {Update bit with\\branch outcome\\(at execution)};

    % Bit Array label
    \node[myblue,font=\small\bfseries] at (0.5,-0.5) {Bit Array};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{Problem: 1-bit predictor has a double mistake in loops}
\end{itemize}

\vspace{0.1cm}

{\footnotesize
\begin{tabular}{@{}ll@{}}
Branch Outcome & \texttt{0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1} \\
Prediction & \texttt{?~0 0 0 0 \textcolor{red}{0 1} 0 0 0 0 \textcolor{red}{0 1} 0 0 0 0 0} \\
\end{tabular}
}

\end{frame}

\subsection{2-Level Branch Prediction}

\begin{frame}
\frametitle{2-Level Branch Prediction}
\label{frame:2level_prediction}

\begin{itemize}
    \item \textbf{Save branch direction history in a Branch History Register}
    \begin{itemize}
        \item A shift-register that saves the last $n$ outcomes of the branch
        \item History points to an array of $2^n$ bits
        \item Bit pointed by a history specifies the predicted branch direction following that history
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{Example: predicting the pattern 0001 0001 0001 ...}
    \begin{itemize}
        \item History length $n=3$
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{center}
% TODO: Add 2-level prediction diagram
\textcolor{red}{[PLACEHOLDER: 2-level predictor diagram showing BHR and counter array]}
\end{center}

\begin{center}
{\footnotesize
\texttt{0 0 0 | 1 0 0 0 1 0 0 0 1 ...}

\vspace{0.2cm}

\textbf{Predict at Fetch} \hspace{2cm} \textbf{Update at EXE}
}
\end{center}

\end{frame}

% Shortest History To Predict a Pattern
\begin{frame}
\frametitle{Shortest History To Predict a Pattern}
\label{frame:shortest_history}

\begin{itemize}
    \item \textbf{What is the shortest history needed to perfectly predict the pattern 10011 10011 ... in steady state?}
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{A history of length 3 predicts correctly:}
    \begin{itemize}
        \item \colorbox{lightblue!30}{100}11 10011 \hspace{0.3cm} 100 $\Rightarrow$ 1
        \item 1\colorbox{lightblue!30}{001}1 10011 \hspace{0.3cm} 001 $\Rightarrow$ 1
        \item 10\colorbox{lightblue!30}{011} 10011 \hspace{0.3cm} 011 $\Rightarrow$ 1
        \item 100\colorbox{lightblue!30}{11 1}0011 \hspace{0.3cm} 111 $\Rightarrow$ 0
        \item 10011 \colorbox{lightblue!30}{1 10}011 \hspace{0.3cm} 110 $\Rightarrow$ 0
    \end{itemize}
    \item Either no sub-pattern appears more than once, or whenever the sub-pattern appears it points to the same value
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{A history of length 2 is wrong twice per iteration}
    \begin{itemize}
        \item \colorbox{lightblue!30}{10}011 10011 \hspace{0.3cm} 10 $\Rightarrow$ 0
        \item 1\colorbox{lightblue!30}{00}11 10011 \hspace{0.3cm} 00 $\Rightarrow$ 1
        \item 10\colorbox{lightblue!30}{01}1 10011 \hspace{0.3cm} 01 $\Rightarrow$ 1
        \item 100\colorbox{lightblue!30}{11} 10011 \hspace{0.3cm} 11 $\Rightarrow$ \textcolor{red}{1}
        \item 10011 \colorbox{lightblue!30}{1 1}0011 \hspace{0.3cm} 11 $\Rightarrow$ \textcolor{red}{0}
    \end{itemize}
    \item A sub-pattern appears more than once, and it points to different values
\end{itemize}

\end{frame}

\subsection{Local History Predictors}

\begin{frame}
\frametitle{Local History Predictor}
\label{frame:local_history}

\begin{itemize}
    \item \textbf{Use 2-bit saturating counters instead of 1 bit to record outcome}
    \begin{itemize}
        \item Avoid a double mistake in case two history sub-patterns point to the same value, or in case of a pattern glitch
        \item Example: 00001 00001 00001 01001 00001 00001
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
\begin{tikzpicture}[scale=0.7]
    % BHR
    \node[draw,thick,fill=lightblue!20,minimum width=2cm,minimum height=0.7cm] (bhr) at (0,0) {history};
    \node[anchor=south,font=\small\bfseries,myblue] at (bhr.north) {BHR};

    % Counter array
    \fill[lightblue!30] (4,-1.5) rectangle (5.2,1.5);
    \draw[thick] (4,-1.5) rectangle (5.2,1.5);
    \foreach \y in {-1,-0.5,0,0.5,1} {
        \draw (4,\y) -- (5.2,\y);
    }
    \node[anchor=south,font=\small\bfseries,myblue] at (4.6,1.6) {2-bit-sat counter array};

    % Arrows
    \draw[->,very thick] (bhr.east) -- (3.8,0);
    \draw[->,very thick] (5.2,0.5) -- (6.5,0.5);
    \node[anchor=west,font=\small,mypurple] at (6.5,0.5) {prediction = msb of counter};

    % Update arrows
    \draw[->,thick,mygreen] (2,-1.5) .. controls (3,-2) and (4.5,-2) .. (4.6,-1.6);
    \node[anchor=north,font=\scriptsize,mygreen,align=center] at (3,-2.2) {Update History\\with branch outcome};

    \draw[->,thick,myorange] (6.5,-1.5) .. controls (5.5,-2) and (5,-1.8) .. (5.2,-1);
    \node[anchor=north,font=\scriptsize,myorange,align=center] at (6.5,-2.2) {Update counter with\\branch outcome\\(at execution)};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{The longer the history}
    \begin{itemize}
        \item Warm-Up is longer
        \item Counter array becomes very big (and sparse)
    \end{itemize}
\end{itemize}

\end{frame}

% Speculative History Updates - slide 1
\begin{frame}
\frametitle{Speculative History Updates}
\label{frame:speculative_history_1}

\begin{itemize}
    \item \textbf{Deep pipeline $\Rightarrow$ many cycles between fetch and branch resolution}
    \begin{itemize}
        \item If history is updated only at resolution (branch execute)
        \begin{itemize}
            \item Future occurrences of the same branch may be fetched before history is updated, and predicted with a stale history
        \end{itemize}
        \item Update history speculatively according to prediction
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
\begin{tikzpicture}[scale=0.7]
    % Speculative BHR
    \node[draw,thick,fill=lightblue!20,minimum width=2cm,minimum height=0.7cm] (sbhr) at (0,0) {history};
    \node[anchor=south,font=\small\bfseries,myblue] at (sbhr.north) {Speculative BHR};

    % Counter array
    \fill[lightblue!30] (4,-1.5) rectangle (5.2,1.5);
    \draw[thick] (4,-1.5) rectangle (5.2,1.5);
    \node[anchor=south,font=\small\bfseries,myblue] at (4.6,1.6) {2-bit-sat counter array};

    % Arrows
    \draw[->,very thick] (sbhr.east) -- (3.8,0);
    \draw[->,very thick] (5.2,0.5) -- (6.5,0.5);
    \node[anchor=west,font=\small,mypurple] at (6.5,0.5) {prediction};

    % Update with prediction
    \draw[->,thick,mygreen] (6.5,0.2) .. controls (3,0.8) and (1,0.8) .. (sbhr.north);
    \node[anchor=south,font=\scriptsize,mygreen,align=center] at (3,1.5) {Update History with prediction};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{As long as the prediction of previous branches is correct, the history used for predicting the next branch is correct as well}
\end{itemize}

\end{frame}

% Speculative History Updates - slide 2
\begin{frame}
\frametitle{Speculative History Updates}
\label{frame:speculative_history_2}

\begin{itemize}
    \item \textbf{If a branch is mispredicted}
    \begin{itemize}
        \item History continues to be updated until the bad branch gets to execution
        \item Branches following it use a wrong history for their prediction
        \begin{itemize}
            \item But this does not matter, as they will be anyhow flushed
        \end{itemize}
        \item Need to recover the branch history to its value before the bad branch
        \begin{itemize}
            \item Maintain a non-speculative copy of the history, updated at execute
            \item In case of misprediction, copy non-speculative history into speculative history
        \end{itemize}
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{center}
% TODO: Add dual BHR diagram
\textcolor{red}{[PLACEHOLDER: Diagram showing Speculative BHR and BHR with recovery mechanism]}
\end{center}

\end{frame}

% Speculative History Updates - slide 3
\begin{frame}
\frametitle{Speculative History Updates}
\label{frame:speculative_history_3}

\begin{itemize}
    \item \textbf{The counter array is not updated speculatively}
    \begin{itemize}
        \item Prediction can change only on a misprediction
        \begin{itemize}
            \item state $01\rightarrow10$ or $10\rightarrow01$
        \end{itemize}
        \item The counter array is too big to be recovered following misprediction
        \begin{itemize}
            \item Too expensive to maintain both speculative and non-speculative copies of the counter array
        \end{itemize}
    \end{itemize}
\end{itemize}

\end{frame}

% Local Predictor: private counter arrays
\begin{frame}
\frametitle{Local Predictor: Private Counter Arrays}
\label{frame:local_private}

\textbf{Holding BHRs and counter arrays for many branches:}

\vspace{0.3cm}

\begin{center}
% TODO: Add history cache with private arrays diagram
\textcolor{red}{[PLACEHOLDER: History Cache with private counter arrays diagram]}
\end{center}

\vspace{0.3cm}

Predictor size: \#BHRs $\times$ (tag\_size + history\_size + 2 $\times$ $2^{\text{history\_size}}$)

\vspace{0.2cm}

Example: \#BHRs = 1024; tag\_size=8; history\_size=6 $\Rightarrow$

size=1024 $\times$ (8 + 6 + 2$\times$$2^6$) = 142Kbit

\end{frame}

% Local Predictor: shared counter arrays
\begin{frame}
\frametitle{Local Predictor: Shared Counter Arrays}
\label{frame:local_shared}

\begin{itemize}
    \item \textbf{Using a single counter array shared by all BHR's}
    \begin{itemize}
        \item All BHR's index the same array
        \item Branches with similar patterns interfere with each other
        \begin{itemize}
            \item Interference can be either constructive or destructive
        \end{itemize}
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
% TODO: Add shared counter array diagram
\textcolor{red}{[PLACEHOLDER: History Cache with shared counter array diagram]}
\end{center}

\vspace{0.3cm}

Predictor size: \#BHRs $\times$ (tag\_size + history\_size) + 2 $\times$ $2^{\text{history\_size}}$

Example: \#BHRs = 1024; tag\_size=8; history\_size=6 $\Rightarrow$ size=1024 $\times$ (8 + 6) + 2$\times$$2^6$ = 14.1Kbit

\end{frame}

% Local Predictor: Lselect
\begin{frame}
\frametitle{Local Predictor: \textit{Lselect}}
\label{frame:lselect}

\begin{itemize}
    \item \textbf{\textit{Lselect} reduces inter-branch-interference in the counter array}
    \begin{itemize}
        \item The counter array index is a concatenation of the jump history and $m$ l.s.bits of the jump IP
        \item Counter array size becomes $2^m$ times bigger
        \item All Branches with the same $m$ IP l.s.bits interfere with each other
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
% TODO: Add Lselect diagram
\textcolor{red}{[PLACEHOLDER: Lselect predictor diagram with IP concatenation]}
\end{center}

\vspace{0.3cm}

Predictor size: \#BHRs $\times$ (tag\_size + history\_size) + 2 $\times$ $2^{\text{history\_size} + m}$

\end{frame}

% Local Predictor: Lshare
\begin{frame}
\frametitle{Local Predictor: \textit{Lshare}}
\label{frame:lshare}

\textbf{\textit{Lshare} reduces inter-branch-interference in the counter array:}

maps common patterns in different branches to different counters

\vspace{0.3cm}

\begin{center}
% TODO: Add Lshare diagram with XOR
\textcolor{red}{[PLACEHOLDER: Lshare predictor diagram with XOR hashing]}
\end{center}

\vspace{0.3cm}

Predictor size: \#BHRs $\times$ (tag\_size + history\_size) + 2 $\times$ $2^{\text{history\_size}}$

\end{frame}

\subsection{Global History Predictors}

\begin{frame}
\frametitle{Global Predictor}
\label{frame:global_predictor}

\begin{itemize}
    \item \textbf{The behavior of some branches is highly correlated}
\end{itemize}

\vspace{0.2cm}

\begin{center}
\texttt{if (x < 1) ...}

\texttt{if (x > 1) ...}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{Using a single Global History Register (\textit{GHR}) for all branches}
    \begin{itemize}
        \item The prediction of the 2$^{nd}$ \textit{if} is influenced by the direction of the 1$^{st}$ \textit{if}
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
\begin{tikzpicture}[scale=0.7]
    % GHR
    \node[draw,thick,fill=lightblue!20,minimum width=2cm,minimum height=0.7cm] (ghr) at (0,0) {history};
    \node[anchor=south,font=\small\bfseries,myblue] at (ghr.north) {GHR};

    % Counter array
    \fill[lightblue!30] (4,-1.5) rectangle (5.2,1.5);
    \draw[thick] (4,-1.5) rectangle (5.2,1.5);
    \node[anchor=south,font=\small\bfseries,myblue] at (4.6,1.6) {2-bit-sat counter array};

    % Arrows
    \draw[->,very thick] (ghr.east) -- (3.8,0);
    \draw[->,very thick] (5.2,0.5) -- (6.5,0.5);
    \node[anchor=west,font=\small,mypurple] at (6.5,0.5) {prediction = msb of counter};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{History interference between non-correlated might hurt prediction}
    \item \textbf{With only a single history, can afford a long history}
    \begin{itemize}
        \item The predictor size: history\_size + 2$\times$$2^{\text{history\_size}}$
    \end{itemize}
\end{itemize}

\end{frame}

% Global Predictor: Gshare
\begin{frame}
\frametitle{Global Predictor: \textit{Gshare}}
\label{frame:gshare}

\begin{itemize}
    \item \textbf{\textit{Gshare} combines global history information with the branch IP}
\end{itemize}

\vspace{0.3cm}

\begin{center}
\begin{tikzpicture}[scale=0.7]
    % GHR
    \node[draw,thick,fill=lightblue!20,minimum width=2cm,minimum height=0.7cm] (ghr) at (0,1) {history};
    \node[anchor=south,font=\small\bfseries,myblue] at (ghr.north) {GHR};

    % Branch IP
    \node[anchor=east,font=\small,myblue] at (-0.5,-0.5) {Branch IP};

    % XOR
    \node[draw,circle,minimum size=0.8cm] (xor) at (3,0) {$\oplus$};

    % Counter array
    \fill[lightblue!30] (5.5,-1.5) rectangle (6.7,1.5);
    \draw[thick] (5.5,-1.5) rectangle (6.7,1.5);
    \node[anchor=south,font=\small\bfseries,myblue] at (6.1,1.6) {2-bit-sat counter array};

    % Arrows
    \draw[->,thick] (ghr.east) -- (xor.west);
    \draw[->,thick] (0,-0.5) -- (xor.south);
    \draw[->,very thick] (xor.east) -- (5.3,0);
    \draw[->,very thick] (6.7,0.5) -- (8,0.5);
    \node[anchor=west,font=\small,mypurple] at (8,0.5) {prediction = msb of counter};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{The counter accessed is a function of the global history and of the specific branch being predicted / updated:}
    \begin{itemize}
        \item Following this history, for this specific branch, the branch is taken/NT
    \end{itemize}
    \item \textbf{This turns to be extremely accurate and space-efficient}
\end{itemize}

\end{frame}

% Why Gshare Works So Well
\begin{frame}
\frametitle{Why \textit{Gshare} Works So Well}
\label{frame:why_gshare}

\begin{itemize}
    \item \textbf{Updating a single history with all branches' outcomes might look like a mess, but ...}
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{The numbers of branches active in the program at a given moment is usually small}
    \begin{itemize}
        \item E.g., in case of short loop with no if statements in the loop body
        \begin{itemize}
            \item There is only one branch in the loop (the loop's branch)
            \item Gshare behaves just like local history
        \end{itemize}
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{Assume 2 branches are active simultaneously: A and B}
    \begin{itemize}
        \item Some of the bits in the GHR are for A, and some for B
        \item Due to the XOR with their IP's, A and B update different counters
    \end{itemize}
\end{itemize}

\end{frame}

% Chooser
\begin{frame}
\frametitle{Chooser}
\label{frame:chooser}

\begin{center}
\begin{tikzpicture}[
    box/.style={draw=black!80, line width=1pt, minimum height=1cm, minimum width=2.5cm, fill=lightblue!15, rounded corners=2pt, font=\small},
    arrow/.style={-latex, thick, draw=black!70},
    data_connector/.style={circle, fill=black, inner sep=1.2pt}
]

    % MUX using circuitikz muxdemux
    \node[muxdemux, muxdemux def={Lh=4, Rh=2, NL=2, NB=1, w=2},
          external pins width=0, fill=yellow!20, anchor=lpin 2] (mux) {};

    % Bimodal or Local box
    \node[box, align=center, left=0.8cm of mux.lpin 1, anchor=east] (bimodal) {Bimodal\\or Local};

    % Branch IP input
    \node[font=\normalsize, text=myblue, left=1cm of bimodal.west] (branch_ip) {Branch IP};

    % Connector for Branch IP
    \node[data_connector, right=0.6cm of branch_ip.east] (conn) {};

    % Global box
    \node[box, left=0.8cm of mux.lpin 2] (global) {Global};

    % Chooser array - drawn with loop and dashed lines, closer to global
    \coordinate (array_start) at ([yshift=-0.3cm]global.south);

    % Draw array box outline - smaller
    \draw[draw=black!80, line width=1pt, fill=lightblue!8]
      ([xshift=-0.4cm]array_start) rectangle ++(0.8cm, -1.9cm)
      node[pos=0.5] (chooser_center) {};

    % Draw dashed lines to show array elements - aligned properly
    \foreach \i in {1,2,3,4} {
      \draw[dashed, black!40] ([xshift=-0.4cm, yshift=-\i*0.38cm]array_start) -- ++(0.8cm, 0);
    }

    % Highlight one element in the middle - aligned with dashed lines
    \draw[draw=myorange, line width=1.5pt, fill=myorange!20]
      ([xshift=-0.38cm, yshift=-1.14cm]array_start) rectangle ++(0.76cm, -0.36cm)
      coordinate[pos=1] (highlight_se);

    % Label for chooser array - BELOW the array
    \node[below=0.8cm of chooser_center.south, font=\scriptsize, text=black, align=center, anchor=north]
      {Chooser Array\\[-1pt]\tiny (2-bit sat. counters)};

    % Store chooser position for connections
    \coordinate (chooser_west) at ([xshift=-0.4cm, yshift=-1.32cm]array_start);
    \coordinate (chooser_east) at ([xshift=0.4cm, yshift=-1.32cm]array_start);

    % Label for MUX
    \node at (mux.center) [font=\small] {MUX};

    % Prediction output
    \node[right=1cm of mux.rpin 1, font=\normalsize, text=myblue] (prediction) {Prediction};

    % Arrows - Branch IP to all three components
    \draw[thick, draw=black!70] (branch_ip) -- (conn);
    \draw[arrow] (conn) |- (bimodal.west);
    \node[data_connector] (conn2) at (conn |- global.west) {};
    \draw[thick, draw=black!70] (conn) -- (conn2);
    \draw[arrow] (conn2) -- (global.west);
    \draw[arrow] (conn) |- (chooser_west);

    % Arrows - from predictors to MUX
    \draw[arrow] (bimodal.east) -- ++(0.3, 0) |- (mux.lpin 1);
    \draw[arrow] (global.east) -- ++(0.3, 0) |- (mux.lpin 2);

    % Arrow - Chooser to MUX control (bottom pin)
    \draw[arrow] (chooser_east) -| (mux.bpin 1);

    % Arrow - MUX to Prediction
    \draw[arrow] (mux.rpin 1) -- (prediction);

    % Add update explanation right below the highlighted box
    \node[anchor=north west, font=\scriptsize, text=black!70, align=left] (update_text)
      at ([xshift=1cm, yshift=-0.3cm]highlight_se) {
      Update: +1 if Bimodal/Local correct\\
      \phantom{Update: }-1 if Global correct
    };

    % Arrow from text to highlighted box
    \draw[-latex, draw=black!50, thin] (update_text.north west) -- (highlight_se);

\end{tikzpicture}
\end{center}

\vspace{-0.1cm}

\begin{itemize}
    \item \textbf{Chooser selects between two predictors}
    \begin{itemize}
        \item Array of 2-bit saturating counters indexed by \textcolor{myblue}{Branch IP}
        \item Each counter tracks which predictor performs better for that branch
        \item MUX selects the prediction from the better predictor
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{itemize}
    \item \textbf{Counter update policy (at execution):}
    \begin{itemize}
        \item \textcolor{mygreen}{Increment}: if Bimodal/Local correct \textit{and} Global wrong
        \item \textcolor{red}{Decrement}: if Global correct \textit{and} Bimodal/Local wrong
        \item No change if both correct or both wrong
    \end{itemize}
\end{itemize}

\end{frame}

\section{Indirect Branch Target Prediction}

\begin{frame}
\frametitle{Indirect Branch Target Prediction}
\label{frame:indirect_target_1}

\begin{itemize}
    \item \textbf{Indirect branch targets: target given in a register}
    \begin{itemize}
        \item Can have many targets: e.g., a case statement
        \item Resolved at execution $\Rightarrow$ high misprediction penalty
        \item Used in object-oriented code (C++, Java)
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{A history-based indirect branch target predictor}
    \begin{itemize}
        \item Uses the same global history used for conditional jumps
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
\begin{tikzpicture}[scale=0.7]
    % GHR
    \node[draw,thick,fill=lightblue!20,minimum width=2cm,minimum height=0.7cm] (ghr) at (0,1) {history};
    \node[anchor=south,font=\small\bfseries,myblue] at (ghr.north) {GHR};

    % Branch IP
    \node[anchor=east,font=\small,myblue] at (-0.5,-0.5) {Branch IP};

    % XOR
    \node[draw,circle,minimum size=0.8cm] (xor) at (3,0) {$\oplus$};

    % iTA
    \fill[lightblue!30] (5.5,-1) rectangle (7.5,1);
    \draw[thick] (5.5,-1) rectangle (7.5,1);
    \node[anchor=south,font=\small\bfseries,myblue] at (6.5,1.1) {Indirect Target Array};

    % Arrows
    \draw[->,thick] (ghr.east) -- (xor.west);
    \draw[->,thick] (0,-0.5) -- (xor.south);
    \draw[->,very thick] (xor.east) -- (5.3,0);
    \draw[->,very thick] (7.5,0) -- (8.5,0);
    \node[anchor=west,font=\small,mypurple] at (8.5,0) {Predicted Target};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item Each Jump takes multiple entries $\Rightarrow$ more expensive than TA $\Rightarrow$ should only be used for jumps with multiple targets
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Indirect Target Array (iTA) Allocation}
\label{frame:indirect_target_2}

\begin{itemize}
    \item \textbf{Initially allocate indirect branch only in the Target Array (TA)}
    \begin{itemize}
        \item Many indirect branches have only one target
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{itemize}
    \item \textbf{If the TA mis-predicts for an indirect jump}
    \begin{itemize}
        \item Allocate an iTA entry with the current target
        \item Indexed by IP $\oplus$ Global History
    \end{itemize}
\end{itemize}

\vspace{0.2cm}

\begin{itemize}
    \item \textbf{Prediction from the iTA is used if}
    \begin{itemize}
        \item TA indicates an indirect jump and iTA hits
    \end{itemize}
\end{itemize}

\vspace{0.1cm}

\begin{center}
\begin{tikzpicture}[scale=0.9,
    arrow/.style={-latex, thick, draw=black!70},
    signal/.style={font=\scriptsize},
    data_connector/.style={circle, fill=black, inner sep=1.2pt}
]

    % Branch IP input (anchor point)
    \node[font=\normalsize, text=myblue] (branch_ip) at (0,0) {Branch IP};

    % Connector for Branch IP
    \node[data_connector, right=1.2cm of branch_ip] (conn_ip) {};

    % Target Array as muxdemux - wider and shorter (Lh=Rh, slightly wider)
    \node[muxdemux, muxdemux def={Lh=2, Rh=2, NL=1, NR=5, w=4.5},
          external pins width=0, fill=green!20, anchor=lpin 1, right=1.5cm of conn_ip, align=center,
          font=\small] (ta) {Target Array};

    % Main MUX for output selection - now with top pin, positioned lower
    \node[muxdemux, muxdemux def={Lh=2, Rh=1, NL=2, NB=0, NR=1, w=1.8, NT=1},
          external pins width=0, fill=yellow!20, xshift=3cm, yshift=-1cm] (mux) at (ta.east) {MUX};

    % Indirect Target Predictor - wider and shorter, positioned using |- relative to TA and MUX
    \node[muxdemux, muxdemux def={Lh=2, Rh=2, NL=1, NR=3, w=4.5},
          external pins width=0, fill=green!20, anchor=rpin 2, align=center, font=\small] (itp) at (ta.east |- mux.lpin 2) {Indirect Target\\Predictor};

    % XOR gate positioned using |- with conn_ip x-axis and itp y-axis
    \node[circle, draw=black!80, line width=1pt, minimum size=0.7cm, fill=white] (xor) at (conn_ip |- itp.lpin 1) {$\oplus$};

    % Global history input - positioned using |- with branch_ip.east x-axis and xor y-axis, anchored east
    \node[font=\normalsize, text=myblue, anchor=east, align=center] (ghr) at (branch_ip.east |- xor) {Global\\history};

    % AND gate rotated 90 degrees - smaller, anchored at output pin above MUX top pin
    \node[and port, rotate=-90, xscale=0.2, yscale=0.6, anchor=out, external pins width=0,
          logic gate input sep=0pt] at ([yshift=3mm]mux.tpin 1) (and_gate) {};

    % Output
    \node[font=\normalsize, text=mypurple, right=2cm of mux.rpin 1, align=center] (pred_target) {Predicted\\Target};

    % HIT output from TA - positioned at intersection of ta.rpin 1 y-coordinate and pred_target.west x-coordinate
    \coordinate (hit_pos) at (pred_target.west |- ta.rpin 1);
    \node[font=\normalsize, text=black, anchor=west] (hit_out) at (hit_pos) {HIT};

    % Draw connections
    % Branch IP to connector
    \draw[thick, draw=black!70] (branch_ip) -- (conn_ip);

    % Branch IP to Target Array
    \draw[arrow] (conn_ip) -- (ta.lpin 1);

    % Branch IP to XOR gate - goes to xor.north
    \draw[arrow] (conn_ip) -- (xor.north);

    % Global history to XOR gate
    \draw[arrow] (ghr) -- (xor.west);

    % XOR to Indirect Target Predictor
    \draw[arrow] (xor.east) -- (itp.lpin 1);

    % Target Array outputs (3 rpins: rpin 1 = TA hit, rpin 2 = type=indirect, rpin 3 = target)
    % rpin 1: TA hit to HIT
    \draw[arrow] (ta.rpin 1) -- (hit_out.west) node[signal, pos=0.15, above] {TA hit};

    % rpin 2: type = indirect to AND gate input 1
    \draw[arrow] (ta.rpin 2) -| (and_gate.bin 2) node[signal, pos=0.25, below, yshift=1mm] {type = indirect};

    % rpin 3: Target to MUX lpin 1
    \draw[arrow] (ta.rpin 5) -- ++(1,0) coordinate (ta_target_corner) |- (mux.lpin 1) node[signal, pos=0.25, above] {Target};

    % Indirect Target Predictor outputs (3 rpins: rpin 1 = Target, rpin 2 = iTA hit, rpin 3 unused)
    % rpin 1: Target to MUX lpin 2
    \draw[arrow] (itp.rpin 2) -- ++(1,0) coordinate (itp_target_corner) |- (mux.lpin 2) node[signal, pos=0.25, above] {Target};

    % rpin 2: iTA hit to AND gate input 2 with complex routing
    \draw[arrow] (itp.rpin 3) -| ([xshift=1cm]mux.east) |- ([xshift=1cm,yshift=5mm]and_gate.east) -| (and_gate.bin 1) node[signal, pos=0.05, below] {iTA hit};

    % AND gate output to MUX top pin
    \draw[arrow] (and_gate.out) -- (mux.tpin 1);

    % MUX to Predicted Target
    \draw[arrow] (mux.rpin 1) -- (pred_target.west);

\end{tikzpicture}
\end{center}

\end{frame}

% Return Stack Buffer
\begin{frame}
\frametitle{Return Stack Buffer}
\label{frame:rsb}

\begin{itemize}
    \item \textbf{A return instruction is a special case of an indirect branch}
    \begin{itemize}
        \item Each times it jumps to a different target
        \item The target is determined by the location of the corresponding Call instruction
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{Maintain a small stack of targets at fetch time}
    \begin{itemize}
        \item When the Target Array predicts a Call
        \begin{itemize}
            \item Push the address of the instruction which follows the Call into the stack (this is the predicted Return address)
        \end{itemize}
        \item When the Target Array predicts a Return
        \begin{itemize}
            \item Pop a target from the stack and use it as the Return address
        \end{itemize}
    \end{itemize}
\end{itemize}

\end{frame}

% RSB Operation Illustration
\begin{frame}
\frametitle{Return Stack Buffer Operation}
\label{frame:rsb_operation}

% Define colors for each function
\definecolor{mainfill}{RGB}{200,230,200}
\definecolor{func1fill}{RGB}{255,220,220}
\definecolor{func2fill}{RGB}{220,220,255}

\begin{center}
\begin{tikzpicture}[scale=0.85,
    remember picture,
    codebox/.style={draw=black!80, line width=1pt, minimum width=3cm, minimum height=1.2cm, font=\footnotesize\ttfamily, text width=2.8cm, align=left},
    arrow/.style={-latex, thick, draw=black!70},
    label/.style={font=\scriptsize, text=black}
]

    % Code boxes on the left
    \node[codebox, fill=mainfill] (main) at (0,0) {main:\\~~...\\~~call~~func1\tikzmark{call1}\\~~...\\~~ret};
    \node[codebox, fill=func1fill, below=0.5cm of main] (func1) {func1:\\~~...\\~~call~~func2\tikzmark{call2}\\~~...\\~~ret};
    \node[codebox, fill=func2fill, below=0.5cm of func1] (func2) {func2:\\~~...\\~~ret\tikzmark{ret2}};

    % Stack on the right using matrix
    \node[label, right=5cm of main.north east, anchor=south] (stack_label) {Stack};

    \matrix[matrix of nodes, below=-0.05cm of stack_label, anchor=north,
            nodes={draw=black!80, line width=0.5pt, minimum width=2.5cm, minimum height=0.5cm,
                   font=\scriptsize, anchor=center},
            row sep=0pt, column sep=0pt] (stack_matrix) {
        |[fill=func2fill]| ... \\
        |[fill=func2fill]| retaddr2 \\
        |[fill=func2fill]| Arguments \\
        |[fill=func1fill]| ... \\
        |[fill=func1fill]| retaddr1 \\
        |[fill=func1fill]| Arguments \\
        |[fill=mainfill]| ... \\
    };

    % Frame braces and labels
    \draw[thick, decoration={brace, amplitude=5pt}, decorate]
        ([xshift=0.25cm]stack_matrix-1-1.north east) -- ([xshift=0.25cm]stack_matrix-3-1.south east)
        node[midway, right=0.15cm, font=\tiny, align=left] {Frame\\of func2};

    \draw[thick, decoration={brace, amplitude=5pt}, decorate]
        ([xshift=0.25cm]stack_matrix-4-1.north east) -- ([xshift=0.25cm]stack_matrix-6-1.south east)
        node[midway, right=0.15cm, font=\tiny, align=left] {Frame\\of func1};

    % RSB below the stack using matrix
    \node[label, below=0.5cm of stack_matrix, anchor=north] (rsb_label) {RSB};

    \matrix[matrix of nodes, below=-0.05cm of rsb_label, anchor=north,
            nodes={draw=black!80, line width=0.5pt, minimum width=2.5cm, minimum height=0.5cm,
                   font=\scriptsize, anchor=center},
            row sep=0pt, column sep=0pt] (rsb_matrix) {
        |[fill=func2fill]| retaddr2 \\
        |[fill=func1fill]| retaddr1 \\
        |[fill=green!15]| ... \\
    };

    % Arrows showing the flow
    % Arrow 1: Load from stack - from ret instruction in func2
    \draw[arrow] ([xshift=0.1cm]pic cs:ret2) -- ++(3,0) coordinate (mid1) |- (stack_matrix-2-1.west);
    \node[label, above right, align=center] at (mid1) {(1) Load\\from\\stack};

    % Arrow 2: Consult for prediction - from ret instruction in func2
    \draw[arrow] ([xshift=0.1cm]pic cs:ret2) -- ++(3,0) coordinate (mid2) |- (rsb_matrix-1-1.west);
    \node[label, below, align=center] at ([yshift=-0.3cm]mid2) {(2) Consult\\for prediction};

\end{tikzpicture}
\end{center}

% Labels for return addresses aligned with tikzmarks
\begin{tikzpicture}[remember picture, overlay]
    \node[font=\scriptsize, text=black, fill=func1fill, inner sep=2pt] at ([xshift=-3.2cm, yshift=-0.15cm]pic cs:call1) {retaddr1};
    \node[font=\scriptsize, text=black, fill=func2fill, inner sep=2pt] at ([xshift=-3.2cm, yshift=-0.15cm]pic cs:call2) {retaddr2};
\end{tikzpicture}

\vspace{0.3cm}

\begin{itemize}
    \item \textbf{At return: processor loads from stack (slow) while consulting RSB for prediction (fast)}
\end{itemize}

\end{frame}

\section{Real-World Implementations}

\begin{frame}
\frametitle{Intel 486, Pentium\textsuperscript{\textregistered}, Pentium\textsuperscript{\textregistered} II}
\label{frame:intel_predictors}

\begin{itemize}
    \item \textbf{486} \hspace{1cm} Statically predict Not Taken
    \item \textbf{Pentium\textsuperscript{\textregistered}} \hspace{1cm} 2-bit saturating counters
    \item \textbf{Pentium\textsuperscript{\textregistered} II}
    \begin{itemize}
        \item 2-level, local histories, per-set counters
        \item 4-way set associative: 512 entries in 128 sets
    \end{itemize}
\end{itemize}

\vspace{0.3cm}

\begin{center}
% TODO: Add Pentium II predictor diagram
\textcolor{red}{[PLACEHOLDER: Pentium II predictor structure diagram]}
\end{center}

\end{frame}

% Alpha 264 - LG Chooser
\begin{frame}
\frametitle{Alpha 21264: Local-Global Chooser}
\label{frame:alpha_264}

\begin{center}
% TODO: Add Alpha 264 predictor diagram
\textcolor{red}{[PLACEHOLDER: Alpha 264 LG Chooser architecture diagram]}
\end{center}

\vspace{0.3cm}

\begin{itemize}
    \item New entry on the Local stage is allocated on a global stage mis-prediction
    \item Chooser state-machines: 2 bit each:
    \begin{itemize}
        \item one bit saves last time global correct/wrong
        \item and the other bit saves for the local correct/wrong
    \end{itemize}
    \item Chooses Local only if local was correct and global was wrong
\end{itemize}

\end{frame}


\end{document}