\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, fit, decorations.pathreplacing, matrix}
\usepackage{tcolorbox}
\usepackage{array}
\usepackage{listings}
\usepackage{pgfkeys}
\usepackage{adjustbox}
\usepackage[normalem]{ulem}
\usetheme{Madrid}
\usecolortheme{default}

% Custom colors
\definecolor{mygreen}{RGB}{0,150,0}
\definecolor{myblue}{RGB}{0,100,200}
\definecolor{myred}{RGB}{200,0,0}
\definecolor{mygray}{RGB}{100,100,100}

% Additional colors for bit field diagrams
\definecolor{fieldpurple}{RGB}{200,180,255}
\definecolor{fieldblue}{RGB}{180,220,255}
\definecolor{fieldgreen}{RGB}{180,255,180}
\definecolor{fieldyellow}{RGB}{255,255,180}
\definecolor{fieldorange}{RGB}{255,220,180}
\definecolor{fieldpink}{RGB}{255,200,230}
\definecolor{fieldgray}{RGB}{220,220,220}
\definecolor{fieldcyan}{RGB}{180,255,255}
\definecolor{fieldred}{RGB}{255,180,180}

% Macro for creating bit field diagrams  
\newcommand{\drawbitfield}[2]{
  % #1: total bits (e.g., 64)
  % #2: comma-separated list of field specifications
  \begin{tikzpicture}[
    scale=0.8,
    cell/.style={rectangle, draw=black, thick, minimum height=0.8cm, font=\tiny},
    label/.style={font=\scriptsize},
    arrow/.style={->, >=stealth, thick}
  ]
    % Total width calculation
    \pgfmathsetmacro{\bitwidth}{0.25}
    \pgfmathsetmacro{\totalwidth}{#1*\bitwidth}
    
    % Draw main border first
    \draw[very thick] (0, 0) rectangle (\totalwidth, 0.8);
    
    % Process each field
    \foreach \spec in {#2} {
      % Parse the specification
      \pgfkeys{/bitfield/.cd, default, \spec}
      \pgfmathtruncatemacro{\startbit}{\fieldstartbit}
      \pgfmathtruncatemacro{\endbit}{\fieldendbit}
      
      % Calculate positions
      \pgfmathsetmacro{\startx}{\startbit*\bitwidth}
      \pgfmathsetmacro{\endx}{(\endbit+1)*\bitwidth}
      \pgfmathsetmacro{\fieldwidth}{\endx-\startx}
      \pgfmathsetmacro{\centerx}{(\startx+\endx)/2}
      
      % Draw field box with color
      \fill[\fieldcolor!30] (\startx, 0) rectangle (\endx, 0.8);
      \draw[thick] (\startx, 0) -- (\startx, 0.8);
      \ifnum\endbit<#1
        \ifnum\endbit<63
          \draw[thick] (\endx, 0) -- (\endx, 0.8);
        \fi
      \fi
      
      % Add field text
      \node[font=\tiny] at (\centerx, 0.4) {\fieldshortname};
      
      % Add bit numbers below
      \ifnum\startbit=\endbit
        \node[below, label] at (\centerx, 0) {\startbit};
      \else
        \node[below, label] at (\startx, 0) {\startbit};
        \node[below, label] at (\endx, 0) {\endbit};
      \fi
      
      % Add long description with arrow if not empty
      \def\emptystring{}
      \ifx\fieldlongname\emptystring\else
        % Calculate label position (stagger heights)
        \pgfmathsetmacro{\labely}{1.2 + 0.4*mod(\startbit/5, 4)}
        \node[above, align=center, label, text=\fieldcolor!70!black] 
              (label-\startbit) at (\centerx, \labely) {\fieldlongname};
        \draw[arrow, \fieldcolor!60!black] (label-\startbit.south) -- (\centerx, 0.8);
      \fi
    }
    
    % Add overall bit range labels
    \node[below, label] at (0, -0.5) {0};
    \pgfmathtruncatemacro{\maxbit}{#1-1}
    \node[below, label] at (\totalwidth, -0.5) {\maxbit};
  \end{tikzpicture}
}

% pgfkeys for field specifications
\pgfkeys{
  /bitfield/.is family, /bitfield,
  default/.style = {
    startbit = 0,
    endbit = 0,
    shortname = {},
    longname = {},
    color = fieldgray
  },
  startbit/.estore in = \fieldstartbit,
  endbit/.estore in = \fieldendbit,
  shortname/.estore in = \fieldshortname,
  longname/.estore in = \fieldlongname,
  color/.estore in = \fieldcolor
}

\title{x86 Virtual Memory and TLB}
\author{Computer Architecture 234267}
\date{2025, Recitation \#11}



\begin{document}

\begin{frame}
\titlepage
\end{frame}

% Slide 2: X86 Paging Introduction
\begin{frame}{X86 Paging}
\begin{itemize}
    \item For 32-bit addressing with 4KB page size, a full page table would require 4MB
    \item Most processes use only a small amount of memory
    \item The overhead of 4MB per process is expensive and unnecessary
    \item In X86, there are multiple levels of translation tables organized in a tree structure
    \item We allocate translation tables dynamically, only when actually needed
\end{itemize}
\end{frame}

% Slide 3: 32-bit Mode Page Mapping
\begin{frame}{32-bit Mode: 4KB / 4MB Page Mapping}
\begin{itemize}
    \item 2-level hierarchical mapping: Page Directories and Page Tables
    \item 4KB aligned pages
    \item PDE (Page Directory Entry) contains:
    \begin{itemize}
        \item Present bit (0 = page fault)
        \item Page size (4KB or 4MB)
        \item CR4.PSE=1 $\Rightarrow$ both 4MB \& 4KB pages supported
        \item Separate TLBs for different page sizes
    \end{itemize}
\end{itemize}

\vspace{1em}
Linear Address Space breakdown:
\begin{itemize}
    \item 4KB Page: DIR[31:22] | TABLE[21:12] | OFFSET[11:0]
    \item 4MB Page: DIR[31:22] | OFFSET[21:0]
\end{itemize}
\end{frame}

% Slide 4: PDE and PTE Format
\begin{frame}{32-bit Mode: PDE and PTE Format}
\centering
\textbf{Page Directory Entry (4KB page table)}\\[0.5em]
\begin{tikzpicture}[scale=0.9]
    % PDE structure
    \draw[thick] (0,0) rectangle (12,0.6);
    \foreach \x/\txt in {0/0,1/1,2/2,3/3,4/4,5/5,6/6,7/7,8/8,11/{11-9},12/{31-12}} {
        \draw (\x,0) -- (\x,0.6);
        \node[below] at (\x-0.5,-0.1) {\tiny \txt};
    }
    \node at (6,0.3) {\tiny Page Frame Address 31:12};
    \node at (10.5,0.3) {\tiny AVAIL};
    \node at (9.5,0.3) {\tiny G};
    \node at (8.5,0.3) {\tiny 0};
    \node at (7.5,0.3) {\tiny A};
    \node at (6.5,0.3) {\tiny PCD};
    \node at (5.5,0.3) {\tiny PWT};
    \node at (4.5,0.3) {\tiny U};
    \node at (3.5,0.3) {\tiny W};
    \node at (0.5,0.3) {\tiny P};
\end{tikzpicture}

\vspace{1em}
\textbf{Page Table Entry}\\[0.5em]
\begin{tikzpicture}[scale=0.9]
    % PTE structure
    \draw[thick] (0,0) rectangle (12,0.6);
    \foreach \x/\txt in {0/0,1/1,2/2,3/3,4/4,5/5,6/6,7/7,8/8,11/{11-9},12/{31-12}} {
        \draw (\x,0) -- (\x,0.6);
        \node[below] at (\x-0.5,-0.1) {\tiny \txt};
    }
    \node at (6,0.3) {\tiny Page Frame Address 31:12};
    \node at (10.5,0.3) {\tiny AVAIL};
    \node at (9.5,0.3) {\tiny G};
    \node at (8.5,0.3) {\tiny PAT};
    \node at (7.5,0.3) {\tiny D};
    \node at (6.5,0.3) {\tiny A};
    \node at (5.5,0.3) {\tiny PCD};
    \node at (4.5,0.3) {\tiny PWT};
    \node at (3.5,0.3) {\tiny U};
    \node at (2.5,0.3) {\tiny W};
    \node at (0.5,0.3) {\tiny P};
\end{tikzpicture}

\vspace{1em}
\small
Key: P=Present, W=Writable, U=User/Supervisor, PWT=Write-Through,\\
PCD=Cache Disable, A=Accessed, D=Dirty, G=Global, PAT=Page Attribute Table
\end{frame}

% Slide 5: Intel 64-bit PTE Format  
\begin{frame}{Intel 64-bit Page Table Entry (PTE)}
\centering
\textbf{64-bit Mode PTE Format}\\[1em]

\begin{tikzpicture}[scale=0.18, font=\tiny]
  % Define constants
  \def\boxheight{3}
  \def\bitwidth{1}
  
  % Draw outer border
  \draw[very thick] (0,0) rectangle (64,\boxheight);
  
  % Individual bit fields - manually define each
  % P bit (0)
  \fill[fieldblue!30] (0,0) rectangle (1,\boxheight);
  \draw[thick] (1,0) -- (1,\boxheight);
  \node at (0.5,1.5) {P};
  \node[below] at (0.5,-0.3) {0};
  
  % W bit (1)
  \fill[fieldgreen!30] (1,0) rectangle (2,\boxheight);
  \draw[thick] (2,0) -- (2,\boxheight);
  \node at (1.5,1.5) {W};
  \node[below] at (1.5,-0.3) {1};
  
  % U/S bit (2)
  \fill[fieldyellow!30] (2,0) rectangle (3,\boxheight);
  \draw[thick] (3,0) -- (3,\boxheight);
  \node at (2.5,1.5) {U/S};
  \node[below] at (2.5,-0.3) {2};
  
  % PWT bit (3)
  \fill[fieldorange!30] (3,0) rectangle (4,\boxheight);
  \draw[thick] (4,0) -- (4,\boxheight);
  \node at (3.5,1.5) {PWT};
  \node[below] at (3.5,-0.3) {3};
  
  % PCD bit (4)
  \fill[fieldorange!30] (4,0) rectangle (5,\boxheight);
  \draw[thick] (5,0) -- (5,\boxheight);
  \node at (4.5,1.5) {PCD};
  \node[below] at (4.5,-0.3) {4};
  
  % A bit (5)
  \fill[fieldcyan!30] (5,0) rectangle (6,\boxheight);
  \draw[thick] (6,0) -- (6,\boxheight);
  \node at (5.5,1.5) {A};
  \node[below] at (5.5,-0.3) {5};
  
  % D bit (6)
  \fill[fieldcyan!30] (6,0) rectangle (7,\boxheight);
  \draw[thick] (7,0) -- (7,\boxheight);
  \node at (6.5,1.5) {D};
  \node[below] at (6.5,-0.3) {6};
  
  % PAT bit (7)
  \fill[fieldpink!30] (7,0) rectangle (8,\boxheight);
  \draw[thick] (8,0) -- (8,\boxheight);
  \node at (7.5,1.5) {PAT};
  \node[below] at (7.5,-0.3) {7};
  
  % G bit (8)
  \fill[fieldpink!30] (8,0) rectangle (9,\boxheight);
  \draw[thick] (9,0) -- (9,\boxheight);
  \node at (8.5,1.5) {G};
  \node[below] at (8.5,-0.3) {8};
  
  % AVL bits (9-11)
  \fill[fieldgray!30] (9,0) rectangle (12,\boxheight);
  \draw[thick] (12,0) -- (12,\boxheight);
  \node at (10.5,1.5) {AVL};
  \node[below] at (9,-0.3) {9};
  \node[below] at (12,-0.3) {11};
  
  % Page Frame Address (12-51)
  \fill[fieldpurple!30] (12,0) rectangle (52,\boxheight);
  \draw[thick] (52,0) -- (52,\boxheight);
  \node at (32,1.5) {Page Frame Address};
  \node[below] at (12,-0.3) {12};
  \node[below] at (52,-0.3) {51};
  
  % Available bits (52-58)
  \fill[fieldgray!30] (52,0) rectangle (59,\boxheight);
  \draw[thick] (59,0) -- (59,\boxheight);
  \node at (55.5,1.5) {Available};
  \node[below] at (59,-0.3) {58};
  
  % Protection Key (59-62)
  \fill[fieldyellow!30] (59,0) rectangle (63,\boxheight);
  \draw[thick] (63,0) -- (63,\boxheight);
  \node at (61,1.5) {PKE};
  \node[below] at (59,-0.3) {59};
  \node[below] at (63,-0.3) {62};
  
  % XD bit (63)
  \fill[fieldred!30] (63,0) rectangle (64,\boxheight);
  \node at (63.5,1.5) {XD};
  \node[below] at (63.5,-0.3) {63};
  
  % Add descriptive labels with arrows
  \node[above, text=fieldblue!70!black] (lblP) at (0.5,4) {Present};
  \draw[->, fieldblue!60!black] (lblP.south) -- (0.5,\boxheight);
  
  \node[above, text=fieldgreen!70!black] (lblW) at (1.5,4.5) {Writable};
  \draw[->, fieldgreen!60!black] (lblW.south) -- (1.5,\boxheight);
  
  \node[above, text=fieldyellow!70!black] (lblUS) at (2.5,5) {User/Supervisor};
  \draw[->, fieldyellow!60!black] (lblUS.south) -- (2.5,\boxheight);
  
  \node[above, text=fieldorange!70!black] (lblPWT) at (3.5,4) {Write-Through};
  \draw[->, fieldorange!60!black] (lblPWT.south) -- (3.5,\boxheight);
  
  \node[above, text=fieldorange!70!black] (lblPCD) at (4.5,4.5) {Cache Disable};
  \draw[->, fieldorange!60!black] (lblPCD.south) -- (4.5,\boxheight);
  
  \node[above, text=fieldcyan!70!black] (lblA) at (5.5,5) {Accessed};
  \draw[->, fieldcyan!60!black] (lblA.south) -- (5.5,\boxheight);
  
  \node[above, text=fieldcyan!70!black] (lblD) at (6.5,4) {Dirty};
  \draw[->, fieldcyan!60!black] (lblD.south) -- (6.5,\boxheight);
  
  \node[above, text=fieldpink!70!black] (lblPAT) at (7.5,4.5) {Page Attr Table};
  \draw[->, fieldpink!60!black] (lblPAT.south) -- (7.5,\boxheight);
  
  \node[above, text=fieldpink!70!black] (lblG) at (8.5,5) {Global};
  \draw[->, fieldpink!60!black] (lblG.south) -- (8.5,\boxheight);
  
  \node[above, text=fieldgray!70!black] (lblAVL) at (10.5,4) {Available for OS};
  \draw[->, fieldgray!60!black] (lblAVL.south) -- (10.5,\boxheight);
  
  \node[above, text=fieldpurple!70!black] (lblPFA) at (32,4.5) {Physical Page Frame (bits 51:12)};
  \draw[->, fieldpurple!60!black] (lblPFA.south) -- (32,\boxheight);
  
  \node[above, text=fieldyellow!70!black] (lblPKE) at (61,4) {Protection Key};
  \draw[->, fieldyellow!60!black] (lblPKE.south) -- (61,\boxheight);
  
  \node[above, text=fieldred!70!black] (lblXD) at (63.5,4.5) {Execute Disable};
  \draw[->, fieldred!60!black] (lblXD.south) -- (63.5,\boxheight);
\end{tikzpicture}

\vspace{1em}
\small
\begin{itemize}
  \item 64-bit entries support 52-bit physical addresses
  \item Protection keys (PKE) provide additional access control
  \item XD bit prevents code execution from data pages
\end{itemize}
\end{frame}

% Slide 6: 64-bit Mode Page Mapping
\begin{frame}{4KB Page Mapping in 64-bit Mode}
\begin{itemize}
    \item Introduced in 2003 with AMD Opteron
    \item 4-level hierarchy: PML4, PDP, DIR, TABLE
    \item 512 entries per table (9 bits addressing)
    \item 48 bits of virtual address space (256 TB)
    \item 40 bits of physical address space (1 TB)
\end{itemize}

\vspace{1em}
Linear Address breakdown (4KB page):\\
\texttt{[63:48] Sign Ext | [47:39] PML4 | [38:30] PDP | [29:21] DIR | [20:12] TABLE | [11:0] OFFSET}
\end{frame}

% Slide 6: Large Pages in 64-bit Mode
\begin{frame}{Large Pages in 64-bit Mode}
\textbf{2MB Page Mapping:}
\begin{itemize}
    \item Linear Address: Sign Ext | PML4[47:39] | PDP[38:30] | DIR[29:21] | OFFSET[20:0]
    \item Page size: $2^{21}$ = 2MB
\end{itemize}

\vspace{1em}
\textbf{1GB Page Mapping:}
\begin{itemize}
    \item Linear Address: Sign Ext | PML4[47:39] | PDP[38:30] | OFFSET[29:0]
    \item Page size: $2^{30}$ = 1GB
\end{itemize}
\end{frame}

% Slide 7: Question 1 Setup
\begin{frame}{Question 1}
Core similar to X86 in 64-bit mode:
\begin{itemize}
    \item Support Small Pages (PTE) and Large Pages (DIR)
    \item Page table size = small page size
    \item Entry size in all hierarchies = 16 bytes
\end{itemize}

\vspace{0.5em}
Address format:\\
\texttt{[63:N4+1] Sign Ext | [N4:N3+1] PML4 | [N3:N2+1] PDP | [N2:N1+1] DIR | [N1:12] TABLE | [11:0] OFFSET}

\vspace{0.5em}
\textbf{Questions:}
\begin{enumerate}
    \item What is the size of a small page?
    \item How many entries are in each Page Table?
    \item What are the values of N1, N2, N3, and N4?
    \item What is the size of a large page?
\end{enumerate}
\end{frame}

% Slide 8: Question 1 Solution
\begin{frame}{Question 1: Solution (a)}
\begin{enumerate}
    \item \textbf{Small page size}
    \begin{itemize}
        \item[] 12 bits in offset field $\Rightarrow 2^{12}$ = 4KB
    \end{itemize}
    \item \textbf{Entries per Page Table}
    \begin{itemize}
        \item Page Table size = Page Size = 4KB
        \item PTE = 16B
        \item Entries = $\frac{\text{4KB}}{\text{16B}} = \frac{2^{12}}{2^4} = 2^8$ = 256 entries
    \end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{Question 1: Solution (b)}
\begin{enumerate}
    \setcounter{enumi}{2}
    \item \textbf{Values of N1, N2, N3, N4}
    \begin{itemize}
        \item 256 entries $\Rightarrow$ 8 bits to address them
    \end{itemize}
    \begin{center}
        \begin{tabular}{lcl}
            TABLE [19:12] & $\Rightarrow$ & N1 = 19\\
            DIR [27:20]   & $\Rightarrow$ & N2 = 27\\
            PDP [35:28]   & $\Rightarrow$ & N3 = 35\\
            PML4 [43:36]  & $\Rightarrow$ & N4 = 43
        \end{tabular}
    \end{center}

    \item \textbf{Large page size}
    \begin{itemize}
        \item Large pages pointed by DIR, offset is [19:0]
        \item Size = $2^{20}$ = 1MB
    \end{itemize}
\end{enumerate}
\end{frame}

% Slide 9: TLB Introduction
\begin{frame}{Translation Lookaside Buffer (TLB)}
\begin{columns}[T]
\begin{column}{0.6\textwidth}
\begin{itemize}
    \item Page table resides in memory\\
    $\Rightarrow$ each translation requires extra memory access
    \item TLB caches recently used PTEs
    \begin{itemize}
        \item Speed up translation
        \item Typically 128-256 entries
        \item 4-8 way associative
    \end{itemize}
    \item \textbf{TLB Indexing:}
\end{itemize}
\vspace{0.2cm}
\begin{tikzpicture}[scale=0.8]
    \draw[thick] (0,0) rectangle (4,0.5);
    \draw[thick] (2.5,0) -- (2.5,0.5);
    \node at (1.25,0.25) {\small Virtual Page Number};
    \node at (3.25,0.25) {\small Offset};
    
    \draw[thick] (0,-0.8) rectangle (4,-0.3);
    \draw[thick] (1.5,-0.8) -- (1.5,-0.3);
    \draw[thick] (2.5,-0.8) -- (2.5,-0.3);
    \node at (0.75,-0.55) {\small Tag};
    \node at (2,-0.55) {\small Set};
    \node at (3.25,-0.55) {\small Offset};
\end{tikzpicture}

\textbf{On TLB miss:}\\
Page Miss Handler (PMH) gets PTE from memory
\end{column}

\begin{column}{0.4\textwidth}
\begin{center}
\begin{tikzpicture}[node distance=0.8cm, auto]
    \scriptsize
    % Nodes
    \node[draw, ellipse] (va) {Virtual Address};
    \node[draw, rectangle, below=of va] (tlb) {TLB Access};
    \node[draw, diamond, below=of tlb, aspect=2] (hit) {TLB Hit?};
    \node[draw, rectangle, left=of hit, align=center] (pt) {Access\\Page Table\\in Memory};
    \node[draw, ellipse, below=of hit, align=center] (pa) {Physical\\Address};
    
    % Arrows
    \draw[->, thick] (va) -- (tlb);
    \draw[->, thick] (tlb) -- (hit);
    \draw[->, thick] (hit) -- node[right] {Yes} (pa);
    \draw[->, thick] (hit) -- node[above] {No} (pt);
    \draw[->, thick] (pt) |- (pa);
\end{tikzpicture}
\end{center}
\end{column}
\end{columns}
\end{frame}

% Slide 10: STLB - Secondary TLB
\begin{frame}{STLB - Secondary TLB}
\begin{itemize}
    \item PMH can access STLB instead of performing page walk
    \item After TLB miss, look in STLB. The STLB is much larger than TLB, so it has higher hit rate but also higher access latency
    \item If hit on STLB, copy PTE to TLB
    \item STLB contains memory references from both I-cache and D-cache, allowing data and code pages to be shared
    \item Like TLB, uses VPN for lookup to STLB
    \item On STLB hit, translation is used
    \item On STLB miss, PMH performs page walk
\end{itemize}

\vspace{1em}
\textbf{TLB Hierarchy:}
\begin{center}
\begin{tikzpicture}[node distance=1.5cm, auto]
    \node[draw, rectangle] (va) {Virtual Address};
    \node[draw, rectangle, below=of va] (tlb) {TLB};
    \node[draw, rectangle, below=of tlb] (stlb) {STLB};
    \node[draw, rectangle, below=of stlb] (pmh) {PMH/Page Walk};
    \node[draw, rectangle, right=of tlb, xshift=1cm] (pa) {Physical Address};
    
    \draw[->, thick] (va) -- (tlb);
    \draw[->, thick] (tlb) -- node[left] {miss} (stlb);
    \draw[->, thick] (stlb) -- node[left] {miss} (pmh);
    \draw[->, thick] (tlb) -- node[above] {hit} (pa);
    \draw[->, thick] (stlb.east) -- ++(0.5,0) |- node[near end, above] {hit} (pa);
    \draw[->, thick] (pmh.east) -- ++(1,0) |- (pa);
\end{tikzpicture}
\end{center}
\end{frame}

% Slide 11: Virtual Memory and Cache
\begin{frame}{Virtual Memory and Cache}
\begin{center}
\begin{tikzpicture}[
    node distance=0.4cm and 0.4cm, 
    auto, 
    font=\tiny,
    diamond node/.style={draw, diamond, align=center, minimum width=1.6cm, minimum height=1.6cm}
]
    % Nodes
    \node[draw, ellipse, fill=yellow!20, align=center] (va) {Virtual\\Address};
    
    % TLB path
    \node[draw, rectangle, fill=orange!20, below=of va, align=center] (tlb) {Access\\TLB};
    \node[diamond node, below=of tlb] (tlbhit) {TLB\\Hit?};
    \node[diamond node, left=of tlbhit] (stlbhit) {STLB\\Hit?};
    \node[draw, rectangle, align=center, left=of stlbhit] (pw) {Page Walk:\\get PTE from\\memory\\hierarchy};
    
    % Cache path
    \node[draw, rectangle, fill=green!20, below=of va, xshift=3cm, align=center] (cache) {Access\\Cache};
    \node[diamond node, below=of cache] (l1hit) {L1\\Cache\\Hit?};
    \node[diamond node, right=of l1hit] (l2hit) {L2\\Cache\\Hit?};
    \node[draw, rectangle, right=of l2hit, align=center] (mem) {Access\\Memory};
    
    % Result nodes
    \node[draw, ellipse, fill=blue!20, below=of tlbhit, align=center] (pa) {Physical\\Address};
    \node[draw, ellipse, fill=green!20, below=of l1hit] (data) {Data};
    
    % Arrows - TLB path
    \draw[->, thick] (va) -- (tlb);
    \draw[->, thick] (tlb) -- (tlbhit);
    \draw[->, thick] (tlbhit) -- node[left] {Yes} (pa);
    \draw[->, thick] (tlbhit) -- node[above] {No} (stlbhit);
    \draw[->, thick] (stlbhit) -- node[above] {No} (pw);
    \draw[->, thick] (stlbhit) -- node[left] {Yes} (pa);
    \draw[->, thick] (pw) |- (pa);
    
    % Arrows - Cache path
    \draw[->, thick, dashed] (pa) -| (cache);
    \draw[->, thick] (cache) -- (l1hit);
    \draw[->, thick] (l1hit) -- node[left] {Yes} (data);
    \draw[->, thick] (l1hit) -- node[above] {No} (l2hit);
    \draw[->, thick] (l2hit) -- node[left] {Yes} (data);
    \draw[->, thick] (l2hit) -- node[above] {No} (mem);
    \draw[->, thick] (mem) |- (data);
\end{tikzpicture}
\end{center}

%\vspace{0.5em}
\begin{itemize}
    \item TLB access is serial with cache access
    \item Page table entries are cached in L1 D\$, L2\$, and L3\$ as data
\end{itemize}
\end{frame}

% Slide 12: Page Walk and PMH
\begin{frame}{Page Walk Process}
\textbf{PMH (Page Miss Handler) Operation:}
\begin{itemize}
    \item PMH performs page walk on TLB miss
    \item Walks the page table hierarchy from root (PML4)
    \item PMH contains caches for higher translation levels:
    \begin{itemize}
        \item PML4 cache
        \item PDP cache
        \item DIR cache
    \end{itemize}
\end{itemize}

\vspace{1em}
\textbf{PMH Cache Access:}
\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Cache} & \textbf{Accessed with} & \textbf{Returns} \\
\hline
DIR cache & [47:21] & PDE \\
PDP cache & [47:30] & PDP entry \\
PML4 cache & [47:39] & PML4 entry \\
\hline
\end{tabular}
\end{center}

\vspace{0.5em}
Note: No Table cache needed as TLB stores complete translations
\end{frame}

\begin{frame}{Caches and Translation Structures}
\begin{tikzpicture}[
    cache/.style={rectangle, draw, thick, minimum height=0.6cm, minimum width=2cm},
    tlb/.style={rectangle, draw, thick, minimum height=0.6cm, minimum width=1.8cm},
    bigbox/.style={rectangle, draw, thick},
    arrow/.style={->, >=stealth, thick,},
    label/.style={font=\tiny},
    font=\scriptsize
]

% L1 Caches
\node[cache, fill=blue!30] (l1inst) {L1 Inst. cache};
\node[cache, fill=orange!30, right=1cm of l1inst, minimum width=3cm] (l1data) {L1 data cache};

% TLBs
\node[tlb, fill=cyan!30, below=0.8cm of l1inst] (insttlb) {Inst. TLB};
\node[tlb, fill=violet!30, below=0.8cm of l1data.south west, anchor=north west] (datatlb) {Data. TLB};

% Translation caches
\node[cache, below=1.1cm of insttlb, xshift=1cm] (stlb) {STLB};
\node[cache, below=0.2cm of stlb] (pdecache) {PDE cache};
\node[cache, below=0.2cm of pdecache] (pdpcache) {PDP cache};
\node[cache, below=0.2cm of pdpcache] (pml4cache) {PML4 cache};

% PMH and Page Walk Logic
\node[rectangle, draw, thick, fill=yellow!20, minimum height=3cm, minimum width=1.5cm, 
      right=2.5cm of stlb, yshift=-1.2cm] (pmh) {};
\node[align=center, anchor=south west] (pmhlabel) at (pmh.north) {PMH};
\node[align=center] (pwllabel) at (pmh.center) {Page\\Walk\\Logic};

% Fit box around translation caches
\node[bigbox, fit=(stlb)(pdecache)(pdpcache)(pml4cache)(pmh)(pmhlabel)] (transbox) {};

% L2, L3, and Memory
\node[cache, fill=gray!30, right=of l1data, minimum width=1cm] (l2) {L2};
\node[cache, fill=green!20, right=of l2, minimum width=1cm] (l3) {L3};
\node[cache, fill=green!30, right=0.8cm of l3, minimum width=1.5cm] (memory) {Memory};

% Core box
\node[bigbox, fit=(l1inst)(l1data)(insttlb)(datatlb)(transbox)(pmhlabel)(l2), 
      inner sep=0.3cm, label={[font=\textbf]north west:Core}] (corebox) {};

% On-die box
\node[bigbox, fit=(l3), inner sep=0.2cm, label={[font=\small]above:On-die}] (ondiebox) {};

% Platform box
\node[bigbox, fit=(memory), inner sep=0.2cm, label={[font=\small]above:Platform}] (platformbox) {};

% Arrows and connections
\draw[arrow, blue] (l1inst) to[bend left=20] node[above, near end, label] {Instruction bytes} (l1data);
\draw[arrow, cyan] (insttlb) -- (l1inst) node[midway, left, label] {translation};
\draw[arrow, violet] (datatlb) -- (l1data) node[midway, left, label] {translation};

% PTE connections
\draw[arrow] (insttlb) to[bend right=15] node[near start, below, label] {PTE} (stlb.north west);
\draw[arrow] (datatlb) to[bend left=15] node[near start, below, label] {PTE} (stlb.north east);

\draw[arrow] ($(pmh.west |- stlb.south) + (0,1mm)$) -- node[near end, above, label, xshift=3mm] {VA[47:12]}  ($(stlb.south east) + (0,1mm)$);
\draw[arrow] ($(pmh.west |- pdecache.south) + (0,1mm)$) -- node[near end, above, label, xshift=3mm] {VA[47:21]}  ($(pdecache.south east) + (0,1mm)$);
\draw[arrow] ($(pmh.west |- pdpcache.south) + (0,1mm)$) -- node[near end, above, label, xshift=3mm] {VA[47:30]}  ($(pdpcache.south east) + (0,1mm)$);
\draw[arrow] ($(pmh.west |- pml4cache.south) + (0,1mm)$) -- node[near end, above, label, xshift=3mm] {VA[47:39]}  ($(pml4cache.south east) + (0,1mm)$);

% From translation caches to PMH
\draw[arrow, red, thick] (stlb.east) -- node[above, label] {PTE} 
      ($(pmh.west)!0.8!(pmh.north west)$);
\draw[arrow, red, thick] (pdecache.east) -- node[above, label] {PDE entry} 
      ($(pmh.west)!0.6!(pmh.north west)$);
\draw[arrow, red, thick] (pdpcache.east) -- node[above, label] {PDP entry} 
      ($(pmh.west)!0.4!(pmh.north west)$);
\draw[arrow, red, thick] (pml4cache.east) -- node[above, label] {PML4 entry} 
      ($(pmh.west)!0.2!(pmh.north west)$);

% VA labels on the right side of PMH
%\node[label, right=0.1cm of pmh.east, yshift=1.2cm] {VA[47:12]};
%\node[label, right=0.1cm of pmh.east, yshift=0.4cm] {VA[47:21]};
%\node[label, right=0.1cm of pmh.east, yshift=-0.4cm] {VA[47:30]};
%\node[label, right=0.1cm of pmh.east, yshift=-1.2cm] {VA[47:39]};

% PMH to L1 data cache
%\draw[arrow, red, thick] (pmh.north) to[out=90, in=270] (l1data.south);
\draw[arrow, red, thick] 
  ($(pmh.north -| l1data.east) + (-3mm,0)$) --  
  node[right, align=center] {Load} 
  ($(l1data.south east) + (-3mm,0)$);


% L1 data cache to L2
\draw[arrow, blue, thick] (l2.west) -- (l1data.east);

% L2 to L3 to Memory
\draw[<->, thick] (l2.east) -- (l3.west);
\draw[<->, thick] (l3.east) -- (memory.west);

\end{tikzpicture}
\end{frame}


% Slide 13: Question 2 Setup
\begin{frame}{Question 2}
\textbf{System Configuration:}
\begin{itemize}
    \item Processor similar to X86-64
    \item 4KB pages
    \item TLB present (Hit: immediate translation, Miss: Page Walk required)
    \item PMH contains cache for each translation table level
    \item All caches and TLB empty on reset
\end{itemize}

\vspace{1em}
\textbf{Memory Access Sequence:}
\begin{center}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Address} & \textbf{Memory Accesses} & \textbf{Explanation} \\
\hline
0x0000022334455666 & ? & \\
0x0000022334455777 & ? & \\
0x0000022884455777 & ? & \\
\hline
\end{tabular}
\end{center}
\end{frame}

% Slide 14: Question 2 Solution
\begin{frame}{Question 2 - Solution}
\begin{center}
\begin{tabular}{|l|c|p{6cm}|}
\hline
\textbf{Address} & \textbf{Accesses} & \textbf{Explanation} \\
\hline
0x0000022334455666 & 4 & Need to access memory for each of the 4 translation tables \\
\hline
0x0000022334455777 & 0 & Same page as above $\Rightarrow$ TLB hit $\Rightarrow$ No memory access \\
\hline
0x0000022884455777 & 3 & Hit in PML4 cache, then miss in PDP. Need to access memory 3 times: PDP, DIR, PTE \\
\hline
\end{tabular}
\end{center}
\end{frame}

% Slide 15: Cache Design Question
\begin{frame}{Question 2: Cache Design}
\textbf{System Configuration:}
\begin{itemize}
    \item Virtual address: 48 bits
    \item Physical address: 41 bits
    \item L1 data cache: 32KB, 2-way set associative, 64B line size
\end{itemize}

\vspace{1em}
\textbf{Question:} How can we access this cache before getting the physical address?

\vspace{1em}
\textbf{Analysis:}
\begin{itemize}
    \item 64B lines $\Rightarrow$ 6 offset bits [5:0]
    \item $\frac{32\text{KB}}{(2\text{ ways} \times 64\text{B})}$ = 256 sets $\Rightarrow$ 8 set bits [13:6]
    \item 12 bits [11:0] are not translated (page offset)
    \item We lack 2 bits [13:12] for complete set address
    \item Solution: Use untranslated bits [13:12] for set lookup
    \item Must compare entire PFN with tag due to aliasing possibility
\end{itemize}
\end{frame}

% Slide 16: Virtual Aliasing Problem
\begin{frame}{Virtual Aliasing Problem}
\textbf{Problem:} Two virtual pages mapping to same physical page

\vspace{1em}
Example:
\begin{itemize}
    \item VPN xxxx01 $\rightarrow$ PFN zzzz
    \item VPN yyyy00 $\rightarrow$ PFN zzzz
    \item Bits [13:12] differ (01 vs 00)
\end{itemize}

\vspace{1em}
\textbf{Consequence:}
\begin{itemize}
    \item Same data may exist in two different cache sets
    \item Violates cache coherency
\end{itemize}

\vspace{1em}
\textbf{Solution:}
\begin{itemize}
    \item Check 4 possible sets when allocating new entry
    \item If same tag appears, evict the alias
    \item On snoop: must check 4 sets × 2 ways = 8 locations
\end{itemize}
\end{frame}

% Slide 17: Question 3 Setup
\begin{frame}{Question 3}
\textbf{System Configuration:}
\begin{itemize}
    \item Core similar to X86 in 64-bit mode
    \item Entry size in all page tables: 8 bytes
    \item PMH caches at all levels:
    \begin{itemize}
        \item 4 entries, direct mapped
        \item Hit time: 2 cycles
        \item Miss detected after 1 cycle
    \end{itemize}
    \item Main memory access: 100 cycles (not including miss detection)
    \item All PMH levels accessed in parallel
\end{itemize}

\vspace{1em}
Address format:\\
\texttt{[63:56] Sign | [55:36] PML4 | [35:24] PDP | [23:12] DIR | [11:0] TABLE/OFFSET}

\vspace{0.5em}
\textbf{Questions:}
\begin{enumerate}
    \item What is the large page size?
    \item How many entries in each table?
\end{enumerate}
\end{frame}

% Slide 18: Question 3 Solution Part 1
\begin{frame}{Question 3 - Solution Part 1}
\textbf{1. Large page size:}
\begin{itemize}
    \item Large pages pointed by DIR
    \item Offset bits: [23:0]
    \item Size = $2^{24}$ = 16MB
\end{itemize}

\vspace{1em}
\textbf{2. Entries per table:}
\begin{itemize}
    \item TABLE: $2^{12}$ bits offset $\Rightarrow 2^{12}$ entries
    \item DIR: $2^{12}$ bits $\Rightarrow 2^{12}$ entries  
    \item PDP: $2^{12}$ bits $\Rightarrow 2^{12}$ entries
    \item PML4: $2^{8}$ bits $\Rightarrow 2^{8}$ = 256 entries
\end{itemize}
\end{frame}

% Slide 19: Question 3 Memory Access Analysis
\begin{frame}{Question 3 - Memory Access Analysis}
\footnotesize
% Define colors for different page table levels
\definecolor{signcolor}{RGB}{128,128,128}
\definecolor{pml4color}{RGB}{255,128,0}
\definecolor{pdpcolor}{RGB}{51,153,255}
\definecolor{dircolor}{RGB}{0,204,102}
\definecolor{offsetcolor}{RGB}{204,0,204}

\begin{center}
\begin{tabular}{|l|c|p{8cm}|}
\hline
\textbf{Virtual Address} & \textbf{Cycles} & \textbf{Comment} \\
\hline
\textcolor{signcolor}{0xFF81}\textcolor{pml4color}{234}\textcolor{pdpcolor}{567}\textcolor{dircolor}{89A}\textcolor{offsetcolor}{BCD} & \onslide<2->{401} & \onslide<2->{Miss at each level: 1 + 4 $\times$ 100 = 401 cycles} \\
\hline
\textcolor{signcolor}{0xFF81}\textcolor{pml4color}{234}\textcolor{pdpcolor}{067}\textcolor{dircolor}{89A}\textcolor{offsetcolor}{BCD} & \onslide<3->{202} & \onslide<3->{(PML4, PDP, DIR, TLB) = (H,H,M,M)}\\
& & \onslide<3->{1 cycle + PDP read 1 cycle}\\
& & \onslide<3->{DIR miss: 100 cycles, PTE miss: 100 cycles} \\
\hline
\textcolor{signcolor}{0xFF80}\textcolor{pml4color}{234}\textcolor{pdpcolor}{067}\textcolor{dircolor}{89A}\textcolor{offsetcolor}{BCD} & \onslide<4->{401} & \onslide<4->{PMH cache miss in all levels: 1 + 4 $\times$ 100 = 401} \\
\hline
\textcolor{signcolor}{0xFF81}\textcolor{pml4color}{234}\textcolor{pdpcolor}{067}\textcolor{dircolor}{09A}\textcolor{offsetcolor}{BCD} & \onslide<5->{302} & \onslide<5->{(PML4, PDP, DIR, TLB) = (H,M,M,M)}\\
& & \onslide<5->{Entry 234 replaced by access 3 (same set)}\\
& & \onslide<5->{2 + 3 $\times$ 100 = 302 cycles} \\
\hline
\textcolor{signcolor}{0xFF81}\textcolor{pml4color}{234}\textcolor{pdpcolor}{067}\textcolor{dircolor}{09A}\textcolor{offsetcolor}{0CD} & \onslide<6->{2} & \onslide<6->{Hit in TLB - 2 cycles} \\
\hline
\end{tabular}
\end{center}

\vspace{0.5em}
\onslide<7->{
\small
\textbf{Color Legend:} 
\textcolor{signcolor}{Sign}, 
\textcolor{pml4color}{PML4}, 
\textcolor{pdpcolor}{PDP}, 
\textcolor{dircolor}{DIR}, 
\textcolor{offsetcolor}{Offset}
}
\end{frame}

% Final slide
\begin{frame}
\centering
\Huge{Questions?}
\end{frame}

\end{document}