\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{tikz}
\usetikzlibrary{matrix, arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, shapes.multipart, fit, decorations.pathreplacing}
\usepackage{circuitikz}
\usepackage{tcolorbox}
\usepackage{array}
\usepackage{listings}
\usepackage{pgfkeys}
\usepackage[normalem]{ulem}
\usepackage{bytefield}

\usetheme{Madrid}

% Custom colors
\definecolor{correctgreen}{RGB}{0,150,0}
\definecolor{incorrectred}{RGB}{200,0,0}
\definecolor{counterblue}{RGB}{70,130,255}
\definecolor{highlightyellow}{RGB}{255,230,100}
\definecolor{lightblue}{RGB}{200,230,250}
\definecolor{darkblue}{RGB}{0,100,200}
\definecolor{highlightorange}{RGB}{255,200,100}
\definecolor{memorycolor}{RGB}{200,200,255}
\definecolor{processcolor}{RGB}{255,200,200}
\definecolor{diskcolor}{RGB}{255,255,200}

% PGF keys for configurable macros
\pgfkeys{
  /memblock/.is family,
  /memblock,
  default/.style = {
    width = 3cm,
    height = 0.6cm,
    color = memorycolor,
    text = {},
    label = {}
  },
  width/.estore in = \memblockWidth,
  height/.estore in = \memblockHeight,
  color/.estore in = \memblockColor,
  text/.estore in = \memblockText,
  label/.estore in = \memblockLabel,
}

% Macro for memory blocks
\newcommand{\memoryblock}[2][]{
  \pgfkeys{/memblock, default, #1}
  \node[draw, rectangle, minimum width=\memblockWidth, minimum height=\memblockHeight, 
        fill=\memblockColor, #2] {\memblockText};
  \ifx\memblockLabel\empty\else
    \node[above] at (#2.north) {\small\memblockLabel};
  \fi
}

% Macro for page table entries
\newcommand{\pteentry}[5][]{
  \begin{tikzpicture}[baseline=(current bounding box.center)]
    \node[draw, rectangle split, rectangle split horizontal, 
          rectangle split parts=4, inner sep=2pt, #1] {
      \nodepart{one} V: #2
      \nodepart{two} M: #3
      \nodepart{three} #4
      \nodepart{four} PFN: #5
    };
  \end{tikzpicture}
}

% Macro for address representation
\newcommand{\addressrep}[3][]{
  \begin{tikzpicture}[baseline=(current bounding box.center)]
    \node[draw, rectangle split, rectangle split horizontal, 
          rectangle split parts=2, inner sep=3pt, #1] {
      \nodepart{one} #2
      \nodepart{two} #3
    };
  \end{tikzpicture}
}

% Macro for memory hierarchy diagram
\newcommand{\memoryhierarchy}[1][]{
  \begin{tikzpicture}[
    proc/.style={draw, circle, minimum size=1.5cm, fill=processcolor},
    mem/.style={draw, rectangle, minimum width=2cm, minimum height=3cm, fill=memorycolor},
    disk/.style={draw, cylinder, shape border rotate=90, minimum width=2cm, minimum height=1.5cm, fill=diskcolor},
    #1
  ]
}

\title{Virtual Memory}
\author{Computer Architecture 2360267}
\date{2025, Recitation \#10}

%\subtitle{Computer Architecture}
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{The Problem}
\begin{columns}
\column{0.6\textwidth}
\begin{itemize}
\item There is a given and limited amount of physical memory
\item How do we divide it among different processes?
\end{itemize}

\column{0.4\textwidth}
\begin{tikzpicture}[scale=0.8]
  \node[draw, circle, fill=processcolor, minimum size=1cm] (cpu) at (0,3) {CPU};
  \node[draw, rectangle, fill=lightblue!50, minimum width=1.5cm, minimum height=0.8cm] (p1) at (-2,1) {Process 1};
  \node[draw, rectangle, fill=lightblue!50, minimum width=1.5cm, minimum height=0.8cm] (p2) at (2,1) {Process 2};
  \node[draw, rectangle, fill=lightblue!50, minimum width=1.5cm, minimum height=0.8cm, yshift=-2mm] (p3) at (0,0) {Process 3};
  \node[muxdemux, muxdemux def={NT=3, Rh=1.5, Lh=1.5, NR=0, NL=0, NB=0, w=6}, external pins width=0, fill=memorycolor] (mem) at (0,-2.5) {Physical Memory};

  \draw[->, thick] (cpu) -- (p1);
  \draw[->, thick] (cpu) -- (p2);
  \draw[->, thick] (cpu) -- (p3);
  \draw[->, dashed] (p1.south) -- (mem.tpin 1);
  \draw[->, dashed] (p2.south) -- (mem.tpin 3);
  \draw[->, dashed] (p3.south) -- (mem.tpin 2);
\end{tikzpicture}
\end{columns}
\end{frame}

\begin{frame}{The Solution: Virtual Memory}
\begin{description}
\item[\textcolor{processcolor!80!black}{Process}] Uses its own unique \textbf{virtual address space}
\begin{itemize}
  \item Sees the illusion of owning all memory
  \item Accesses memory only through virtual addresses
\end{itemize}

\item[\textcolor{correctgreen}{OS}] Maps each process's virtual space to physical memory (or disk)
\begin{itemize}
  \item Manages the translation tables
  \item Handles page faults and swapping
\end{itemize}

\item[\textcolor{darkblue}{Hardware}] Translates virtual → physical addresses
\begin{itemize}
  \item Uses OS-provided mapping tables
  \item Performs translation on every memory access
\end{itemize}
\end{description}
\end{frame}

\begin{frame}{Key Concepts}
\begin{columns}[T]
\column{0.5\textwidth}
\textbf{Physical Memory Terms:}
\begin{itemize}
\item \textbf{Frame}: Physical memory divided into equal units
\item \textbf{PFN} (Physical Frame Number): Frame number in physical space
\end{itemize}

\column{0.5\textwidth}
\textbf{Virtual Memory Terms:}
\begin{itemize}
\item \textbf{Page}: Virtual memory divided into units equal in size to frames
\item \textbf{VPN} (Virtual Page Number): Page number in logical space
\end{itemize}
\end{columns}

\vspace{0.5cm}
\begin{block}{Memory Management Techniques}
\begin{itemize}
\item \textbf{Swapping}: Using secondary memory to extend memory space
\item \textbf{Demand Paging}: Pages are brought into physical memory only when needed
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Advantages of Virtual Memory}
\begin{enumerate}
\item \textbf{Memory Expansion}
\begin{itemize}
  \item Swapping extends memory beyond physical limits
\end{itemize}
\item \textbf{No Relocation Needed}
\begin{itemize}
  \item Each program has its own address space starting at 0
\end{itemize}
\item \textbf{Easy Memory Sharing}
\begin{itemize}
  \item Multiple PTEs can point to the same physical frame
  \item Enables efficient process forking (copy-on-write)
\end{itemize}
\item \textbf{Protection \& Isolation}
\begin{itemize}
  \item Processes cannot access each other's memory spaces
\end{itemize}
\end{enumerate}
\end{frame}

\section{Address Translation}

\begin{frame}{Physical Memory Structure}
\begin{columns}
\column{0.5\textwidth}
Physical memory can be divided into two parts:
\begin{enumerate}
\item \textbf{Upper part}: Contains translation tables for all processes' virtual spaces
\item \textbf{Lower part}: Contains frames holding process memory pages
\end{enumerate}

\vspace{0.3cm}
\textbf{Key principle:}\\
Frame size in physical memory = Page size in virtual memory

\column{0.5\textwidth}
\begin{tikzpicture}[scale=0.7]
  % Physical Memory
  \draw[thick] (0,0) rectangle (3,5);
  \node at (1.5,5.3) {Physical Memory};
  
  % Upper part - Page Tables
  \draw[fill=lightblue!30] (0,3) rectangle (3,5);
  \node at (1.5,4.5) {Page Tables};
  \node at (1.5,4) {\small PT};
  \node at (1.5,3.5) {\small PT};
  
  % Lower part - Frames
  \draw (0,2.5) -- (3,2.5);
  \draw (0,2) -- (3,2);
  \draw (0,1.5) -- (3,1.5);
  \draw (0,1) -- (3,1);
  \draw (0,0.5) -- (3,0.5);
  
  \node at (1.5,2.25) {\small Frame 3};
  \node at (1.5,1.75) {\small Frame 2};
  \node at (1.5,1.25) {\small Frame 1};
  \node at (1.5,0.75) {\small Frame 0};
  
  % PTBR
  \draw[->, thick] (-1,4) -- (0,4);
  \node at (-1.5,4) {PTBR};
  
  % Disk
  \node[draw, cylinder, shape border rotate=90, minimum width=2cm, minimum height=1.5cm, fill=diskcolor] at (5,1) {Disk};
\end{tikzpicture}
\end{columns}
\end{frame}

\begin{frame}{Virtual Address Translation Process}
\begin{columns}
\column{0.6\textwidth}
The CPU addresses only using the process's virtual addresses. To access data in physical memory, we need to translate virtual to physical addresses.

\vspace{0.5cm}
\textbf{Virtual Address Structure:}
\begin{center}
\addressrep{VPN}{Offset}
\end{center}

\begin{itemize}
\item \textbf{VPN}: Virtual Page Number
\item \textbf{Offset}: Displacement from page start to desired byte
\end{itemize}

\column{0.4\textwidth}
\begin{tikzpicture}[scale=0.8]
  \node[draw, rectangle split, rectangle split horizontal, rectangle split parts=2] (vaddr) at (0,3) {
    \nodepart{one} VPN
    \nodepart{two} Offset
  };
  
  \node[draw, rectangle, fill=lightblue!30] (pt) at (0,1.5) {Page Table};
  
  \node[draw, rectangle split, rectangle split horizontal, rectangle split parts=2] (paddr) at (0,0) {
    \nodepart{one} PFN
    \nodepart{two} Offset
  };
  
  \draw[->, thick] (vaddr) -- (pt);
  \draw[->, thick] (pt) -- (paddr);
\end{tikzpicture}
\end{columns}
\end{frame}

\begin{frame}{Page Table Structure}
\begin{columns}
\column{0.5\textwidth}
\textbf{Page Table Basics:}
\begin{itemize}
\item Each process has its own page table
\item One PTE (Page Table Entry) for each virtual page
\item Index in page table = VPN
\item PTBR (Page Table Base Register) points to current process's page table
\end{itemize}

\column{0.5\textwidth}
\begin{tikzpicture}[
  pte/.style={draw, minimum width=1.5cm, minimum height=0.5cm, font=\tiny},
  dots/.style={minimum width=1.5cm, minimum height=0.5cm}
]
  % Page Table using matrix of nodes
  \matrix[matrix of nodes,
          nodes={pte},
          row sep=-\pgflinewidth,
          column sep=0pt,
          ampersand replacement=\&] (pt) {
    |[pte]| PTE \\
    |[pte]| PTE \\
    |[pte]| PTE \\
    |[dots]| \vdots \\
    |[pte]| PTE \\
    |[pte]| PTE \\
    |[pte]| PTE \\
    |[pte]| PTE \\
  };

  % PTBR with relative positioning
  \node[left=1cm of pt-1-1, red] (ptbr) {PTBR};
  \draw[->, thick, red] (ptbr) -- (pt-1-1.west);

  % Label below
  \node[below=3mm of pt] {Page Table};
\end{tikzpicture}
\end{columns}

\vspace{0.5cm}
\begin{block}{PTE Address Calculation}
\texttt{PTE\_Address = [PTBR] + VPN * (Size Of One PTE)}
\end{block}
\end{frame}

\begin{frame}{Virtual Memory: Page Table Translation}

%\begin{columns}[T]
%\column{0.4\textwidth}
%\begin{exampleblock}{\scriptsize Address Configuration}
%\scriptsize
%\textbf{PTBR:} 0x1000\\
%\textbf{Virtual Addr:} 30 bits\\
%\textbf{Physical Addr:} 32 bits
%\end{exampleblock}
%
%\column{0.6\textwidth}
%\begin{exampleblock}{\scriptsize Translation Example}
%\scriptsize
%Virtual address mapped through PTE at\\
%\texttt{(00201200 : 940001C0)} base + offset
%\end{exampleblock}
%\end{columns}

%\vspace{0.5cm}

\begin{center}
\begin{tikzpicture}[scale=0.9, every node/.style={scale=0.9}]
\tikzset{
  entry/.style={
    draw,
    rectangle,
    fill=white,
    minimum width=2.5cm,
    minimum height=0.35cm,
    font=\bfseries\scriptsize
  },
  pte/.style={
    entry,
    minimum width=1cm,  
    font=\tiny\color{red}
  }
}
% Main Memory (Page Table)
\node[draw, rectangle, fill=orange!40, minimum width=3cm, minimum height=5.5cm, rounded corners] (mainmem) {};
\node[above] at (mainmem.north) {\textbf{Main Memory}};

% Page Table Entries with proper spacing
\node[entry, text=blue] (pt1) at (mainmem.center) [yshift=2cm] {PT};
\node[entry, below=0.15cm of pt1, text=green] (pt2) {PT};
\node[entry, below=0.15cm of pt2, text=red, align=left, minimum height=1.6cm] (pt3) {};
\node[anchor=north west, text=red, align=left, font=\scriptsize] at (pt3.north west) {PT};
\node[pte, fill=red!20, below=0cm of pt3.north east, text=red, anchor=north east] (pte1) {PTE};
\node[pte, fill=red!20, below=0cm of pte1, text=red] (pte2) {PTE};
\node[pte, fill=red!20, below=0cm of pte2, text=red] (pte3) {PTE};
\node[text=red, below=0cm of pte3] (pten) {\ldots};
\node[entry, fill=white, below=0.15cm of pt3.south east, anchor=north east, text=green] (entry1) {1};
\node[entry, fill=white, below=0.15cm of entry1, text=blue] (entry2a) {2};
\node[entry, fill=white, below=0.15cm of entry2a, text=red] (entry2b) {2};

% PTBR Register
\node[draw, rectangle, fill=gray!20, minimum width=1.5cm, minimum height=0.6cm, left=2cm of pte1.north west] (ptbr) {\textbf{PTBR}};

% Address labels
\node[left, font=\scriptsize, left=-1mm of pte3] at (pte3.west) (addr) {[0x201200]};
\node[right, font=\scriptsize, red, anchor=east] at ([xshift=-2mm]addr.west) {940001C0 = };

% Secondary Storage/Disk
\node[draw, cylinder, shape border rotate=90, fill=cyan!40, minimum width=3cm, minimum height=6.5cm, aspect=0.8, right=2.5cm of mainmem] (storage) {};
\node[above] at (storage.north) {\textbf{Secondary Storage}};

% Storage Pages
\node[entry, text=blue] (page1) at (storage.north) [yshift=-7mm] {1};
\node[entry, below=0.1cm of page1, text=green] (page2a) {2};
\node[entry, below=0.1cm of page2a, text=blue] (page3a) {3};
\node[entry, below=0.1cm of page3a, text=red] (page1b) {1};
\node[entry, below=0.1cm of page1b, text=green] (page1c) {1};
\node[entry, below=0.1cm of page1c, text=blue] (page2b) {2};
\node[entry, below=0.5cm of page2b, text=red] (page2c) {2};
\node[entry, below=0.1cm of page2c, text=red] (page3b) {3};
\node[entry, below=0.1cm of page3b, text=green] (page3c) {3};

% Arrow from PTBR to Page Table
\draw[->, thick] (ptbr.east) -- (pt3.north west);

% Mapping arrows from entries to storage pages
\draw[<->, dashed, thick] (entry1.east) -- ++(0.5,0) |- (page1c.west);
\draw[<->, dashed, thick] (entry2a.east) -- ++(0.7,0) |- (page2b.west);
\draw[<->, dashed, thick] (entry2b.east) -- ++(0.9,0) |- (page2c.west);

\end{tikzpicture}
\end{center}

\vspace{0.3cm}
\begin{exampleblock}{\scriptsize Key Concepts}
\scriptsize
\begin{itemize}
\item PTBR points to page table location in main memory
\item Valid PTEs contain mappings to physical frames in secondary storage
\item Multiple virtual pages can map to the same physical frame
\end{itemize}
\end{exampleblock}

\end{frame}


\begin{frame}{Page Table Entry (PTE) Structure}
\begin{center}
\begin{tikzpicture}
  \node[draw, rectangle split, rectangle split horizontal, rectangle split parts=3, 
        minimum height=1cm, inner sep=5pt] {
    \nodepart{one} \textbf{V}
    \nodepart{two} \textbf{M}
    \nodepart{three} \textbf{PFN}
  };
\end{tikzpicture}
\end{center}

\vspace{0.5cm}
\begin{itemize}
\item \textbf{V (Valid bit)}: Indicates if page is in physical memory
\begin{itemize}
  \item If not, page may be in secondary storage or address is invalid
  \item Invalid access causes \textbf{Page Fault}
\end{itemize}
\item \textbf{M (Modified bit)}: Indicates if page was modified since loading
\begin{itemize}
  \item Used for Write-Back policy
  \item Only write to disk when page is evicted if M=1
\end{itemize}
\item \textbf{PFN}: Physical Frame Number where page resides
\end{itemize}

\vspace{0.3cm}
\textbf{Page Replacement}: LRU (Least Recently Used) policy
\end{frame}

\begin{frame}{Address Translation Diagram}
\begin{center}
\begin{tikzpicture}[scale=0.85,
  addrfield/.style={draw, minimum height=7mm, inner sep=2mm, font=\small},
  lbl/.style={font=\scriptsize\bfseries},
  arrow/.style={->, thick, >=stealth},
  darrow/.style={<->, dashed, thick, >=stealth},
]
  % Virtual Address - using matrix of nodes
  \matrix[matrix of nodes,
          nodes={addrfield},
          column sep=-\pgflinewidth,
          ampersand replacement=\&] (vaddr) {
    |[fill=lightblue, minimum width=2cm]| VPN \&
    |[fill=highlightyellow, minimum width=1.5cm]| offset \\
  };
  \node[lbl, above=0mm of vaddr] {Virtual Address};

  % Page Table - positioned relative to VPN field
  \node[draw, fill=lightblue!30, minimum width=2.2cm, minimum height=1.6cm,
        below=0.8cm of vaddr-1-1, align=center] (pt) {Page\\Table};

  % PTBR - positioned relative to page table
  \node[draw, fill=highlightorange, inner sep=3mm,
        left=1.5cm of pt.north west, anchor=east] (ptbr) {PTBR};

  % Physical Address - east aligned with virtual address east
  \matrix[matrix of nodes,
          nodes={addrfield},
          column sep=-\pgflinewidth,
          anchor=east,
          ampersand replacement=\&] (paddr) at (vaddr.east |- pt.south) [yshift=-1.5cm] {
    |[fill=correctgreen!30, minimum width=2cm]| PFN \&
    |[fill=highlightyellow, minimum width=1.5cm]| offset \\
  };
  \node[lbl, below=0mm of paddr] {Physical Address};

  % Main Memory - positioned relative to page table
  \node[draw, fill=memorycolor, minimum width=2.2cm, minimum height=3cm,
        right=2cm of pt] (mem) {};
  \node[lbl, above=0mm of mem] {Main Memory};

  % Data block inside memory (white background)
  \node[draw, fill=white, minimum width=1.8cm, minimum height=8mm,
        align=center, font=\small] (data) at (mem.center) {data};

  % Arrows
  % VPN -> Page Table (index)
  \draw[arrow, darkblue] (vaddr-1-1.south) -- (pt.north)
    node[midway, right, font=\scriptsize] {index};

  % PTBR -> Page Table (base)
  \draw[arrow] (ptbr.east) -- (pt.north west)
    node[midway, above, font=\scriptsize] {base};

  % Page Table -> PFN
  \draw[arrow, correctgreen!70!black] (pt.south) -- (paddr-1-1.north)
    node[midway, left, font=\scriptsize] {PFN};

  % Physical Address -> Memory (from right of entire address)
  \draw[arrow, correctgreen!70!black] (paddr.east) to[out=0, in=180] (data.west);

  % Offset passthrough (dashed)
  \draw[darrow, orange!80!black] (vaddr-1-2.south) -- (paddr-1-2.north)
    node[midway, right, font=\scriptsize, text=black] {same};

\end{tikzpicture}
\end{center}

\textbf{Result}: 2 memory accesses — one for page table, one for data
\end{frame}

\section{Questions}

\begin{frame}{Question 1: Virtual Memory System}
\textbf{Given:}
\begin{itemize}
\item Machine without cache
\item Page table in main memory
\item PTBR = 0x1000
\item Content at address 0x00201200 is 0xC0 01 00 94
\item Virtual address: 30 bits
\item Physical address: 32 bits
\item PTE structure (32 bits):
\end{itemize}

\begin{center}
\begin{bytefield}[bitwidth=1.1em, endianness=big, boxformatting={\centering\scriptsize}]{32}
  \bitheader{0,22,23,25,26,27,30,31} \\
  \bitbox{1}[bgcolor=correctgreen!30]{V}
  \bitbox{4}[bgcolor=lightblue]{Prot}
  \bitbox{1}[bgcolor=highlightyellow]{M}
  \bitbox{3}[bgcolor=gray!20]{Unused}
  \bitbox{23}[bgcolor=highlightorange!50]{PFN}
\end{bytefield}
\end{center}
\end{frame}

\begin{frame}{Question 1: Address Translation}
\textbf{Question:} A program reads a dword (4 bytes) from virtual address 0x0A100100
\begin{enumerate}
\item What is the physical address?
\item How many memory accesses are needed?
\end{enumerate}

\textbf{Solution:}
\pause
\begin{enumerate}
\item Convert to binary: 0x0A100100
\begin{itemize}
  \item = \textcolor{blue}{0000 1010 0001 0000 0000 001}\textcolor{red}{0 0000 0000} (binary)
  \item \textcolor{red}{offset bits} = [phys addr width] - [PFN bits] = 32 - 23 = \textcolor{red}{9} $\rightarrow$ \textcolor{red}{offset} = bits [8:0]
  \item \textcolor{blue}{VPN bits} = [virt addr width] - [offset bits] = 30 - \textcolor{red}{9} = \textcolor{blue}{21} $\rightarrow$ \textcolor{blue}{VPN} = bits [30:9]
\end{itemize}
\pause
\item Calculate PTE address:
\begin{itemize}
  \item \textcolor{blue}{VPN} × \textcolor{green!50!black}{[PTE size]} + PTBR = \textcolor{blue}{VPN} × \textcolor{green!50!black}{4} + PTBR = 0x00201200
\end{itemize}
\pause
\item Read PTE content: 0xC0010094 (little-endian: 0xC0 01 00 94 $\rightarrow$ 0x940100C0)
\begin{itemize}
  \item Valid (bit 31) = 1, PFN (bits [22:0]) = 0x0001C0
\end{itemize}
\pause
\item Physical address = (PFN $\ll$ \textcolor{red}{9}) + \textcolor{red}{offset} = 0x000380A0
\end{enumerate}

\pause
\textbf{Answer:} 2 memory accesses (1 for PTE, 1 for data)
\end{frame}

\begin{frame}{TLB - Translation Lookaside Buffer}
\textbf{Problem:} Virtual memory doubles memory access time (need to access page table first)

\textbf{Solution:} TLB - a cache for recently used PTEs

\begin{columns}
\column{0.7\textwidth}
\textbf{How it works:}
\begin{itemize}
\item Check TLB before accessing page table
\item TLB hit → translation in few clock cycles
\item TLB miss → access page table normally
\item Store page table in regular cache too
\end{itemize}

\column{0.3\textwidth}
\begin{tikzpicture}[scale=0.7]
  \node[draw, rectangle split, rectangle split horizontal, rectangle split parts=2] (vaddr) at (0,4) {
    \nodepart{one} VPN
    \nodepart{two} Offset
  };
  \coordinate (vpn) at ([xshift=-8mm]vaddr.south);
  
  \node[draw, rectangle, fill=correctgreen!30] (tlb) at (-2,2) {TLB};
  \node[draw, rectangle, fill=lightblue!30, align=center, right=4mm of tlb] (pt) {Page\\Table};
  
  \node[draw, rectangle split, rectangle split horizontal, rectangle split parts=2] (paddr) at (0,0) {
    \nodepart{one} PFN
    \nodepart{two} Offset
  };
  \coordinate (pfn) at ([xshift=-8mm]paddr.north);
  
  \draw[->, thick, correctgreen] (vpn) -- (tlb) node[midway, left] {\tiny hit};
  \draw[->, thick, dashed, incorrectred] (vpn) -- (pt) node[midway, right] {\tiny miss};
  \draw[->, thick] (tlb) -- ([xshift=-1mm]pfn);
  \draw[->, thick] (pt) -- ([xshift=1mm]pfn);
\end{tikzpicture}
\end{columns}
\end{frame}

\begin{frame}{Question 2: Cache and Virtual Memory Optimization}
\textbf{Question:} What speedup can be achieved if $q \geq b + c$?

Where:
\begin{itemize}
\item Virtual memory: $2^n$ bytes, page size: $2^q$ bytes
\item Physical memory: $2^m$ bytes
\item Direct-mapped cache: $2^c$ blocks, block size: $2^b$ bytes
\end{itemize}

\textbf{Answer:} If $q \geq b + c$, then page offset contains both set and displacement fields

\begin{center}
\begin{tikzpicture}[scale=0.9]

% Virtual Address
\matrix[matrix of nodes,
        nodes={draw, minimum height=7mm, inner xsep=2mm, anchor=center},
        column sep=-\pgflinewidth,
        row sep=0pt,
        ampersand replacement=\&] (vaddr) {
  |[minimum width=1.8cm]| VPN \&
  |[minimum width=3.2cm]| Page Offset (q bits) \\
};

% Physical Address (cache indexing)
\matrix[matrix of nodes,
        nodes={draw, minimum height=7mm, inner xsep=2mm, anchor=center},
        column sep=-\pgflinewidth,
        row sep=0pt,
        below=1cm of vaddr.south east,
        anchor=north east,
        ampersand replacement=\&] (cache) {
  |[minimum width=1.2cm]| tag \&
  |[minimum width=1.8cm]| set (c bits) \&
  |[minimum width=1.2cm]| disp (b bits) \\
};

% Labels - aligned using |- positioning
\node[anchor=east] (vlabel) at ([xshift=-5mm]vaddr.west) {Virtual:};
\node[anchor=east] at (vlabel.east |- cache) {Physical:};

% Arrow
\draw[<-, thick, correctgreen]
  (vaddr-1-2.south)
  -- (cache-1-3.north -| vaddr-1-2.south)
  node[midway, right, align=center] {contained\\in offset};

\end{tikzpicture}
\end{center}

\textbf{Benefit:} Can access cache in parallel with TLB lookup!
\end{frame}

\section{Summary}

\begin{frame}{Summary}
\begin{itemize}
\item \textbf{Virtual Memory} provides abstraction between logical and physical memory
\item \textbf{Key Benefits:}
\begin{itemize}
  \item Memory larger than physical through swapping
  \item Process isolation and protection
  \item Simplified memory management
  \item Efficient memory sharing
\end{itemize}
\item \textbf{Performance Optimization:}
\begin{itemize}
  \item TLB reduces translation overhead
  \item Clever cache indexing enables parallel access
  \item Page tables can be cached
\end{itemize}
\item \textbf{Trade-offs:}
\begin{itemize}
  \item Extra memory accesses for translation
  \item Page fault handling overhead
  \item Memory needed for page tables
\end{itemize}
\end{itemize}
\end{frame}

\end{document}