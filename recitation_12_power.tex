\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{bytefield}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc}
\usepackage{tcolorbox}
\usetheme{Madrid}
\title{Multithreading and Power}
\author{Computer Architecture 2340267}
\date{2025, Recitation \#12}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction to Execution Models}

\begin{frame}{Scalar Execution}
\begin{itemize}
    \item Sequential execution of instructions
    \item One instruction at a time
    \item Dependencies reduce throughput/utilization
\end{itemize}

\vspace{0.5cm}
\begin{center}
\begin{tikzpicture}[scale=0.8]
    \node at (0,0.5) {Time $\rightarrow$};
    \foreach \x in {0,0.8,1.6,2.4,3.2,4.0,4.8,5.6,6.4} {
        \pgfmathparse{int(mod(\x/0.8,2))}
        \ifnum\pgfmathresult=0
            \fill[red!70] (\x,0) rectangle (\x+0.7,-0.5);
        \else
            \draw (\x,0) rectangle (\x+0.7,-0.5);
        \fi
    }
\end{tikzpicture}
\end{center}

\begin{alertblock}{Key Issue}
Dependencies reduce throughput/utilization
\end{alertblock}
\end{frame}

\begin{frame}{Superscalar Execution}
\begin{itemize}
    \item Multiple instructions per cycle
    \item Out-of-order execution capabilities
    \item Still limited by:
    \begin{itemize}
        \item Dependencies
        \item Cache misses
        \item Branch mispredictions
    \end{itemize}
\end{itemize}

\begin{block}{Impact}
These factors reduce throughput/utilization even in superscalar processors
\end{block}
\end{frame}

\section{Multithreading Approaches}

\begin{frame}{Blocked Multithreading}
\framesubtitle{Switch on Event}

\begin{itemize}
    \item Switch threads when current thread encounters low utilization event
    \item Examples of switching events:
    \begin{itemize}
        \item L2 cache miss
        \item Long latency operations
    \end{itemize}
    \item May increase utilization and throughput
\end{itemize}

\begin{block}{Benefit}
Hides long latency events by switching to another thread
\end{block}
\end{frame}

\begin{frame}{Fine Grained Multithreading}
\begin{itemize}
    \item Switch threads frequently (e.g., every cycle)
    \item Reduces impact of dependencies
    \item Better latency hiding than blocked multithreading
\end{itemize}

\begin{block}{Key Advantage}
Increases utilization/throughput by reducing impact of dependencies
\end{block}
\end{frame}

\begin{frame}{Simultaneous Multithreading (SMT)}
\begin{columns}
\column{0.5\textwidth}
\begin{itemize}
    \item Multiple threads execute simultaneously
    \item Shares execution resources
    \item Best utilization of resources
\end{itemize}

\column{0.5\textwidth}
\begin{block}{Benefits}
\begin{itemize}
    \item Reduces impact of dependencies
    \item Hides cache misses
    \item Masks branch mispredictions
\end{itemize}
\end{block}
\end{columns}

\vspace{0.5cm}
\begin{center}
\textbf{Pipeline:} In-order fetch/decode/rename $\rightarrow$ Out-Of-Order Execution $\rightarrow$ In-order Retire
\end{center}
\end{frame}

\section{Performance Analysis}

\subsection{Question 1: Switch-on-Event Analysis}

\begin{frame}{Q1: Switch-on-Event Analysis}
\begin{columns}
\column{0.5\textwidth}
\textbf{Given Parameters:}
\begin{itemize}
    \item M instructions execute with cache access
    \item Cache miss takes Q cycles
    \item Thread switch on cache miss (event)
    \item $CPI_{ideal}$ when Thread 0 runs
    \item N threads available
\end{itemize}

\column{0.5\textwidth}
\textbf{Analysis:}
\begin{itemize}
    \item Each memory access: Q cycles
    \item Memory access every M instructions
    \item Context switch overhead considered
\end{itemize}
\end{columns}
\end{frame}

\begin{frame}{Q1a: IPC Equation Development}
\textbf{Question:} Develop an equation for IPC as a function of running threads (N)

\vspace{3mm}

\begin{block}{CPI per Thread}
$$CPI_{Thread} = CPI_i + \frac{Q}{M}$$
\end{block}

Where:
\begin{itemize}
    \item $CPI_i$ = ideal CPI
    \item Q = memory access cycles
    \item M = instructions between memory accesses
\end{itemize}

\begin{alertblock}{IPC Formula}
$$IPC = \frac{N}{CPI_i + \frac{Q}{M}}$$
\end{alertblock}
\end{frame}

\begin{frame}{Q1b: Best Achievable Performance}
\textbf{Question:} What is the best achievable performance?

\vspace{3mm}

\textbf{Maximum IPC when memory latencies are fully hidden:}
\begin{itemize}
    \item Achieved when: No memory accesses OR all latencies masked by other threads
\end{itemize}

\begin{alertblock}{Maximum IPC}
$$IPC_{Max} = IPC_{ideal}$$
\end{alertblock}
\end{frame}

\begin{frame}{Q1c: Minimum Threads for Maximum Performance}
\textbf{Question:} How many threads are needed to achieve maximum performance?

\vspace{3mm}

Starting from the IPC equation:
\vspace{-8mm}
$$IPC = \frac{N}{CPI_i + \frac{Q}{M}}$$

For maximum performance, $IPC = IPC_{ideal} = \frac{1}{CPI_i}$:
$$\frac{1}{CPI_i} = \frac{N1}{CPI_i + \frac{Q}{M}}$$

Solving for $N1$:
\vspace{-3mm}
$$CPI_i + \frac{Q}{M} = N1 \cdot CPI_i$$

\begin{alertblock}{Minimum Threads}
$$N1 = 1 + \frac{Q}{M \cdot CPI_i}$$
\end{alertblock}
\end{frame}

\subsection{Question 2: IPC vs Number of Threads}

\begin{frame}{Q2: IPC vs Number of Threads}
\textbf{Question:} Draw a graph of IPC as a function of number of threads (N)

\pause
\begin{center}
\begin{tikzpicture}[scale=0.8]
    \draw[->] (0,0) -- (8,0) node[right] {N = Threads};
    \draw[->] (0,0) -- (0,4.5) node[above] {IPC};
    
    % Draw roofline (not curve)
    \draw[thick, blue] (0,0) -- (3,3.5);
    \draw[thick, blue] (3,3.5) -- (7.5,3.5);
    
    % Mark key points
    \draw[dashed] (3,0) -- (3,3.5) node[pos=0, below] {$N_1$};
    \draw[dashed] (0,3.5) -- (3,3.5) node[pos=0, left] {$IPC_{Max}$};
    
    % Equation annotation
    \node at (5.5,2) {$IPC = \frac{N}{CPI_i + \frac{Q}{M}}$};
\end{tikzpicture}
\end{center}
\end{frame}

\section{Cache Impact}

\subsection{Question 3: Cache Analysis}

\begin{frame}{Q3a: L1 Cache Addition}
\textbf{Improvement Proposal:} Add L1 cache with 0 cycles access time

\begin{block}{Modified IPC with Cache}
$$IPC = \frac{N}{CPI_i + k \cdot \frac{Q}{M}} \quad \text{where } k = \text{miss rate (k = 1} \rightarrow \text{100\% miss rate)}$$
\end{block}

\textbf{Question:} What cache hit rate provides maximum performance with $N_1/2$ threads?
\begin{align*}
IPC_{Max} &= IPC_{ideal} & \Rightarrow N_1 = 1 + \frac{Q}{M \cdot CPI_i} \quad \Rightarrow \quad \frac{N_1}{2} = \frac{1 + \frac{Q}{M \cdot CPI_i}}{2}
\end{align*}

Solve: $IPC\Big|_{N=\frac{N_1}{2}} = \left(CPI_i + k \cdot \frac{Q}{M}\right)^{-1} \cdot \frac{1}{2} \cdot CPI_i^{-1} = CPI_i^{-1}$

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black]
$$CPI\left(\frac{N_1}{2}\right) = \left(CPI_i + Q \cdot \frac{k}{M}\right) \cdot \frac{2 \cdot M \cdot CPI_i}{M \cdot CPI_i + Q} = CPI_i$$
\end{tcolorbox}

\alert{Result: $k = 0.5$ (50\% miss rate) $\Rightarrow$ 50\% hit rate required}
\end{frame}

\begin{frame}{Q3b: Cache Design Impact}
\textbf{How will cache addition affect the CPU?}

\begin{columns}
\column{0.30\textwidth}
\begin{block}{Area}
\textcolor{red}{Increase} \\
Cache requires silicon area
\end{block}

\column{0.30\textwidth}
\begin{block}{Power}
\textcolor{green}{Decrease} \\
(with sufficient hit rate)
\end{block}

\column{0.33\textwidth}
\begin{block}{Complexity}
\textcolor{red}{Increase} \\
Cache control logic needed
\end{block}
\end{columns}

\vspace{0.5cm}
\begin{itemize}
    \item Might allow CPU redesign with fewer threads if hit rate is high enough
\end{itemize}
\end{frame}


\section{Power/Performance Trade-offs}

\subsection{Question 4: Power/Performance Analysis}

\begin{frame}{Q4a: Single Thread Performance}
\textbf{Question:} Which processor provides best single-thread performance at 4W?

\begin{columns}[t]
\column{0.48\textwidth}
\textbf{Two Processor Options:}
\vspace{-2mm}
\begin{table}
\centering
\scriptsize
\begin{tabular}{lcc}
\toprule
Parameter & Small & Large \\
\midrule
Area & 2 mm² & 4 mm² \\
Width & 2-wide & 4-wide \\
IPC & 1 & 2 \\
Leakage & 0.5W & \textcolor{red}{\textbf{?}} \\
Cap. & 500 pF & 1500 pF \\
Threads & 1 & 1 \\
\bottomrule
\end{tabular}
\end{table}

\column{0.48\textwidth}
\textbf{Voltage-Frequency Points:}
\vspace{-2mm}
\begin{table}
\centering
\scriptsize
\begin{tabular}{ccc}
\toprule
V (V) & Large & Small \\
\midrule
0.6 & 0.7 & 1.0 \\
0.65 & 1.0 & 1.25 \\
0.7 & 1.35 & 1.5 \\
0.75 & 1.75 & 1.75 \\
0.8 & 2.25 & 2.0 \\
0.85 & 2.5 & 2.25 \\
0.9 & 3.0 & 2.5 \\
0.95 & 3.5 & 2.75 \\
1.0 & 4.0 & 3.0 \\
\bottomrule
\end{tabular}
\end{table}
\end{columns}

\begin{block}{Key Assumption}
Leakage is approximately proportional to area
\end{block}
\end{frame}

\begin{frame}{Q4a: Leakage Power Calculation}
\textbf{Question:} Which processor provides best single-thread performance at 4W?

\textbf{First, we compute the leakage power for the large core:}

\begin{columns}
\column{0.5\textwidth}
\begin{table}
\centering
\small
\begin{tabular}{lcc}
\toprule
Parameter & Small & Large \\
\midrule
\rowcolor{yellow!30} Area & 2 mm² & 4 mm² \\
Width & 2-wide & 4-wide \\
IPC & 1 & 2 \\
\rowcolor{yellow!30} Leakage & 0.5W & \textcolor{red}{\textbf{?}} \\
Cap. & 500 pF & 1500 pF \\
Threads & 1 & 1 \\
\bottomrule
\end{tabular}
\end{table}

\column{0.5\textwidth}
\begin{alertblock}{General Formula}
$$\text{Leakage} \propto \text{Area}$$
\end{alertblock}

\textbf{For this question:}
$$\text{Leakage}_{\text{large}} = \frac{\text{area}_{\text{large}}}{\text{area}_{\text{small}}} \times \text{Leakage}_{\text{small}}$$

$$= \frac{4\text{ mm}^2}{2\text{ mm}^2} \times 0.5\text{W} = 1\text{W}$$
\end{columns}
\end{frame}

\begin{frame}{Q4a: Frequency Calculation (4W Budget)}
\textbf{Second, we compute the maximum frequency given the 4W power budget:}

\begin{columns}[t]
\column{0.35\textwidth}
\vspace{-3mm}
\begin{table}
\centering
\tiny
\begin{tabular}{lcc}
\toprule
Parameter & Small & Large \\
\midrule
Leakage & \cellcolor{yellow!40}0.5W & \cellcolor{green!25}1W \\
Cap. & \cellcolor{yellow!60!orange!40}500 pF & \cellcolor{green!40!cyan!30}1500 pF \\
\bottomrule
\end{tabular}
\end{table}

\vspace{1mm}

{\centering\tiny\textbf{Voltage-Frequency (GHz):}\par}
\vspace{0mm}

\begin{table}
\centering
\tiny
\begin{tabular}{ccc}
\toprule
V (V) & Small & Large \\
\midrule
0.6 & 1.0 & 0.7 \\
0.65 & 1.25 & 1.0 \\
0.7 & 1.5 & 1.35 \\
0.75 & 1.75 & 1.75 \\
0.8 & 2.0 & 2.25 \\
\cellcolor{cyan!35}0.85 & 2.25 & \cellcolor{cyan!50}2.5 \\
0.9 & 2.5 & 3.0 \\
0.95 & 2.75 & 3.5 \\
\cellcolor{orange!40}1.0 & \cellcolor{orange!60}3.0 & 4.0 \\
\bottomrule
\end{tabular}
\end{table}

\column{0.65\textwidth}
\vspace{-3mm}
\begin{alertblock}{Power Equation}
$$P = \text{Leakage} + C \cdot V^2 \cdot f$$
\end{alertblock}

\textbf{Small core:}
$4W \geq \colorbox{yellow!40}{0.5W} + \colorbox{yellow!60!orange!40}{500\text{pF}} \cdot V^2 \cdot f$\par
From table: $V = \colorbox{orange!40}{1\text{V}}$, $f = \colorbox{orange!60}{3\text{GHz}}$\par
\vspace{-4mm}
$$P = \colorbox{yellow!40}{0.5} + \colorbox{yellow!60!orange!40}{500} \cdot \colorbox{orange!40}{1}^2 \cdot \colorbox{orange!60}{3} = 2\text{W} < 4\text{W} \checkmark$$

\textbf{Large core:}
$4W \geq \colorbox{green!25}{1W} + \colorbox{green!40!cyan!30}{1500\text{pF}} \cdot V^2 \cdot f$\par
From table: $V = \colorbox{cyan!35}{0.85\text{V}}$, $f = \colorbox{cyan!50}{2.5\text{GHz}}$\par
\vspace{-4mm}
$$P = \colorbox{green!25}{1} + \colorbox{green!40!cyan!30}{1500} \cdot \colorbox{cyan!35}{0.85}^2 \cdot \colorbox{cyan!50}{2.5} = 3.7\text{W} < 4\text{W} \checkmark$$
\end{columns}
\end{frame}

\begin{frame}{Q4a: Performance Comparison}
\textbf{Finally, we compare the performance:}

\begin{block}{Performance Metric}
$$\text{Performance} \propto \text{IPC} \times \text{Frequency}$$
\end{block}

\textbf{Given:} Small core IPC = 1, Large core IPC = 2

\textbf{Results:}
\begin{itemize}
    \item \textbf{Small core:} IPC = 1, Frequency = 3 GHz
    $$\text{Performance} = 1 \times 3 = 3 \text{ G inst/sec}$$

    \item \textbf{Large core:} IPC = 2, Frequency = 2.5 GHz
    $$\text{Performance} = 2 \times 2.5 = 5 \text{ G inst/sec}$$
\end{itemize}

\alert{Result: Large core provides better performance (5 vs 3 G inst/sec)}
\end{frame}

\begin{frame}{Q4b: Multi-Thread Performance}
\textbf{Question:} Given a 2W power budget per core, which configuration provides best 2-way Multi-Thread performance: two large cores or two small cores?

\pause

\vspace{5mm}

\textbf{Approach:}
\begin{itemize}
    \item Calculate power consumption for different voltage-frequency points
    \item Find maximum frequencies that fit within 2W budget
    \item Compare performance of configurations
\end{itemize}
\end{frame}

\begin{frame}{Q4b: Voltage-Frequency Analysis}
\textbf{Question:} Given a 2W power budget per core, which configuration provides best 2-way Multi-Thread performance: two large cores or two small cores?

\vspace{3mm}

\begin{columns}[t]
\column{0.3\textwidth}
\scriptsize
\begin{tabular}{|c|c|c|}
\hline
\makecell{Voltage \\ (V)} &
\makecell{Freq \\ Small \\ Core \\ (GHz)} &
\makecell{Freq \\ Large \\ Core \\ (GHz)} \\
\hline
0.6 & 1 & 0.7 \\
0.65 & 1.25 & 1 \\
0.7 & 1.5 & 1.35 \\
0.75 & 1.75 & 1.75 \\
0.8 & 2 & 2.25 \\
0.85 & 2.25 & 2.5 \\
0.9 & 2.5 & 3 \\
0.95 & 2.75 & 3.5 \\
1 & 3 & 4 \\
\hline
\end{tabular}

\column{0.7\textwidth}

\vspace{-2.4cm}
\textbf{Given:}
\begin{itemize}
    \item Voltage-frequency points for each core type
    \item Small core: Leakage = 0.5W, C = 500 pF
    \item Large core: Leakage = 1W, C = 1500 pF
\end{itemize}

\vspace{3mm}

Considering the voltage-frequency relationship, we can calculate:
$$P_{act} = C \cdot V^2 \cdot f$$
$$P_{tot} = P_{act} + \text{Leakage}$$
\end{columns}
\end{frame}

\begin{frame}{Q4b: Power Table Analysis (2W per Core)}
\textbf{Question:} Given a 2W power budget per core (and the table below), which configuration provides best 2-way Multi-Thread performance: two large cores or two small cores?
\vspace{3mm}
\begin{columns}[t]
\column{0.57\textwidth}
\scriptsize
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\makecell{Voltage \\ (V)} &
\makecell{Freq \\ Small \\ Core \\ (GHz)} &
\makecell{Freq \\ Large \\ Core \\ (GHz)} &
\makecell{$P_{act}$ \\ Small \\ Core \\ (W)} &
\makecell{$P_{act}$ \\ Large \\ Core \\ (W)} &
\makecell{$P_{tot}$ \\ Small \\ Core \\ (W)} &
\makecell{$P_{tot}$ \\ Large \\ Core \\ (W)} \\
\hline
0.6 & 1 & 0.7 & 0.18 & 0.38 & 0.68 & 1.38 \\
0.65 & 1.25 & 1 & 0.26 & 0.63 & 0.76 & 1.63 \\
0.7 & 1.5 & \only<2->{\cellcolor{cyan!40}}1.35 & 0.37 & 0.99 & 0.87 & \only<2->{\cellcolor{green!40}}1.99 \\
0.75 & 1.75 & 1.75 & 0.49 & 1.48 & 0.99 & 2.48 \\
0.8 & 2 & 2.25 & 0.64 & 2.16 & 1.14 & 3.16 \\
0.85 & 2.25 & 2.5 & 0.81 & 2.71 & 1.31 & 3.71 \\
0.9 & 2.5 & 3 & 1.01 & 3.65 & 1.51 & 4.65 \\
0.95 & 2.75 & 3.5 & 1.24 & 4.74 & 1.74 & 5.74 \\
1 & \only<2->{\cellcolor{yellow!50}}3 & 4 & 1.50 & 6.00 & \only<2->{\cellcolor{orange!50}}2.00 & 7.00 \\
\hline
\end{tabular}

\column{0.43\textwidth}

\vspace{-2.4cm}
\textbf{Answer:}

\vspace{2mm}

First, find $P_{act}$ and $P_{tot}$ based on the known leakage:

\vspace{1mm}

$P_{act} = C \cdot V^2 \cdot f$ \\
$P_{tot} = P_{act} + \text{Leakage}$

\pause

Then, find frequencies that fit within the 2W power budget per core:

\pause

\textbf{Small cores:} \colorbox{yellow!50}{3} GHz (\colorbox{orange!50}{2}W) \\
\textbf{Large cores:} \colorbox{cyan!40}{1.35} GHz (\colorbox{green!40}{1.99}W)
\end{columns}
\end{frame}

\begin{frame}{Q4b: Performance Calculation}
\textbf{Question:} Given a 2W power budget per core, which configuration provides best 2-way Multi-Thread performance: two large cores or two small cores?

\vspace{5mm}

\begin{block}{Performance Formula}
$$\text{Performance} = N \times F \times \text{IPC}$$
where $N$ = number of cores, $F$ = frequency, IPC = instructions per cycle
\end{block}

\vspace{5mm}

\textbf{Two Small cores:} $\text{Performance} = 2 \times 3\text{ GHz} \times 1 = 6 \text{ G inst/sec}$

\textbf{Two Large cores:} $\text{Performance} = 2 \times 1.35\text{ GHz} \times 2 = 5.4 \text{ G inst/sec}$

\vspace{5mm}

\alert{Result: Two small cores provide better performance (6 vs 5.4 G inst/sec)}
\end{frame}

\begin{frame}{Power Curve Characteristics}
\begin{columns}
\column{0.45\textwidth}
\begin{tikzpicture}[scale=0.8]
    \draw[->] (0,0) -- (6,0) node[right] {Freq};
    \draw[->] (0,0) -- (0,5) node[above] {Power};

    % Draw power curve - orange, steeper cubic relationship
    \draw[thick, orange!80!red, line width=1.2pt] (0.5,0.5) .. controls (1.2,0.6) and (2,0.9) .. (5.5,4.5);

    % Mark points from bottom to top
    \node[circle,fill=black,inner sep=3pt,label=left:$P_n$] at (1,0.6) {};
    \node[circle,fill=black,inner sep=3pt,label=left:$P_2$] at (2.5,1.2) {};
    \node[circle,fill=black,inner sep=3pt,label=left:$P_1$] at (3.8,2.5) {};
    \node[circle,fill=black,inner sep=3pt,label=left:$P_0$] at (5,4.2) {};

    % Arrow and annotation for P1 to P0
    \draw[<->,blue,thick] (3.8,2.5) -- (5,4.2);
    \node[right,align=left,font=\scriptsize] at (5.2,3.3) {$\sim$3X};
\end{tikzpicture}

\column{0.55\textwidth}
\textbf{At $P_n$ ($V_{min}$ = Energy efficient point):}
\begin{itemize}\small
    \item Freq decrease doesn't decrease V: $P \propto K \cdot F$
    \item Freq decrease by 1\% decreases power by 1\%
    \item Perf. features better than 1:1
\end{itemize}

\vspace{0.3cm}
\textbf{At $P_2$ (mid-range):}
\begin{itemize}\small
    \item Perf. features better than 1:3
    \item (1\% perf / less than 3\% power)
\end{itemize}

\vspace{0.3cm}
\textbf{Key relationships:}
\begin{itemize}\small
    \item $P = CV^2f$; $f = KV \Rightarrow P \propto f^3$
    \item $E = P \times t \Rightarrow E \propto f^2$
\end{itemize}
\end{columns}
\end{frame}

\begin{frame}{Summary}
\begin{itemize}
    \item \textbf{Multithreading} improves processor utilization
    \item \textbf{SMT} provides best resource utilization
    \item \textbf{IPC} increases with thread count up to saturation
    \item \textbf{Cache} can reduce required thread count
    \item \textbf{Power/Performance} trade-offs depend on workload:
    \begin{itemize}
        \item Single-thread: Large cores often better
        \item Multi-thread: Small cores can be more efficient
    \end{itemize}
    \item \textbf{Energy efficiency} achieved at moderate frequencies
\end{itemize}
\end{frame}

\end{document}