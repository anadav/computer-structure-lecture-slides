\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{bytefield}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, patterns, fit, circuits.logic.US, matrix, backgrounds}
\usepackage{circuitikz}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{arydshln}
\usetheme{Madrid}

% Define blocksize length once globally
\newlength{\blocksize}
\setlength{\blocksize}{0.3cm}

% Define TikZ styles for cache diagrams
\tikzset{
    writeblock/.style={draw, thick, minimum width=\blocksize, minimum height=\blocksize, pattern=grid, pattern color=#1},
    writeblock/.default=blue
}

\newcommand{\addressbreakdown}[3]{%
    \begin{tikzpicture}[
        section/.style={draw, very thick, minimum height=0.6cm},
        bitnumber/.style={font=\tiny},
        sectionlabel/.style={font=\scriptsize},
        baseline=(current bounding box.center)
    ]
    % Calculate total bits and positions
    \pgfmathtruncatemacro{\totalbits}{#1 + #2 + #3}
    \pgfmathtruncatemacro{\tagstart}{\totalbits - 1}
    \pgfmathtruncatemacro{\tagend}{\totalbits - #1}
    \pgfmathtruncatemacro{\setstart}{\tagend - 1}
    \pgfmathtruncatemacro{\setend}{\tagend - #2}
    \pgfmathtruncatemacro{\offsetstart}{\setend - 1}
    \pgfmathtruncatemacro{\offsetend}{0}
    
    % Scale factor for width (adjust this to change overall size)
    \pgfmathsetmacro{\bitwidth}{0.17}
    
    % Starting position
    \pgfmathsetmacro{\xpos}{0}
    
    % Draw tag block
    \ifnum#1>0
        \pgfmathsetmacro{\tagwidth}{#1 * \bitwidth}
        \node[section, fill=blue!40, minimum width=\tagwidth cm] (tag) at (\xpos + \tagwidth/2, 0) {};
        \node[sectionlabel] at (tag.center) {tag};
        
        % Add bit numbers below
        \node[bitnumber] at ($(tag.south west) + (0mm,-1mm)$) {\tagstart};
        \node[bitnumber] at ($(tag.south east) + (-1mm,-1mm)$) {\tagend};
        
        \pgfmathsetmacro{\xpos}{\xpos + \tagwidth}
    \fi
    
    % Draw set block
    \ifnum#2>0
        \pgfmathsetmacro{\setwidth}{#2 * \bitwidth}
        \node[section, fill=green!40, minimum width=\setwidth cm] (set) at (\xpos + \setwidth/2, 0) {};
        % if num is smaller thean 2 rotate label
        \ifnum#2<3
            \node[sectionlabel, rotate=90] at (set.center) {set};
        \else
            \node[sectionlabel] at (set.center) {set};
        \fi

        % Add bit numbers below
        \node[bitnumber] at ($(set.south west) + (1mm,-1mm)$) {\setstart};
        \node[bitnumber] at ($(set.south east) + (-1mm,-1mm)$) {\setend};

        \pgfmathsetmacro{\xpos}{\xpos + \setwidth}
    \fi

    % Draw offset block
    \ifnum#3>0
        \pgfmathsetmacro{\offsetwidth}{#3 * \bitwidth}
        \node[section, fill=yellow!40, minimum width=\offsetwidth cm] (offset) at (\xpos + \offsetwidth/2, 0) {};
        \ifnum#3<3
            \node[sectionlabel, rotate=90, font=\tiny] at (offset.center) {offset};
        \else
            \node[sectionlabel] at (offset.center) {offset};
        \fi

        % Add bit numbers below - fix for when set bits = 0
        \ifnum#2>0
            \node[bitnumber] at ($(offset.south west) + (1mm,-1mm)$) {\offsetstart};
        \else
            % When no set bits, offset starts directly after tag
            \pgfmathtruncatemacro{\offsetstartalt}{\tagend - 1}
            \node[bitnumber] at ($(offset.south west) + (1mm,-1mm)$) {\offsetstartalt};
        \fi
        \node[bitnumber] at ($(offset.south east) + (0mm,-1mm)$) {\offsetend};
    \fi
    \end{tikzpicture}
}

% Alternative version with bit counts shown instead of labels
\newcommand{\addressbreakdownbits}[3]{%
    \begin{tikzpicture}[
        section/.style={draw, very thick, minimum height=0.8cm},
        bitnumber/.style={font=\tiny},
        bitcount/.style={font=\footnotesize},
        baseline=(current bounding box.center)
    ]
    % Calculate total bits and positions
    \pgfmathtruncatemacro{\totalbits}{#1 + #2 + #3}
    \pgfmathtruncatemacro{\tagstart}{\totalbits - 1}
    \pgfmathtruncatemacro{\tagend}{\totalbits - #1}
    \pgfmathtruncatemacro{\setstart}{\tagend - 1}
    \pgfmathtruncatemacro{\setend}{\tagend - #2}
    \pgfmathtruncatemacro{\offsetstart}{\setend - 1}
    \pgfmathtruncatemacro{\offsetend}{0}
    
    % Scale factor for width
    \pgfmathsetmacro{\bitwidth}{0.15}
    
    % Starting position
    \pgfmathsetmacro{\xpos}{0}
    
    % Draw tag block
    \ifnum#1>0
        \pgfmathsetmacro{\tagwidth}{#1 * \bitwidth}
        \node[section, fill=blue!40, minimum width=\tagwidth cm] (tag) at (\xpos + \tagwidth/2, 0) {};
        \node[bitcount] at (tag.center) {#1};
        
        % Add bit range below
        \node[bitnumber, below=2pt] at (tag.south) {\tagstart:\tagend};
        
        \pgfmathsetmacro{\xpos}{\xpos + \tagwidth}
    \fi
    
    % Draw set block
    \ifnum#2>0
        \pgfmathsetmacro{\setwidth}{#2 * \bitwidth}
        \node[section, fill=green!40, minimum width=\setwidth cm] (set) at (\xpos + \setwidth/2, 0) {};
        \node[bitcount] at (set.center) {#2};

        % Add bit range below
        \node[bitnumber, below=2pt] at (set.south) {\setstart:\setend};

        \pgfmathsetmacro{\xpos}{\xpos + \setwidth}
    \fi

    % Draw offset block
    \ifnum#3>0
        \pgfmathsetmacro{\offsetwidth}{#3 * \bitwidth}
        \node[section, fill=yellow!40, minimum width=\offsetwidth cm] (offset) at (\xpos + \offsetwidth/2, 0) {};
        \node[bitcount] at (offset.center) {#3};

        % Add bit range below - fix for when set bits = 0
        \ifnum#2>0
            \node[bitnumber, below=2pt] at (offset.south) {\offsetstart:\offsetend};
        \else
            % When no set bits, offset range is directly after tag
            \pgfmathtruncatemacro{\offsetstartalt}{\tagend - 1}
            \node[bitnumber, below=2pt] at (offset.south) {\offsetstartalt:\offsetend};
        \fi
    \fi

    % Add labels above
    \ifnum#1>0
        \node[font=\footnotesize, above=2pt] at (tag.north) {Tag};
    \fi
    \ifnum#2>0
        \node[font=\footnotesize, above=2pt] at (set.north) {Set};
    \fi
    \ifnum#3>0
        \node[font=\footnotesize, above=2pt] at (offset.north) {Offset};
    \fi
    \end{tikzpicture}
}

\title{Cache Memory I}
\author{Computer Architecture 2360267}
\date{2025, Recitation \#3}

\begin{document}

\frame{\titlepage}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction}
\begin{frame}{The Problem}
\begin{itemize}
    \item Memory access speed is slow relative to processor performance (up to 1000x slower)
    \item The larger the memory, the slower the access
    \item Processor performance suffers significantly if we need to wait many clock cycles for each memory read
\end{itemize}
\end{frame}

\begin{frame}{The Solution}
\begin{center}
\textbf{Cache Memory}
\end{center}
\begin{itemize}
    \item Maintain a partial copy of memory "close" to the processor
    \item Access time is significantly shorter
    \item Exploits locality principles in programs
\end{itemize}
\end{frame}

\section{Locality Principles}
\begin{frame}{Why Does Cache Work?}
\begin{block}{Temporal Locality}
\begin{itemize}
    \item If we access an object, we're likely to access it again soon
    \item We spend 90\% of time in 10\% of code (loops)
    \item Certain variables are updated repeatedly
\end{itemize}
\end{block}

\begin{block}{Spatial Locality}
\begin{itemize}
    \item If we access an object, we're likely to access nearby objects
    \item Code segments: next instruction is likely needed
    \item Data: array elements are accessed sequentially
\end{itemize}
\end{block}

\textbf{Amdahl's Law Reminder:} Optimize what happens most of the time!
\end{frame}

\section{Cache Terminology}
\begin{frame}{Basic Terminology}
\begin{itemize}
    \item \textbf{Hit:} Data appears at the memory level
    \item \textbf{Miss:} Data doesn't appear at memory level, must fetch from lower level
    \item \textbf{Hit Rate:} Percentage of hits out of total memory accesses
    \item \textbf{Miss Rate:} $1 - \text{Hit Rate}$
    \item \textbf{Block:} Main memory is divided into blocks of several bytes. When copying a byte to cache, we copy the entire block
\end{itemize}
\end{frame}

\section{Cache Organizations}
\begin{frame}{Fully Associative Organization}
\begin{columns}
\column{0.5\textwidth}
\begin{itemize}
    \item Any block can map to any cache line
    \item Address divided into:
    \begin{itemize}
        \item Tag (block number)
        \item Offset (position within block)
    \end{itemize}
    \item Parallel comparison with all tags
\end{itemize}

\column{0.5\textwidth}
\begin{tcolorbox}[colback=gray!10]
\textbf{Address Fields:}\\
\begin{center}
    \begin{tikzpicture}[
        section/.style={draw, very thick, minimum height=0.6cm},
        bitnumber/.style={font=\tiny},
        sectionlabel/.style={font=\scriptsize},
        baseline=(current bounding box.center)
    ]
    % Tag block (27 bits)
    \node[section, fill=blue!40, minimum width=4.59cm] (tag) at (2.295, 0) {};
    \node[sectionlabel] at (tag.center) {tag};
    \node[bitnumber] at ($(tag.south west) + (0mm,-1mm)$) {31};
    \node[bitnumber] at ($(tag.south east) + (-1mm,-1mm)$) {5};

    % Offset block (5 bits)
    \node[section, fill=yellow!40, minimum width=0.85cm] (offset) at (5.015, 0) {};
    \node[sectionlabel] at (offset.center) {offset};
    \node[bitnumber] at ($(offset.south west) + (1mm,-1mm)$) {4};
    \node[bitnumber] at ($(offset.south east) + (0mm,-1mm)$) {0};

    % Block number arrow above tag
    \draw[<->, thick] ([yshift=2mm]tag.north west) -- ([yshift=2mm]tag.north east)
        node[midway, above, font=\scriptsize] {block number};
    \end{tikzpicture}
\end{center}
\end{tcolorbox}

\textbf{Advantage:} High hit rate\\
\textbf{Disadvantage:} Expensive parallel comparison
\end{columns}
\end{frame}

\begin{frame}{Fully Associative Cache - Structure}
\centering
\begin{tikzpicture}[
    tagbox/.style={draw, thick, minimum width=1.5cm, minimum height=0.4cm, fill=green!20},
    databox/.style={draw, thick, minimum width=3.5cm, minimum height=0.4cm, fill=white},
    offsetbox/.style={draw, thick, minimum width=0.6cm, minimum height=0.4cm, fill=orange!20},
    label/.style={font=\small},
    biglabel/.style={font=\bfseries},
    data_connector/.style={circle, fill, inner sep=1.2pt},
    node distance=0cm
]

% Address breakdown at top
\node[draw, thick, fill=green!20, minimum width=5.5cm, minimum height=0.7cm, font=\small] (tag_field) {Tag = Block\#};
\node[label, font=\small, above=1mm of tag_field] (addr_title) {Address Fields};
\node[draw, thick, fill=orange!20, minimum width=1.2cm, minimum height=0.7cm, anchor=west, font=\small] (offset_field) at (tag_field.east) {Line Offset};
\node[label, font=\tiny, above] at (tag_field.north west) {31};
\node[label, font=\tiny, above] at (offset_field.west |- tag_field.north) {4};
\node[label, font=\tiny, above] at (offset_field.north east) {0};

% Labels for columns
\node[label, below=0.4cm of tag_field.south, xshift=0.5cm] (tag_array_label) {Tag Array};
\node[label, below=0.4cm of offset_field.south, xshift=2cm] (data_array_label) {Data Array};

% Create arrays using loops
\foreach \i in {0,...,7} {
    % Tag array - adjacent boxes (no space)
    \ifnum\i=0
        \node[tagbox, below=0cm of tag_array_label] (tag\i) {};
        \node[label, font=\tiny] at (tag\i.center) {Tag};
    \else
        \pgfmathtruncatemacro{\prev}{\i-1}
        \node[tagbox, below=0cm of tag\prev] (tag\i) {};
    \fi

    % Comparators using muxdemux - anchored at lpin 2 relative to tag
    \node[muxdemux, muxdemux def={Lh=0.6, Rh=0.3, NL=2, NB=1, w=0.5},
          external pins width=0, fill=cyan!20, anchor=lpin 2] (comp\i) at ([xshift=0.8cm]tag\i.east) {};
    % Add "=" inside comparator
    \node[font=\fontsize{4}{4}\selectfont] at (comp\i.center) {=};

    % Data array
    \node[databox, right=1.2cm of comp\i] (data\i) {};
}

\node[label, font=\tiny] at (data0.west) [anchor=west, xshift=1mm] {Line};
% Orange box only on first line
\node[offsetbox, anchor=west] at ([xshift=1cm]data0.west) (thedata) {};

% Tag input vertical line
\coordinate (tag_input_top) at ([xshift=-0.5cm]comp3.west);

% Connect tag input to all comparators
\foreach \i in {0,...,7} {
    \draw[->, >=stealth, thick] ([xshift=3mm]tag_field.south -| tag1.east) -- ([xshift=3mm]tag\i.east |- comp\i.lpin 1) node[data_connector] {}  -- (comp\i.lpin 1);
}

\draw[->, >=stealth, thick] (offset_field.south) -- (thedata.north);

% Connect arrays using loops
\foreach \i in {0,...,7} {
    % Tag to comparator (other input)
    \draw[->, >=stealth, thick] (tag\i.east) -- (comp\i.lpin 2);
    % Comparator to data
    \draw[->, >=stealth, thick] (comp\i.rpin 1) -- (data\i.west);
}

% OR gate for hit/miss
\node[or port, number inputs=8, anchor=north, external pins width=0, fill=cyan!20,
      xscale=0.7, yscale=0.3, rotate=-90, below right=0.5cm and 0.6cm of comp7.south, anchor=out] (or_gate) {};

% Connect comparators to OR gate
\foreach \i in {0,...,7} {
    \draw[->, >=stealth, thick] (comp\i.rpin 1) -- (comp\i.rpin 1 -| or_gate.bin \the\numexpr\i+1\relax) node[data_connector] {} -- (or_gate.bin \the\numexpr\i+1\relax);
}

% Hit/Miss output
\node[label, below=0.5cm of or_gate.bout, font=\bfseries] (hit_miss) {Hit/Miss};
\draw[->, >=stealth, thick] (or_gate.bout) -- (hit_miss.north);

% Data output
\node[label, font=\bfseries, anchor=north] (data_out) at (data7.south |- hit_miss.north east) {Data};
\draw[->, >=stealth, thick] (data7.south) -- (data_out.north);

% Bit labels at bottom
\node[label, font=\tiny] at ([yshift=-2mm]data7.south west) {31};
\node[label, font=\tiny] at ([yshift=-2mm]data7.south east) {0};

\end{tikzpicture}
\end{frame}

\begin{frame}{Direct Mapping Organization}
\begin{columns}
\column{0.5\textwidth}
\begin{itemize}
    \item Each block maps to exactly one cache location
    \item Address divided into:
    \begin{itemize}
        \item Tag (identifier)
        \item Set\# (cache location)
        \item Offset (position within block)
    \end{itemize}
    \item Simple indexing - no search needed
    \item No eviction policy needed
\end{itemize}

\column{0.5\textwidth}
\begin{tcolorbox}[colback=gray!10]
\textbf{Address Fields:}\\
\begin{center}
    \begin{tikzpicture}[
        section/.style={draw, very thick, minimum height=0.6cm},
        bitnumber/.style={font=\tiny},
        sectionlabel/.style={font=\scriptsize},
        baseline=(current bounding box.center)
    ]
    % Tag block (24 bits)
    \node[section, fill=blue!40, minimum width=4.08cm] (tag) at (2.04, 0) {};
    \node[sectionlabel] at (tag.center) {tag};
    \node[bitnumber] at ($(tag.south west) + (0mm,-1mm)$) {31};
    \node[bitnumber] at ($(tag.south east) + (-1mm,-1mm)$) {8};

    % Set block (3 bits)
    \node[section, fill=green!40, minimum width=0.51cm] (set) at (4.335, 0) {};
    \node[sectionlabel, rotate=90] at (set.center) {set};
    \node[bitnumber] at ($(set.south west) + (1mm,-1mm)$) {7};
    \node[bitnumber] at ($(set.south east) + (-1mm,-1mm)$) {5};

    % Offset block (5 bits)
    \node[section, fill=yellow!40, minimum width=0.85cm] (offset) at (5.015, 0) {};
    \node[sectionlabel] at (offset.center) {offset};
    \node[bitnumber] at ($(offset.south west) + (1mm,-1mm)$) {4};
    \node[bitnumber] at ($(offset.south east) + (0mm,-1mm)$) {0};

    % Block number arrow above tag and set
    \draw[<->, thick] ([yshift=2mm]tag.north west) -- ([yshift=2mm]set.north east)
        node[midway, above, font=\scriptsize] {block number};
    \end{tikzpicture}
\end{center}
\end{tcolorbox}

\textbf{Advantage:} Simple and cheap\\
\textbf{Disadvantage:} Higher miss rate due to conflicts
\end{columns}
\end{frame}

\begin{frame}{K-Way Set Associative Organization}
\begin{columns}
\column{0.5\textwidth}
\begin{itemize}
    \item Compromise between fully associative and direct mapped
    \item Cache divided into K ways
    \item Each block can map to K different locations (one per way)
    \item Most common: 2-way, 4-way, 8-way
\end{itemize}

\column{0.5\textwidth}
\begin{tcolorbox}[colback=gray!10]
\textbf{Example: 2-Way}\\
Each set has 2 possible locations\\
\vspace{0.3cm}
[Placeholder: 2-way cache diagram]
\end{tcolorbox}
\end{columns}
\end{frame}

\tikzset{
    % Style definitions
    tagbox/.style={rectangle, draw, fill=green!30, minimum width=2cm, minimum height=0.6cm, font=\footnotesize},
    setbox/.style={rectangle, draw, fill=cyan!30, minimum width=1.5cm, minimum height=0.6cm, font=\footnotesize},
    offsetbox/.style={rectangle, draw, fill=orange!30, minimum width=2cm, minimum height=0.6cm, font=\footnotesize},
    cellstyle/.style={rectangle, draw, minimum width=1.2cm, minimum height=0.35cm, 
                     text depth=0.1cm, text height=0.2cm, font=\tiny},
    tagcell/.style={cellstyle, fill=green!30},
    offsetcell/.style={cellstyle, fill=orange!30, minimum width=2mm},
    titlecell/.style={cellstyle, font=\tiny},
    decoder/.style={muxdemux, muxdemux def={Lh=1, Rh=4, NB=0, NL=1, NR=4, w=0.8, square pins=0},
                   external pins width=0, fill=cyan!20},
    % Comparator as downward-pointing pentagon
    comparator/.style={regular polygon, regular polygon sides=5, draw, fill=green!30, 
                      minimum width=1cm, minimum height=1cm, rotate=180},
    % MUX as wider trapezoid
    muxshape/.style={trapezium, trapezium angle=60, draw, minimum width=1.5cm, minimum height=0.8cm},
    arrow/.style={->, >=stealth, thick},
    dasharrow/.style={dashed, ->, >=stealth},
    % OR gate with custom sizing (rotated 90 degrees counter-clockwise)
    orgatestyle/.style={or gate US, draw, logic gate inputs=nn, anchor=center,
                       minimum width=1cm, minimum height=0.8cm, rotate=90},
    % Junction dot style
    junction/.style={circle, fill=black, inner sep=0pt, minimum size=3pt},
    % Data connector dot style
    data_connector/.style={circle, fill, inner sep=1.2pt}
}

\begin{frame}[fragile]{2-Way Set Associative Organization}
\begin{center}
\begin{tikzpicture}[scale=0.8, transform shape]

% Address bits at top - shifted to the right
\node[tagbox] at (2,0) (tag) {Tag};
\node[setbox, right=0pt of tag] (set) {Set};
\node[offsetbox, right=0pt of set] (offset) {Line Offset};

% Bit labels - adjacent to boxes
\node[anchor=south west] at (tag.north west) {\footnotesize 31};
\node[anchor=south east] at (tag.north east) {\footnotesize 6};
\node[anchor=south east] at (set.north east) {\footnotesize 5\,4};
\node[anchor=south east] at (offset.north east) {\footnotesize 0};

% Define base positions for ways (further apart)
\coordinate (way0base) at ($(set.south) + (-6,-2.5)$);
\coordinate (way1base) at ($(set.south) + (0,-2.5)$);

% Way 0 Tag array - using for loop (create first to align demux)
\coordinate (tag0_start) at ($(way0base) + (2.5,0.5)$);
\begin{scope}[every node/.style={tagcell}]
\foreach \i in {0,...,3} {
    \ifnum\i=0
        \node[anchor=north] at (tag0_start) (tag0_\i) {\scriptsize Tag};
    \else
        \pgfmathtruncatemacro{\prev}{\i-1}
        \node[below=0cm of tag0_\prev.south, anchor=north] (tag0_\i) {};
    \fi
}
\end{scope}

% Way 0 decoder (demux) - aligned with first tag box using rpin 1, further left
\node[decoder, anchor=rpin 1] at ($(tag0_0.west) + (-0.5,0)$) (decoder0) {};
\node[font=\small, anchor=east] at ([xshift=-5mm]decoder0.lpin 1) {Set\#};

% Way 0 Data array - using for loop, positioned relative to tag array
\coordinate (data0_start) at ($(tag0_0.east) + (0.8,0)$);
\begin{scope}[every node/.style={cellstyle}]
\foreach \i in {0,...,3} {
    \ifnum\i=0
        \node[anchor=west] at (data0_start) (data0_\i) {\scriptsize Data};
    \else
        \pgfmathtruncatemacro{\prev}{\i-1}
        \node[below=0cm of data0_\prev.south, anchor=north] (data0_\i) {};
    \fi
}
% Draw orange box for line offset only on first data line
\node[offsetcell, anchor=east] at ([xshift=-1mm]data0_1.east) (thedata0) {};
\end{scope}

% Way 0 comparator - using muxdemux rotated 90 degrees
\node[muxdemux, muxdemux def={Lh=0.6, Rh=0.3, NL=2, NB=1, w=0.5},
      external pins width=0, fill=green!30, rotate=270] at ([xshift=1.5cm, yshift=-0.5cm] tag0_3.south west) (comp0) {};
\node[font=\fontsize{4}{4}\selectfont, rotate=90] at (comp0.center) {=};

% Way 0 label
\node[above=1mm of tag0_0.north] (way0label) {\textbf{Way 0}};

% Way 1 Tag array - using for loop (create first to align demux)
\coordinate (tag1_start) at ($(way1base) + (2.5,0.5)$);
\begin{scope}[every node/.style={tagcell}]
\foreach \i in {0,...,3} {
    \ifnum\i=0
        \node[anchor=north] at (tag1_start) (tag1_\i) {\scriptsize Tag};
    \else
        \pgfmathtruncatemacro{\prev}{\i-1}
        \node[below=0cm of tag1_\prev.south, anchor=north] (tag1_\i) {};
    \fi
}
\end{scope}

% Way 1 decoder (demux) - aligned with first tag box using rpin 1, further left
\node[decoder, anchor=rpin 1] at ($(tag1_0.west) + (-0.5,0)$) (decoder1) {};
\node[font=\small, anchor=east] at ([xshift=-5mm]decoder1.lpin 1) {Set\#};

% Way 1 Data array - using for loop, positioned relative to tag array
\coordinate (data1_start) at ($(tag1_0.east) + (0.8,0)$);
\begin{scope}[every node/.style={cellstyle}]
\foreach \i in {0,...,3} {
    \ifnum\i=0
        \node[anchor=west] at (data1_start) (data1_\i) {\scriptsize Data};
    \else
        \pgfmathtruncatemacro{\prev}{\i-1}
        \node[below=0cm of data1_\prev.south, anchor=north] (data1_\i) {};
    \fi
}
\node[offsetcell, anchor=east] at ([xshift=-1mm]data1_1.east) (thedata1) {};
\end{scope}

% Way 1 comparator - using muxdemux rotated 90 degrees
\node[muxdemux, muxdemux def={Lh=0.6, Rh=0.3, NL=2, NB=1, w=0.5},
      external pins width=0, fill=green!30, rotate=270] at ([xshift=1.5cm, yshift=-5mm] tag1_3.south west) (comp1) {};
\node[font=\fontsize{4}{4}\selectfont, rotate=90] at (comp1.center) {=};

% Way 1 label
\node[above=1mm of tag1_0.north] (way1label) {\textbf{Way 1}};

% Background for ways
\begin{pgfonlayer}{background}
    \node[fit=(way0label)(decoder0)(tag0_0)(tag0_3)(data0_0)(data0_3)(comp0),
          fill=gray!10, draw=gray!30, dashed, rounded corners,
          inner sep=3mm] (way0bg) {};
    \node[fit=(way1label)(decoder1)(tag1_0)(tag1_3)(data1_0)(data1_3)(comp1),
          fill=gray!10, draw=gray!30, dashed, rounded corners,
          inner sep=3mm] (way1bg) {};
\end{pgfonlayer}

% OR gate - positioned between comparators
\node[orgatestyle, rotate=180, yscale=0.7, xscale=0.5] at ($(comp0)!0.5!(comp1) + (0,-1.5)$) (orgate) {};

% MUX - using muxdemux, rotated 270 degrees, positioned relative to data arrays
\node[muxdemux, muxdemux def={Lh=1, Rh=0.5, NL=2, NB=2, NR=1, w=0.8},
      external pins width=0, fill=gray!20, rotate=270,anchor=lpin 1] at ([yshift=-1.1cm]data1_3.south) (mux) {};

% Output labels
\node[below=2mm of orgate.east] (hitmiss) {Hit/Miss};
\node[below=0.5cm of mux.rpin 1] (dataout) {Data Out};

% Arrows from address bits to decoders with junction - initial line has no arrow
\draw (set.south) -- ++(0,-0.5) coordinate (setjunction);
\node[junction] at (setjunction) {};
\draw[arrow] (setjunction) -| ([xshift=-5mm]decoder0.lpin 1) -- (decoder0.lpin 1);
\draw[arrow] (setjunction) -| ([xshift=-5mm]decoder1.lpin 1) -- (decoder1.lpin 1);

% Arrows from address tag to comparators with junction - initial line has no arrow
\draw (tag.south) -- ++(0,-0.8) coordinate (tagjunction);
\node[junction] at (tagjunction) {};
\draw[arrow] (tagjunction) -| (comp0.lpin 1);
\draw[arrow] (tagjunction) -| (comp1.lpin 1);

% Arrows from offset to data arrays with junction - initial line has no arrow
\draw (offset.south) -- ++(0,-0.7) coordinate (offsetjunction);
\node[junction] at (offsetjunction) {};
\draw[arrow] (offsetjunction) -| (thedata0.north);
\draw[arrow] (offsetjunction) -| (thedata1.north);

% Decoder to tag arrays - straight horizontal lines
\foreach \i in {0,...,3} {
    \pgfmathtruncatemacro{\pin}{\i+1}
    \draw[arrow] (decoder0.rpin 1 |- tag0_\i.west) -- (tag0_\i.west);
    \draw[arrow] (decoder1.rpin 1 |- tag1_\i.west) -- (tag1_\i.west);
}

% Dashed lines from tag arrays to data arrays (each row)
\foreach \i in {0,...,3} {
    \draw[dasharrow] (tag0_\i.east) -- (data0_\i.west);
    \draw[dasharrow] (tag1_\i.east) -- (data1_\i.west);
}

% Selected line highlighting (example: line 1)
\draw[arrow, thick, orange] (tag0_1.east) -- (data0_1.west);
\draw[arrow, thick, orange] (tag1_1.east) -- (data1_1.west);

% Tag array output to comparator
\draw[arrow] (tag0_1.east) -| (comp0.lpin 2);
\draw[arrow] (tag1_1.east) -| (comp1.lpin 2);

% Data array to MUX connections
\draw[arrow] (data0_3.south) |- ([yshift=3mm]mux.lpin 2) -- (mux.lpin 2);
\draw[arrow] (data1_3.south) -- (mux.lpin 1);

% Comparator outputs to OR gate
\draw[arrow] (comp0.rpin 1) |- ([yshift=3mm]orgate.input 2) -- (orgate.input 2);
\draw[arrow] (comp1.rpin 1) |- ([yshift=3mm]orgate.input 1) -- (orgate.input 1);

% OR gate to Hit/Miss
\draw[arrow] (orgate.output) -- (hitmiss.north);

% Comparator to MUX select (using comp1 output)
\draw[arrow] (comp0.rpin 1 |- mux.bpin 1) node[data_connector] {} -- (mux.bpin 1);
\draw[arrow] (comp1.rpin 1 |- mux.bpin 2) node[data_connector] {} -- (mux.bpin 2);

% MUX to data out
\draw[arrow] (mux.rpin 1) -- (dataout.north);

\end{tikzpicture}
\end{center}
\end{frame}





\section{Replacement Policies}
\begin{frame}{Eviction Policies}
When cache is full and we need to bring in a new block, which block should be evicted?

\begin{enumerate}
    \item \textbf{LRU (Least Recently Used)}
    \begin{itemize}
        \item Evict the block that hasn't been used for the longest time
    \end{itemize}
    
    \item \textbf{LRM (Least Recently Modified)}
    \begin{itemize}
        \item Evict the block that hasn't been written to for the longest time
    \end{itemize}
    
    \item \textbf{Random}
    \begin{itemize}
        \item Completely random selection
    \end{itemize}
\end{enumerate}

Note: Direct mapped caches don't need replacement policy!
\end{frame}

\section{Write Policies}
\begin{frame}{Write Back Policy}
\vspace{-0.3cm}
\begin{itemize}
    \item Write only to cache during write operation
    \item Update main memory only when block is evicted
    \item Requires a \textbf{dirty bit} per block to indicate if block was modified
\end{itemize}

\vspace{0.3cm}
\centering
\begin{tikzpicture}[
    block/.style={draw, thick, minimum width=\blocksize, minimum height=\blocksize},
    label/.style={font=\bfseries\large},
    arrow/.style={->, >=Stealth, thick, font=\small},
    dirtymark/.style={font=\footnotesize\bfseries, black},
    group/.style={draw, very thick, inner sep=0pt},
    node distance=0cm and 0cm,
    scale=0.9
]

% State 1: Initial
\node[label] (l1lbl) {L1};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right={\ifnum\i=1 0cm\else 0cm\fi} of l1lbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_l1_\i) {};
}
\node[group, fit=(s1_l1_1)(s1_l1_2)] {};
\node[group, fit=(s1_l1_3)(s1_l1_4)] {};

\node[label, below=1.5cm of l1lbl.east, anchor=east] (memlbl) {MEM};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of memlbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_mem_\i) {};
}
\node[group, fit=(s1_mem_1)(s1_mem_2)] {};
\node[group, fit=(s1_mem_3)(s1_mem_4)] {};
\node[group, fit=(s1_mem_5)(s1_mem_6)] {};

\coordinate (between) at ($(l1lbl.east)!0.5!(memlbl.east)$);

% Arrow 1 with "Write" label
\draw[arrow] ([xshift=1.5cm]between) -- ++(2.5,0)
  node[midway, above] (arrow1) {};
\node[writeblock=blue,
      above=of arrow1] (writeblock) {};
\node[above=of writeblock] (write) {Write};

% State 2: After Write
\coordinate (s2start) at ([xshift=4cm]between);

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \ifnum\i=1
        \node[writeblock=\col,
              right=0cm of s2start, anchor=west, xshift={\i*\blocksize},
              yshift=0.75cm] (s2_l1_\i) {};
        \node[dirtymark] at (s2_l1_\i) {D};
    \else
        \ifnum\i=2
            \node[block, fill=\col, right=0cm of s2start,
                  anchor=west, xshift={\i*\blocksize}, yshift=0.75cm] (s2_l1_\i) {};
            \node[dirtymark] at (s2_l1_\i) {D};
        \else
            \node[block, fill=\col, right=0cm of s2start,
                  anchor=west, xshift={\i*\blocksize}, yshift=0.75cm] (s2_l1_\i) {};
        \fi
    \fi
}
\node[group, fit=(s2_l1_1)(s2_l1_2)] {};
\node[group, fit=(s2_l1_3)(s2_l1_4)] {};

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of s2start,
          anchor=west, xshift={\i*\blocksize}, yshift=-0.75cm] (s2_mem_\i) {};
}
\node[group, fit=(s2_mem_1)(s2_mem_2)] {};
\node[group, fit=(s2_mem_3)(s2_mem_4)] {};
\node[group, fit=(s2_mem_5)(s2_mem_6)] {};

% Arrow 2
\coordinate (between2) at ([xshift=4*\blocksize+3cm]between);
\draw[arrow] ([xshift=1.5cm]between2) -- ++(2.5,0)
    node[midway, above, align=center] (arrow2) {Eviction};

% State 3: Final
\coordinate (s3start) at ([xshift=4cm]between2);

\foreach \i/\col in {1/yellow!60, 2/yellow!60, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right=0cm of s3start,
          anchor=west, xshift={\i*\blocksize}, yshift=0.75cm] (s3_l1_\i) {};
}
\node[group, fit=(s3_l1_1)(s3_l1_2)] {};
\node[group, fit=(s3_l1_3)(s3_l1_4)] {};

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \ifnum\i=1
        \node[writeblock=\col,
              right=0cm of s3start, anchor=west, xshift={\i*\blocksize},
              yshift=-0.75cm] (s3_mem_\i) {};
        \node[dirtymark] at (s3_mem_\i) {D};
    \else
        \ifnum\i=2
            \node[block, fill=\col, right=0cm of s3start,
                  anchor=west, xshift={\i*\blocksize}, yshift=-0.75cm] (s3_mem_\i) {};
            \node[dirtymark] at (s3_mem_\i) {D};
        \else
            \node[block, fill=\col, right=0cm of s3start,
                  anchor=west, xshift={\i*\blocksize}, yshift=-0.75cm] (s3_mem_\i) {};
        \fi
    \fi
}
\node[group, fit=(s3_mem_1)(s3_mem_2)] {};
\node[group, fit=(s3_mem_3)(s3_mem_4)] {};
\node[group, fit=(s3_mem_5)(s3_mem_6)] {};

\end{tikzpicture}

\vspace{0.3cm}
\footnotesize
Dirty blocks (marked 'D') are written back to memory on eviction
\end{frame}





\begin{frame}{Write Through Policy}
\vspace{-0.3cm}
\begin{itemize}
    \item Write to both cache AND main memory during write operation
    \item No need to update memory when block is evicted
    \item No dirty bit needed - simpler but more memory traffic
\end{itemize}

\vspace{0.3cm}
\centering
\begin{tikzpicture}[
    block/.style={draw, thick, minimum width=\blocksize, minimum height=\blocksize},
    label/.style={font=\bfseries\large},
    arrow/.style={->, >=Stealth, thick, font=\small},
    group/.style={draw, very thick, inner sep=0pt},
    node distance=0cm and 0cm,
    scale=0.9
]

% State 1: Initial
\node[label] (l1lbl) {L1};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right={\ifnum\i=1 0cm\else 0cm\fi} of l1lbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_l1_\i) {};
}
\node[group, fit=(s1_l1_1)(s1_l1_2)] {};
\node[group, fit=(s1_l1_3)(s1_l1_4)] {};

\node[label, below=1.5cm of l1lbl.east, anchor=east] (memlbl) {MEM};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of memlbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_mem_\i) {};
}
\node[group, fit=(s1_mem_1)(s1_mem_2)] {};
\node[group, fit=(s1_mem_3)(s1_mem_4)] {};
\node[group, fit=(s1_mem_5)(s1_mem_6)] {};

\coordinate (between) at ($(l1lbl.east)!0.5!(memlbl.east)$);

% Arrow 1
\draw[arrow] ([xshift=1.5cm]between) -- ++(2.5,0)
  node[midway, above] (arrow1) {};
\node[writeblock=blue,
      above=of arrow1] (writeblock) {};
\node[above=of writeblock] (write) {Write};

% State 2: After Write
\coordinate (s2start) at ([xshift=4cm]between);

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \ifnum\i=1
        \node[writeblock=\col,
              right=0cm of s2start, anchor=west, xshift={\i*\blocksize},
              yshift=0.75cm] (s2_l1_\i) {};
    \else
        \node[block, fill=\col, right=0cm of s2start,
              anchor=west, xshift={\i*\blocksize}, yshift=0.75cm] (s2_l1_\i) {};
    \fi
}
\node[group, fit=(s2_l1_1)(s2_l1_2)] {};
\node[group, fit=(s2_l1_3)(s2_l1_4)] {};

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \ifnum\i=1
        \node[writeblock=\col,
              right=0cm of s2start, anchor=west, xshift={\i*\blocksize},
              yshift=-0.75cm] (s2_mem_\i) {};
    \else
        \node[block, fill=\col, right=0cm of s2start,
              anchor=west, xshift={\i*\blocksize}, yshift=-0.75cm] (s2_mem_\i) {};
    \fi
}
\node[group, fit=(s2_mem_1)(s2_mem_2)] {};
\node[group, fit=(s2_mem_3)(s2_mem_4)] {};
\node[group, fit=(s2_mem_5)(s2_mem_6)] {};

% Arrow 2
\coordinate (between2) at ([xshift=4*\blocksize+3cm]between);
\draw[arrow] ([xshift=1.5cm]between2) -- ++(2.5,0)
    node[midway, above, align=center] (arrow2) {Eviction};

% State 3: Final
\coordinate (s3start) at ([xshift=4cm]between2);

\foreach \i/\col in {1/yellow!60, 2/yellow!60, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right=0cm of s3start,
          anchor=west, xshift={\i*\blocksize}, yshift=0.75cm] (s3_l1_\i) {};
}
\node[group, fit=(s3_l1_1)(s3_l1_2)] {};
\node[group, fit=(s3_l1_3)(s3_l1_4)] {};

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \ifnum\i=1
        \node[writeblock=\col,
              right=0cm of s3start, anchor=west, xshift={\i*\blocksize},
              yshift=-0.75cm] (s3_mem_\i) {};
    \else
        \node[block, fill=\col, right=0cm of s3start,
              anchor=west, xshift={\i*\blocksize}, yshift=-0.75cm] (s3_mem_\i) {};
    \fi
}
\node[group, fit=(s3_mem_1)(s3_mem_2)] {};
\node[group, fit=(s3_mem_3)(s3_mem_4)] {};
\node[group, fit=(s3_mem_5)(s3_mem_6)] {};

\end{tikzpicture}

\vspace{0.3cm}
\footnotesize
Both cache and memory are updated simultaneously on write
\end{frame}

\begin{frame}{Write Miss Policies: Write Allocate}
\vspace{-0.3cm}
\begin{itemize}
    \item On write miss: fetch block from memory, allocate in cache, then write
    \item May require eviction to make room
    \item Commonly used with \textbf{write-back} policy
\end{itemize}

\vspace{0.2cm}
\centering
\begin{tikzpicture}[
    block/.style={draw, thick, minimum width=\blocksize, minimum height=\blocksize},
    label/.style={font=\bfseries\large},
    arrow/.style={->, >=Stealth, thick, font=\small},
    invalidmark/.style={font=\scriptsize\sffamily\bfseries, black},
    dirtymark/.style={font=\footnotesize\bfseries, black},
    group/.style={draw, very thick, inner sep=0pt},
    arrowlabel/.style={font=\scriptsize, inner sep=1pt, align=center},
    node distance=0cm and 0cm,
    scale=0.9
]

% State 1: Initial
\node[label] (l1lbl) {L1};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right={\ifnum\i=1 0cm\else 0cm\fi} of l1lbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_l1_\i) {};
}
\node[group, fit=(s1_l1_1)(s1_l1_2)] {};
\node[group, fit=(s1_l1_3)(s1_l1_4)] {};

\node[label, below=1.5cm of l1lbl.east, anchor=east] (memlbl) {MEM};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of memlbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_mem_\i) {};
}
\node[group, fit=(s1_mem_1)(s1_mem_2)] {};
\node[group, fit=(s1_mem_3)(s1_mem_4)] {};
\node[group, fit=(s1_mem_5)(s1_mem_6)] {};

\coordinate (between) at ($(l1lbl.east)!0.5!(memlbl.east) + (0,-0.15cm)$);

% Arrow 1: Write request, miss, eviction
\draw[arrow] ([xshift=1.5cm]between) -- ++(2.5,0)
  node[midway, above, arrowlabel] (arrow1) {Write request,\\[-2pt]miss \& eviction};
\node[draw, thick, minimum width=\blocksize, minimum height=\blocksize,
      pattern=north east lines, pattern color=orange, above=0.15cm of arrow1] (writeblock) {};

% State 2: After eviction (block invalidated)
\coordinate (s2start) at ([xshift=4cm]between);

\foreach \i/\col in {1/white, 2/white, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right=0cm of s2start, anchor=west, xshift={\i*\blocksize},
          yshift=0.9cm] (s2_l1_\i) {};
    \ifnum\i<3
        \node[invalidmark] at (s2_l1_\i) {\textsf{I}};
    \fi
}
\node[group, fit=(s2_l1_1)(s2_l1_2)] {};
\node[group, fit=(s2_l1_3)(s2_l1_4)] {};

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of s2start,
          anchor=west, xshift={\i*\blocksize}, yshift=-0.6cm] (s2_mem_\i) {};
}
\node[group, fit=(s2_mem_1)(s2_mem_2)] {};
\node[group, fit=(s2_mem_3)(s2_mem_4)] {};
\node[group, fit=(s2_mem_5)(s2_mem_6)] {};

% Arrow 2: Fetch block and write
\coordinate (between2) at ([xshift=4*\blocksize+3cm]between);
\draw[arrow] ([xshift=1.5cm]between2) -- ++(2.5,0)
    node[midway, above, arrowlabel] (arrow2) {Fetch block\\[-2pt]\& write};

% State 3: Final - yellow block fetched and written
\coordinate (s3start) at ([xshift=4cm]between2);

\foreach \i/\col in {1/yellow!60, 2/yellow!60, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right=0cm of s3start,
          anchor=west, xshift={\i*\blocksize}, yshift=0.9cm] (s3_l1_\i) {};
}
% Add pattern to the written block (first yellow) - same pattern as write box
\node[draw, thick, minimum width=\blocksize, minimum height=\blocksize,
      fill=yellow!60, pattern=north east lines, pattern color=orange,
      right=0cm of s3start, anchor=west,
      xshift={1*\blocksize}, yshift=0.9cm] {};
% Add D markers to both yellow blocks
\node[dirtymark] at (s3_l1_1) {D};
\node[dirtymark] at (s3_l1_2) {D};
\node[group, fit=(s3_l1_1)(s3_l1_2)] {};
\node[group, fit=(s3_l1_3)(s3_l1_4)] {};

\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of s3start,
          anchor=west, xshift={\i*\blocksize}, yshift=-0.6cm] (s3_mem_\i) {};
}
\node[group, fit=(s3_mem_1)(s3_mem_2)] {};
\node[group, fit=(s3_mem_3)(s3_mem_4)] {};
\node[group, fit=(s3_mem_5)(s3_mem_6)] {};

\end{tikzpicture}

\vspace{0.3cm}
\footnotesize
Block is fetched to cache before writing; evicted blocks marked 'I' (invalid), dirty block marked 'D'
\end{frame}

\begin{frame}{Write Miss Policies: No Write Allocate}
\vspace{-0.3cm}
\begin{itemize}
    \item On write miss: write directly to next level, don't fetch to cache
    \item Cache unchanged, simpler but may miss future locality
    \item Commonly used with \textbf{write-through} policy
\end{itemize}

\vspace{0.2cm}
\centering
\begin{tikzpicture}[
    block/.style={draw, thick, minimum width=\blocksize, minimum height=\blocksize},
    label/.style={font=\bfseries\large},
    arrow/.style={->, >=Stealth, thick},
    arrowlabel/.style={font=\scriptsize, inner sep=1pt, align=center},
    group/.style={draw, very thick, inner sep=0pt},
    node distance=0cm and 0cm,
    scale=0.9
]

% State 1: Initial
\node[label] (l1lbl) {L1};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right={\ifnum\i=1 0cm\else 0cm\fi} of l1lbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_l1_\i) {};
}
\node[group, fit=(s1_l1_1)(s1_l1_2)] {};
\node[group, fit=(s1_l1_3)(s1_l1_4)] {};

\node[label, below=2.0cm of l1lbl.east, anchor=east] (l2lbl) {L2};
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of l2lbl.east,
          anchor=west, xshift={\i*\blocksize}] (s1_l2_\i) {};
}
\node[group, fit=(s1_l2_1)(s1_l2_2)] {};
\node[group, fit=(s1_l2_3)(s1_l2_4)] {};
\node[group, fit=(s1_l2_5)(s1_l2_6)] {};

\coordinate (between1) at ($(l1lbl.east)!0.5!(l2lbl.east)$);

% Arrow 1: Write request to L1, miss
\draw[arrow] ([xshift=3.0cm, yshift=-5mm]between1) -- ++(1.8,0)
  node[midway, above, yshift=1mm, arrowlabel] (arrow1) {Write request to\\[-2pt]level 1, miss};
\node[draw, thick, minimum width=\blocksize, minimum height=\blocksize,
      pattern=north east lines, pattern color=orange, above=0.15cm of arrow1] (writeblock) {};

% State 2: L1 miss, forwarding to L2
\coordinate (s2start) at ([xshift=5.0cm]between1);

% L1 unchanged
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right=0cm of s2start, anchor=west, xshift={\i*\blocksize},
          yshift=1.0cm] (s2_l1_\i) {};
}
\node[group, fit=(s2_l1_1)(s2_l1_2)] {};
\node[group, fit=(s2_l1_3)(s2_l1_4)] {};

% L2 unchanged yet
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of s2start,
          anchor=west, xshift={\i*\blocksize}, yshift=-1.0cm] (s2_l2_\i) {};
}
\node[group, fit=(s2_l2_1)(s2_l2_2)] {};
\node[group, fit=(s2_l2_3)(s2_l2_4)] {};
\node[group, fit=(s2_l2_5)(s2_l2_6)] {};

% Arrow 2: Write request from L1 to L2, hit
\coordinate (between2) at ($(s2_l1_4.east)!0.5!(s2_l2_6.east)$);
\draw[arrow] ([xshift=0.3cm, yshift=-5mm]between2) -- ++(1.8,0)
  node[midway, above, yshift=1mm, arrowlabel] {Write request from\\[-2pt]level 1 to level 2, hit};

% State 3: Final - L2 has the write
\coordinate (s3start) at ([xshift=2.4cm]between2);

% L1 still unchanged
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60} {
    \node[block, fill=\col, right=0cm of s3start, anchor=west, xshift={\i*\blocksize},
          yshift=1.0cm] (s3_l1_\i) {};
}
\node[group, fit=(s3_l1_1)(s3_l1_2)] {};
\node[group, fit=(s3_l1_3)(s3_l1_4)] {};

% L2 with yellow block written
\foreach \i/\col in {1/blue!30, 2/blue!30, 3/green!60, 4/green!60, 5/yellow!60, 6/yellow!60} {
    \node[block, fill=\col, right=0cm of s3start,
          anchor=west, xshift={\i*\blocksize}, yshift=-1.0cm] (s3_l2_\i) {};
}
% Add pattern to the yellow block that was written
\node[draw, thick, minimum width=\blocksize, minimum height=\blocksize,
      fill=yellow!60, pattern=north east lines, pattern color=orange,
      right=0cm of s3start, anchor=west,
      xshift={5*\blocksize}, yshift=-1.0cm] {};
\node[group, fit=(s3_l2_1)(s3_l2_2)] {};
\node[group, fit=(s3_l2_3)(s3_l2_4)] {};
\node[group, fit=(s3_l2_5)(s3_l2_6)] {};

\end{tikzpicture}

\vspace{0.3cm}
\footnotesize
Write goes directly to next level; L1 cache is not modified
\end{frame}

\section{Types of Misses}
\begin{frame}{Three Types of Cache Misses}
\begin{enumerate}
    \item \textbf{Compulsory (Cold) Misses}
    \begin{itemize}
        \item Block has never been used before
        \item Unavoidable on first access
    \end{itemize}
    
    \item \textbf{Conflict Misses}
    \begin{itemize}
        \item Block was used but evicted due to mapping conflicts
        \item Another block took its place in the set
        \item Affected by associativity and mapping
    \end{itemize}
    
    \item \textbf{Capacity Misses}
    \begin{itemize}
        \item Block was used but evicted because cache is full
        \item Would occur even in fully associative cache
        \item Can only be reduced by increasing cache size
    \end{itemize}
\end{enumerate}
\end{frame}

\section{LRU Implementation}
\begin{frame}{LRU Implementation for 4-Way Cache}
\textbf{Method 1: Full List (8 bits per set)}
\begin{itemize}
    \item Maintain linked list of 4 nodes (one per way)
    \item Store order of usage
    \item 2 bits per way $\times$ 4 ways = 8 bits
    \item Update list on every access
\end{itemize}

\textbf{Example states:}
\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
Initial: & Way0(00) & Way1(01) & Way2(10) & Way3(11) \\
Hit Way1: & Way1(01) & Way0(00) & Way2(10) & Way3(11) \\
Hit Way2: & Way2(10) & Way1(01) & Way0(00) & Way3(11) \\
\hline
\multicolumn{2}{|l}{MRU} & & & LRU \\
\hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}{LRU Implementation - Optimized}
\textbf{Method 2: Partial List (6 bits per set)}
\begin{itemize}
    \item Store only 3 most recent ways
    \item 4th way is implicitly LRU
    \item 2 bits $\times$ 3 = 6 bits per set
\end{itemize}

\textbf{Method 3: Optimal Encoding (5 bits per set)}
\begin{itemize}
    \item Number of possible orderings: $4! = 24$
    \item Need $\lceil \log_2(24) \rceil = 5$ bits
    \item Most space-efficient
    \item But complex encoding/decoding logic
\end{itemize}
\end{frame}

\section{Cache Performance Metrics}
\begin{frame}{Cache Performance Metrics}
\textbf{Important Formulas:}
\begin{itemize}
    \item \textbf{Average Memory Access Time (AMAT):}
    $$AMAT = Hit\_Time + Miss\_Rate \times Miss\_Penalty$$

    \item \textbf{Cache Size:}
    $$Size = \#Sets \times \#Ways \times Block\_Size$$

    \item \textbf{Directory Size:}
    $$Dir\_Size = \#Sets \times \#Ways \times (Tag\_Bits + Status\_Bits)$$

    \item \textbf{Set Calculation:}
    $$Set = \lfloor Address / Block\_Size \rfloor \mod \#Sets$$
\end{itemize}
\end{frame}

\section{Question 1: Cache Access Trace}
\begin{frame}{Q1: Cache Access Trace}
\textbf{Given:}
\begin{itemize}
    \item 2-way set associative cache, LRU replacement
    \item 4 bytes per block (line)
    \item Address format: %[Tag(29-5) | Set(4-2) | Offset(1-0)]
    \addressbreakdown{25}{3}{2}
    \item Sequence: 5, 7, 1, 4, 36, 8, 100, 6, 4, 12, 36, 12, 68, 5, 7
\end{itemize}

\textbf{Calculate:} Number of misses and final cache state
\end{frame}

\begin{frame}{Q1a: Solution Setup}
\begin{columns}[T]
\begin{column}{0.48\textwidth}
\textbf{Address Analysis:}
\begin{itemize}
    \item Block size = 4 bytes $\rightarrow$ 2 offset bits
    \item Addresses 0-3 $\rightarrow$ block 0, 4-7 $\rightarrow$ block 1, etc.
    \item Set = $\lfloor$Address / 4$\rfloor$ mod 4
\end{itemize}
\end{column}

\begin{column}{0.48\textwidth}
\centering
\footnotesize
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Addr} & \textbf{Block} & \textbf{Tag} & \textbf{Set} \\
\hline
5 & 1 & 0 & 1 \\
7 & 1 & 0 & 1 \\
1 & 0 & 0 & 0 \\
4 & 1 & 0 & 1 \\
36 & 9 & 1 & 1 \\
8 & 2 & 0 & 2 \\
6 & 1 & 0 & 1 \\
12 & 3 & 0 & 3 \\
68 & 17 & 2 & 1 \\
\hline
\end{tabular}
\end{column}
\end{columns}
\end{frame}

\begin{frame}{Q1b: Trace Table}
\vspace{-0.3cm}
\begin{center}
\footnotesize
\begin{tabular}{|c|c:c|c|c|c|c|l|}
\hline
& \textbf{Addr} & \textcolor{blue}{\textbf{Tag}} \textcolor{green!70!black}{\textbf{Set}} \textcolor{orange}{\textbf{Off}} & \textbf{Tag} & \textbf{Set} & \textbf{\shortstack{Hit/\\Miss}} & \textbf{\shortstack{Way/\\LRU}} & \textbf{Explanation} \\
\hline
1 & 5 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{01} & 0 & 1 & \uncover<1->{\textcolor{red}{M}} & \uncover<1->{0/1} & \uncover<1->{First access to set 1} \\
2 & 7 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{11} & 0 & 1 & \uncover<2->{\textcolor{green!70!black}{H}} & \uncover<2->{0/1} & \uncover<2->{Same block as addr 5 (4-7)} \\
3 & 1 & \textcolor{blue}{00}\textcolor{green!70!black}{000}\textcolor{orange}{01} & 0 & 0 & \uncover<3->{\textcolor{red}{M}} & \uncover<3->{0/1} & \uncover<3->{First access to set 0} \\
4 & 4 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{00} & 0 & 1 & \uncover<4->{\textcolor{green!70!black}{H}} & \uncover<4->{0/1} & \uncover<4->{Already loaded (1)} \\
5 & 36 & \textcolor{blue}{01}\textcolor{green!70!black}{001}\textcolor{orange}{00} & 1 & 1 & \uncover<5->{\textcolor{red}{M}} & \uncover<5->{1/0} & \uncover<5->{Different tag, set=1 (1), way=1} \\
6 & 8 & \textcolor{blue}{00}\textcolor{green!70!black}{010}\textcolor{orange}{00} & 0 & 2 & \uncover<6->{\textcolor{red}{M}} & \uncover<6->{0/1} & \uncover<6->{First access to set 2} \\
7 & 100 & \textcolor{blue}{11}\textcolor{green!70!black}{001}\textcolor{orange}{00} & 3 & 1 & \uncover<7->{\textcolor{red}{M}} & \uncover<7->{0/1} & \uncover<7->{Evict way 0 (LRU), set=1} \\
8 & 6 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{10} & 0 & 1 & \uncover<8->{\textcolor{red}{M}} & \uncover<8->{1/0} & \uncover<8->{Block 4-7 evicted (7), use way 0 (LRU)} \\
9 & 4 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{00} & 0 & 1 & \uncover<9->{\textcolor{green!70!black}{H}} & \uncover<9->{1/0} & \uncover<9->{Loaded again (8)} \\
10 & 12 & \textcolor{blue}{00}\textcolor{green!70!black}{011}\textcolor{orange}{00} & 0 & 3 & \uncover<10->{\textcolor{red}{M}} & \uncover<10->{0/1} & \uncover<10->{First access to set 3} \\
11 & 36 & \textcolor{blue}{01}\textcolor{green!70!black}{001}\textcolor{orange}{00} & 1 & 1 & \uncover<11->{\textcolor{red}{M}} & \uncover<11->{0/1} & \uncover<11->{Evict way 0 (LRU), set=1} \\
12 & 12 & \textcolor{blue}{00}\textcolor{green!70!black}{011}\textcolor{orange}{00} & 0 & 3 & \uncover<12->{\textcolor{green!70!black}{H}} & \uncover<12->{0/1} & \uncover<12->{Already loaded (10)} \\
13 & 68 & \textcolor{blue}{10}\textcolor{green!70!black}{001}\textcolor{orange}{00} & 2 & 1 & \uncover<13->{\textcolor{red}{M}} & \uncover<13->{1/0} & \uncover<13->{Evict way 1 (LRU), set=1} \\
14 & 5 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{01} & 0 & 1 & \uncover<14->{\textcolor{red}{M}} & \uncover<14->{0/1} & \uncover<14->{Block evicted (8,13), use way 1 (LRU)} \\
15 & 7 & \textcolor{blue}{00}\textcolor{green!70!black}{001}\textcolor{orange}{11} & 0 & 1 & \uncover<15->{\textcolor{green!70!black}{H}} & \uncover<15->{0/1} & \uncover<15->{Loaded again (14)} \\
\hline
\end{tabular}
\end{center}
\end{frame}

\section{Question 2: Array Initialization}
\begin{frame}[fragile]{Q2: Array Initialization}
\begin{columns}
\column{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize, frame=single, bgcolor=gray!10]{c}
int array[1024];
for (int i=0; i<1024; i++)
    array[i] = 0;
\end{minted}

\textbf{Assumptions:}
\begin{itemize}
    \item i and array pointer in registers
    \item int = 4 bytes, aligned
    \item Array aligned to cache line
\end{itemize}

\column{0.5\textwidth}
\textbf{Cache specs:}
\begin{itemize}
    \item 1KB data cache
    \item 4-way set associative
    \item 16-byte blocks
    \item Write through
    \item Write allocate
    \item Random replacement
\end{itemize}
\end{columns}
\end{frame}

\begin{frame}{Q2a: Cache Directory Size}
\textbf{Question:} How many bits in the cache directory?

\textbf{Solution:}
\begin{itemize}
    \item Cache size: 1KB = 1024 bytes
    \item Block size: 16 bytes $\rightarrow$ 4 offset bits
    \item Number of blocks: $\frac{1024}{16} = 64$ blocks
    \item 4-way associative $\rightarrow$ 16 sets $\rightarrow$ 4 set bits
    \item Tag bits: 32 - 4 (offset) - 4 (set) = 24 bits
    \item Per line: 24 (tag) + 1 (valid) = 25 bits
    \item No dirty bit (write-through), No LRU bits (random)
\end{itemize}

\addressbreakdown{24}{4}{4}

\textbf{Total:} $25 \times 4 \times 16 = 1600$ bits
\end{frame}

\begin{frame}{Q2b: Number of Misses}
\textbf{Question:} Maximum number of misses during execution?

\textbf{Solution:}
\begin{itemize}
    \item Array size: $1024 \text{ints} \times 4 \text{bytes} = 4096 \text{bytes}$
    \item Block size: 16 bytes (4 ints per block)
    \item Total blocks needed: $\frac{4096}{16} = 256$ blocks
    \item Each block loaded once (compulsory miss)
    \item 4 ints per block $\rightarrow$ 3 hits after each miss
\end{itemize}


\textbf{Result:} 
\begin{itemize}
    \item 256 misses total
    \item Miss rate = $\frac{256}{1024} = 0.25 = 25\%$
    \item All are compulsory misses
\end{itemize}
\end{frame}

\begin{frame}{Q2c: Effect of Alignment}
\textbf{Question:} What if array is not aligned?

\textbf{Answer:}
\begin{itemize}
    \item If array starts at non-aligned address
    \item Array might span 257 blocks instead of 256
    \item First block: partial use
    \item Last block: partial use
    \item Maximum misses: 257 (one extra)
\end{itemize}

\begin{center}
\begin{tcolorbox}[colback=red!10, width=0.8\textwidth]
Alignment matters for cache performance!
\end{tcolorbox}
\end{center}
\end{frame}

\begin{frame}{Q2d: No Write Allocate}
\textbf{Question:} How many blocks transferred if using no-write-allocate?

Given: Variable i at address 0x00000100

\textbf{Solution:}
\begin{itemize}
    \item In the loop: only writing to array elements
    \item Only reading: variable i (for loop condition)
    \item With no-write-allocate:
    \begin{itemize}
        \item Writes go directly to memory
        \item Only i's block fetched to cache
    \end{itemize}
    \item Address 0x00000100 is aligned
\end{itemize}

\textbf{Result:} Only 1 block transferred to cache
\end{frame}

\begin{frame}{Q2e: Locality Principles}
\textbf{Question:} Which locality principle is demonstrated in this code?
\pause

\textbf{Reminder - Two Types of Locality:}
\begin{itemize}
    \item \textbf{Temporal:} If we access an object, we're likely to access it again soon
    \item \textbf{Spatial:} If we access an object, we're likely to access nearby objects
\end{itemize}
\pause

\textbf{Answer:} \textbf{Spatial Locality}
\begin{itemize}
    \item Array stored contiguously in memory
    \item When we miss on one element, we fetch entire block
    \item Next 3 elements are hits (same block)
    \item Spatial locality saves 3 misses per block
\end{itemize}
\pause

\textbf{NOT Temporal Locality:}
\begin{itemize}
    \item Each array element accessed only once
    \item No reuse of data
    \item But variable i shows temporal locality (accessed 1024 times)
\end{itemize}
\end{frame}

\section{Question 3: Segment-Based Cache Design}
\begin{frame}{Q3: Segment-Based Cache Design}
\textbf{Problem Setup:}
\begin{itemize}
    \item 2-way set associative cache deployed in a system
    \item Physical memory divided into 4 equal segments (256MB each):
    \begin{itemize}
        \item A0, B0, A1, B1 (in this order)
    \end{itemize}
    \item \textbf{Design Requirement:} No more than 50\% of cache should contain addresses from A segments OR B segments
    \item Must maintain 2-way associativity
\end{itemize}

\textbf{Question:} Propose a simple and efficient method to implement this requirement and explain its operation.
\end{frame}

\begin{frame}{Q3a: Analysis}
\textbf{Step 1: Understanding Memory Segments}
\begin{itemize}
    \item Each segment is 256MB = $2^{28}$ bytes
    \item Total memory: 1GB = 4 segments
    \item Need 30 bits to address 1GB (ignoring upper 2 bits)
\end{itemize}
\pause

\textbf{Step 2: Segment Encoding in Address Bits}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Segment} & \textbf{Bits [29:28]} & \textbf{Address Range} \\
\hline
A0 & 00 & 0x00000000 - 0x0FFFFFFF \\
B0 & 01 & 0x10000000 - 0x1FFFFFFF \\
A1 & 10 & 0x20000000 - 0x2FFFFFFF \\
B1 & 11 & 0x30000000 - 0x3FFFFFFF \\
\hline
\end{tabular}
\end{center}
\pause

\textbf{Key Observation:}
\begin{itemize}
    \item Bit 28: distinguishes A (0) from B (1) segments
    \item This single bit can control cache partitioning!
\end{itemize}
\end{frame}

\begin{frame}{Q3b: Solution}
\textbf{Design Goal:} Ensure max 50\% cache for A segments, 50\% for B segments

\pause
\textbf{Original Cache Mapping (8 sets example):}
\begin{itemize}
    \item Address format: \addressbreakdown{25}{3}{2}
    \item Any address can map to any set (0-7)
    \item Problem: A segments could occupy 100\% of cache!
\end{itemize}

\pause
\textbf{Solution: Modified Set Mapping}
\begin{itemize}
    \item Include segment bit (bit 28) in set calculation
    \item New set field: concatenate bit 28 with original set bits
    \item Result: Sets 0-3 for A segments, Sets 4-7 for B segments
    \item Modified address format:
\begin{tikzpicture}[
    section/.style={draw, very thick, minimum height=0.6cm},
    bitnumber/.style={font=\tiny},
    sectionlabel/.style={font=\scriptsize},
    baseline=(current bounding box.center)
]
    % Tag section - bit 29
    \node[section, fill=blue!40, minimum width=0.17cm] (tag29) at (0,0) {};
    \node[sectionlabel, rotate=90, font=\tiny] at (tag29.center) {tag};
    \node[bitnumber] at ($(tag29.south) + (0mm,-1mm)$) {29};

    % Set section - bit 28 (segment bit)
    \node[section, fill=green!40, minimum width=0.17cm, anchor=west] (set28) at (tag29.east) {};
    \node[sectionlabel, rotate=90, font=\tiny] at (set28.center) {set};
    \node[bitnumber] at ($(set28.south) + (0mm,-1mm)$) {28};

    % Tag section - bits 27-5
    \node[section, fill=blue!40, minimum width=3.91cm, anchor=west] (tag275) at (set28.east) {};
    \node[sectionlabel] at (tag275.center) {tag};
    \node[bitnumber] at ($(tag275.south west) + (1mm,-1mm)$) {27};
    \node[bitnumber] at ($(tag275.south east) + (-1mm,-1mm)$) {5};

    % Set section - bits 4-2
    \node[section, fill=green!40, minimum width=0.51cm, anchor=west] (set42) at (tag275.east) {};
    \node[sectionlabel, rotate=90] at (set42.center) {set};
    \node[bitnumber] at ($(set42.south west) + (1mm,-1mm)$) {4};
    \node[bitnumber] at ($(set42.south east) + (-1mm,-1mm)$) {2};

    % Offset section - bits 1-0
    \node[section, fill=yellow!40, minimum width=0.34cm, anchor=west] (offset) at (set42.east) {};
    \node[sectionlabel, rotate=90, font=\tiny] at (offset.center) {offset};
    \node[bitnumber] at ($(offset.south west) + (1mm,-1mm)$) {1};
    \node[bitnumber] at ($(offset.south east) + (0mm,-1mm)$) {0};
\end{tikzpicture}
\end{itemize}
\end{frame}

\begin{frame}{Q3c: Concrete Example}
\textbf{Example Addresses and Their Mapping:}

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Address} & \textbf{Segment} & \textbf{Bit 28} & \textbf{Maps to Set} \\
\hline
\texttt{0x05000010} & A0 & 0 & 0-3 (A sets) \\
\texttt{0x12345678} & B0 & 0 & 4-7 (B sets) \\
\texttt{0x25000000} & A1 & 1 & 0-3 (A sets) \\
\texttt{0x3ABCDEF0} & B1 & 1 & 4-7 (B sets) \\
\hline
\end{tabular}
\end{center}

\pause
\vspace{0.5cm}
\textbf{Cache Organization Result:}
\begin{columns}
\column{0.5\textwidth}
\begin{center}
\textbf{Sets 0-3: A segments only}
\begin{itemize}
    \item Can cache data from A0 and A1
    \item Maximum 50\% of total cache
    \item 2-way associative within group
\end{itemize}
\end{center}

\column{0.5\textwidth}
\begin{center}
\textbf{Sets 4-7: B segments only}
\begin{itemize}
    \item Can cache data from B0 and B1
    \item Maximum 50\% of total cache
    \item 2-way associative within group
\end{itemize}
\end{center}
\end{columns}

\begin{tcolorbox}[colback=green!10]
\textbf{Advantages:} Simple hardware, guaranteed 50/50 split, maintains associativity
\end{tcolorbox}
\end{frame}

\section{Summary}
\begin{frame}{Cache Design Trade-offs}
\begin{table}
\centering
\small
\begin{tabular}{lcc}
\toprule
\textbf{Design Choice} & \textbf{Advantage} & \textbf{Disadvantage} \\
\midrule
Fully Associative & High hit rate & Expensive hardware \\
Direct Mapped & Simple, cheap & Higher miss rate \\
Set Associative & Good compromise & Moderate complexity \\
\midrule
Write Back & Less memory traffic & Needs dirty bit, complexity \\
Write Through & Simple, consistent & More memory traffic \\
\midrule
Write Allocate & Good locality exploitation & Transfer overhead \\
No Write Allocate & Simple, less traffic & May miss reuse \\
\midrule
Large blocks & Better spatial locality & More transfer time \\
Small blocks & Less wasted transfer & Poor spatial locality \\
\bottomrule
\end{tabular}
\end{table}
\end{frame}

\begin{frame}{Key Takeaways}
\begin{itemize}
    \item Cache exploits temporal and spatial locality
    \item Set associativity provides good performance/cost trade-off
    \item Write policies affect memory traffic and complexity
    \item Different miss types require different optimizations:
    \begin{itemize}
        \item Compulsory: Larger blocks, prefetching
        \item Conflict: Increase associativity
        \item Capacity: Increase cache size
    \end{itemize}
    \item Implementation details matter:
    \begin{itemize}
        \item Alignment affects performance
        \item LRU can be optimized for space
        \item Directory overhead is significant
    \end{itemize}
    \item Real systems use multi-level hierarchies (L1, L2, L3)
\end{itemize}
\end{frame}

\end{document}