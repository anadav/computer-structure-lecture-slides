\documentclass[aspectratio=169,12pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{booktabs}
\usepackage{colortbl}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, positioning, shapes.geometric, calc, tikzmark, shapes.misc, fit, decorations.pathreplacing, matrix}
\usepackage{tcolorbox}
\usepackage{array}
\usepackage{listings}
\usepackage{pgfkeys}
\usepackage{adjustbox}
\usepackage[normalem]{ulem} 
\usetheme{Madrid}

% Custom colors - consolidated
\definecolor{correctgreen}{RGB}{0,150,0}
\definecolor{incorrectred}{RGB}{200,0,0}
\definecolor{counterblue}{RGB}{70,130,255}
\definecolor{highlightyellow}{RGB}{255,230,100}
\definecolor{lightblue}{RGB}{200,230,250}
\definecolor{darkblue}{RGB}{0,100,200}
\definecolor{highlightorange}{RGB}{255,200,100}

% PGF Keys for pipeline diagram configuration
\pgfkeys{
    /pipeline/.cd,
    % Stage colors
    ifcolor/.initial=lightblue,
    idcolor/.initial=lightblue,
    excolor/.initial=lightblue,
    memcolor/.initial=lightblue,
    wbcolor/.initial=lightblue,
    % Execution unit contents
    integercontent/.initial={},
    multiplycontent/.initial={},
    dividercontent/.initial={},
    % Instruction list
    instructions/.initial={},
    % Highlight colors for specific units
    highlightinteger/.initial=white,
    highlightmultiply/.initial=white,
    highlightdivider/.initial=white,
    % Individual multiply stage highlights
    highlightM1/.initial=white,
    highlightM2/.initial=white,
    highlightM3/.initial=white,
    highlightM4/.initial=white,
    % Individual divider stage highlights
    highlightD1/.initial=white,
    highlightD2/.initial=white,
    highlightD3/.initial=white,
    highlightD4/.initial=white,
    highlightD5/.initial=white,
    highlightD6/.initial=white
}

% Macro for drawing the pipeline diagram
\newcommand{\drawPipeline}[1][]{%
    \pgfkeys{/pipeline/.cd,#1}%
    \begin{tikzpicture}[scale=0.8, transform shape]
        % Pipeline stages
        \node[draw, fill=\pgfkeysvalueof{/pipeline/ifcolor}, minimum width=1.2cm, minimum height=0.8cm] (IF) {IF};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/idcolor}, minimum width=1.2cm, minimum height=0.8cm, right=of IF] (ID) {ID};
        
        % Multiply pipeline (4 stages) - each stage can be individually highlighted
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightM1}, minimum width=0.8cm, minimum height=0.6cm, right=2cm of ID.east] (M1) {M1};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightM2}, minimum width=0.8cm, minimum height=0.6cm, right=0.5cm of M1] (M2) {M2};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightM3}, minimum width=0.8cm, minimum height=0.6cm, right=0.5cm of M2] (M3) {M3};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightM4}, minimum width=0.8cm, minimum height=0.6cm, right=0.5cm of M3] (M4) {M4};
        
        % Divider pipeline (multi-stage) - each stage can be individually highlighted
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightD2}, minimum width=0.6cm, minimum height=0.6cm] (D2) at ($(M1) + (0,-1.2)$) {D2};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightD1}, minimum width=0.6cm, minimum height=0.6cm, left=0.4cm of D2] (D1) {D1};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightD3}, minimum width=0.6cm, minimum height=0.6cm, right=0.4cm of D2] (D3) {D3};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightD4}, minimum width=0.6cm, minimum height=0.6cm, right=0.4cm of D3] (D4) {D4};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightD5}, minimum width=0.6cm, minimum height=0.6cm, right=0.4cm of D4] (D5) {D5};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightD6}, minimum width=0.6cm, minimum height=0.6cm, right=0.4cm of D5] (D6) {D6};

        % Integer unit (single stage) - positioned between M2 and M3 horizontally, same distance above M as M is above D
        \node[draw, fill=\pgfkeysvalueof{/pipeline/highlightinteger}, minimum width=1cm, minimum height=0.6cm] (EX) at ($(M2)!0.5!(M3) + (0,1.2)$) {EX};
         
        % Labels for units
        \node[below=0.1cm of EX, font=\footnotesize] (intlabel) {Integer unit};
        \node[below=0.1cm of M2.south east, font=\footnotesize] (mullabel) {Multiply};
        \node[below=0.1cm of D3.south east, font=\footnotesize] (divlabel){Divider};

        % Execution box (drawn after units to be in background) - fits around all execution units
        \node[draw, thick, dashed, fit=(EX)(M1)(M2)(M3)(M4)(D1)(D2)(D3)(D4)(D5)(D6)(intlabel)(mullabel)(divlabel), inner sep=0.3cm] (execbox) {};
        \node[above=0 of execbox.north, anchor=south, font=\small] {Execution};
         
        % MEM and WB stages - positioned relative to execution box
        \node[draw, fill=\pgfkeysvalueof{/pipeline/memcolor}, minimum width=1.2cm, minimum height=0.8cm, right=3cm of M4.west] (MEM) {MEM};
        \node[draw, fill=\pgfkeysvalueof{/pipeline/wbcolor}, minimum width=1.2cm, minimum height=0.8cm, right=of MEM] (WB) {WB};
        
        % Connections from IF to ID
        \draw[->, thick] (IF) -- (ID);
        
        % Connections from ID to execution units - DO NOT CHANGE
        \draw[->, thick] (ID.east) -- ([xshift=-2cm]EX.west) |- (EX.west);
        \draw[->, thick] (ID.east) -- (M1.west);
        \draw[->, thick] (ID.east) -- ([xshift=-3mm]D1.west) -- (D1.west);
        
        % Connections within multiply pipeline
        \draw[->, thick] (M1) -- (M2);
        \draw[->, thick] (M2) -- (M3);
        \draw[->, thick] (M3) -- (M4);
        
        % Connections within divider pipeline
        \draw[->, thick] (D1) -- (D2);
        \draw[->, thick] (D2) -- (D3);
        \draw[->, thick] (D3) -- (D4);
        \draw[->, thick] (D4) -- (D5);
        \draw[->, thick] (D5) -- (D6);
        
        % Connections from execution units to MEM - DO NOT CHANGE
        \draw[->, thick] (EX.east) -- ([xshift=2cm]EX.east) -- ([xshift=-3mm]MEM.west) -- (MEM.west);
        \draw[->, thick] (M4.east) -- (MEM.west);
        \draw[->, thick] (D6.east) -- ([xshift=-3mm]MEM.west) -- (MEM.west);
        
        % Connection from MEM to WB
        \draw[->, thick] (MEM) -- (WB);
        
        % Add content to execution units if specified
        \pgfkeysgetvalue{/pipeline/integercontent}{\intcontent}
        \ifx\intcontent\empty\else
            \node[above=0.1cm of EX, font=\footnotesize, text=blue] {\intcontent};
        \fi
        
        \pgfkeysgetvalue{/pipeline/multiplycontent}{\mulcontent}
        \ifx\mulcontent\empty\else
            \node[above=0.1cm of M2, font=\footnotesize, text=blue] {\mulcontent};
        \fi
        
        \pgfkeysgetvalue{/pipeline/dividercontent}{\divcontent}
        \ifx\divcontent\empty\else
            \node[above=0.1cm of D3, font=\footnotesize, text=blue] {\divcontent};
        \fi
        
        % Instruction list
        \pgfkeysgetvalue{/pipeline/instructions}{\instlist}
        \ifx\instlist\empty\else
            \node[right=0.5cm of WB, align=left, font=\footnotesize] {\instlist};
        \fi
    \end{tikzpicture}%
}

% Macro for ROB diagram
\newcommand{\drawROB}[1]{%
    \begin{tikzpicture}[scale=0.8]
        \matrix (rob) [matrix of nodes, 
            nodes={draw, minimum width=2cm, minimum height=0.5cm, anchor=center},
            row sep=-\pgflinewidth,
            column sep=-\pgflinewidth,
            ] {
            #1
        };
        \node[left=0.3cm of rob-1-1] {P0};
        \node[left=0.3cm of rob-2-1] {P1};
        \node[left=0.3cm of rob-3-1] {P2};
        \node[left=0.3cm of rob-4-1] {P3};
        \node[below=0.1cm of rob-4-1] {$\vdots$};
        \node[left=0.3cm of rob-5-1] {Pn};
    \end{tikzpicture}
}

\title{Out-of-Order Execution: Part I}
\subtitle{Breaking the In-Order Bottleneck}
\author{Computer Architecture}
\date{\today}

\begin{document}

\frame{\titlepage}

\begin{frame}{Execution of Instructions with Variable Execution Time}
    \begin{itemize}
        \item \textbf{Problem:} Single cycle Execution phase $\rightarrow$ The longest operation possible in the machine fixes the frequency
        \begin{itemize}
            \item Example: \textcolor{blue}{ADD/SUB=2ns, MUL=10ns, DIV=20ns} $\rightarrow$ \textcolor{red}{cc=20ns}
        \end{itemize}
        
        \item \textbf{Solution:} Implement a \textcolor{blue}{pipeline} in EXE
        \begin{itemize}
            \item Execution time of certain instructions is now variable (i.e. load with or without cache miss)
            \item More pipe stages = bigger penalty on misprediction and more data hazards (but generally an increase in CPI)
        \end{itemize}
    \end{itemize}
    
    \vspace{0.5cm}
    \centering
    \drawPipeline
\end{frame}

\begin{frame}{Pipeline Stage Progression: Multiply Unit}
    \begin{exampleblock}{Example: R2 $\leftarrow$ R3 * R3}
        The multiply operation takes 4 cycles, progressing through stages M1 $\rightarrow$ M2 $\rightarrow$ M3 $\rightarrow$ M4
    \end{exampleblock}
    \centering
    \drawPipeline
\end{frame}

\begin{frame}{Multiply Pipeline: Cycle 1}
    \centering
    \drawPipeline[
        highlightM1=highlightyellow,
        multiplycontent={R2 $\leftarrow$ R3*R3}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stage M1}
        First stage of multiplication - operand fetch and partial product generation
    \end{alertblock}
\end{frame}

\begin{frame}{Multiply Pipeline: Cycle 2}
    \centering
    \drawPipeline[
        highlightM2=highlightyellow,
        multiplycontent={R2 $\leftarrow$ R3*R3}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stage M2}
        Second stage - partial product accumulation
    \end{alertblock}
\end{frame}

\begin{frame}{Multiply Pipeline: Cycle 3}
    \centering
    \drawPipeline[
        highlightM3=highlightyellow,
        multiplycontent={R2 $\leftarrow$ R3*R3}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stage M3}
        Third stage - final partial products
    \end{alertblock}
\end{frame}

\begin{frame}{Multiply Pipeline: Cycle 4}
    \centering
    \drawPipeline[
        highlightM4=correctgreen,
        multiplycontent={R2 $\leftarrow$ R3*R3}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stage M4 - Complete}
        Final stage - result ready for writeback
    \end{alertblock}
\end{frame}

\begin{frame}{Pipeline Stage Progression: Divider Unit}
    \begin{exampleblock}{Example: R5 $\leftarrow$ R6 / R7}
        Division takes 6+ cycles, progressing through stages D1 $\rightarrow$ D2 $\rightarrow$ D3 $\rightarrow$ D4 $\rightarrow$ D5 $\rightarrow$ D6
    \end{exampleblock}
    \centering
    \drawPipeline
\end{frame}

\begin{frame}{Divider Pipeline: Cycles 1-2}
    \centering
    \drawPipeline[
        highlightD1=highlightyellow,
        highlightD2=highlightyellow,
        dividercontent={R5 $\leftarrow$ R6/R7}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stages D1-D2}
        Initial quotient digit generation
    \end{alertblock}
\end{frame}

\begin{frame}{Divider Pipeline: Cycles 3-4}
    \centering
    \drawPipeline[
        highlightD3=highlightyellow,
        highlightD4=highlightyellow,
        dividercontent={R5 $\leftarrow$ R6/R7}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stages D3-D4}
        Intermediate quotient refinement
    \end{alertblock}
\end{frame}

\begin{frame}{Divider Pipeline: Cycles 5-6}
    \centering
    \drawPipeline[
        highlightD5=highlightyellow,
        highlightD6=correctgreen,
        dividercontent={R5 $\leftarrow$ R6/R7}
    ]
    \vspace{0.3cm}
    \begin{alertblock}{Stages D5-D6 - Complete}
        Final quotient and remainder computation
    \end{alertblock}
\end{frame}

\begin{frame}{Example - In-Order Execution}
    \centering
    \drawPipeline[
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4}
    ]
\end{frame}

\begin{frame}{In-Order Execution: Cycle 1}
    \centering
    \drawPipeline[
        integercontent={R1 $\leftarrow$ R1+4},
        multiplycontent={R2 $\leftarrow$ R3*R3},
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4},
        highlightinteger=highlightyellow,
        highlightmultiply=highlightyellow
    ]
\end{frame}

\begin{frame}{In-Order Execution: Cycle 2}
    \centering
    \drawPipeline[
        integercontent={R4 $\leftarrow$ R3+R4},
        multiplycontent={R2 $\leftarrow$ R3*R3},
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4},
        highlightinteger=highlightyellow,
        highlightmultiply=highlightyellow
    ]
    \vspace{0.5cm}
    
    \textcolor{red}{Note: R4 instruction is blocked waiting for R2 multiplication to complete!}
\end{frame}

\begin{frame}{In-Order Execution: Cycles 3-4}
    \centering
    \drawPipeline[
        multiplycontent={R2 $\leftarrow$ R3*R3},
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4},
        highlightmultiply=highlightyellow
    ]
    \vspace{0.5cm}
    
    The multiplication continues through M2, M3, M4 stages...
\end{frame}

\begin{frame}{In-Order Execution: Final State}
    \centering
    \drawPipeline[
        integercontent={R4 $\leftarrow$ R3+R4},
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4},
        highlightinteger=highlightyellow
    ]
    \vspace{0.5cm}
    
    Finally, R4 can execute after R2 completes
\end{frame}

\begin{frame}{Execution with Variable Time - The Problem}
    \begin{block}{Problem}
        A short operation might get "stuck" waiting for another operation of a different type to leave the Execution phase.
    \end{block}
    
    \begin{block}{Solution}
        Allow instructions of different types/pipelines to be executed \textbf{Out of Order}.
        \begin{itemize}
            \item Execute many independent instructions in parallel (in different pipelines)
            \item Improves CPI
            \item Execution must keep correctness of the code
        \end{itemize}
    \end{block}
    
    \begin{alertblock}{Note}
        If an operation gets "stuck" waiting for another operation of the same type to leave the Execution phase $\rightarrow$ \textbf{Structural Hazard} (need to add more execution units to solve).
    \end{alertblock}
\end{frame}

\begin{frame}{Out-of-Order Execution: Cycle 1}
    \centering
    \drawPipeline[
        integercontent={R1 $\leftarrow$ R1+4},
        multiplycontent={R2 $\leftarrow$ R3*R3},
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4},
        highlightinteger=highlightyellow,
        highlightmultiply=highlightyellow
    ]
\end{frame}

\begin{frame}{Out-of-Order Execution: Cycle 2}
    \centering
    \drawPipeline[
        integercontent={R4 $\leftarrow$ R3+R4},
        multiplycontent={R2 $\leftarrow$ R3*R3},
        instructions={R1 $\leftarrow$ R1+4\\R2 $\leftarrow$ R3*R3\\R4 $\leftarrow$ R3+R4},
        highlightinteger=correctgreen,
        highlightmultiply=highlightyellow
    ]
    \vspace{0.5cm}
    
    \textcolor{correctgreen}{R4 can execute immediately - no need to wait!}
\end{frame}

\begin{frame}{CPI Limitations}
    \begin{itemize}
        \item In \textbf{in-order} machines as we've known until today, the minimum CPI achievable is 1
        \item Even with OOO execution, this limit exists as long as we only allow parallel execution in the EXE stage
    \end{itemize}
    %\begin{columns}
        %\column{0.2\textwidth}
        %\column{0.6\textwidth}
            \centering
        \begin{tikzpicture}[stage/.style={font=\bfseries, inner sep=1pt}]
            %--- stage labels (center line) ---
            \node (IF)  {IF};
            \node (ID)  [right=of IF]  {ID};
            \node (EXE) [right=of ID]  {EXE};
            \node (MEM) [right=of EXE] {MEM};
            \node (WB)  [right=of MEM] {WB};

            % vertical offset of the rails
            \def\dy{0.55}
            % small horizontal margin at the ends
            \def\marg{0.6}
            
            % helper points for where the bump starts/ends (midpoints around EXE)
            \coordinate (LT) at ($(ID.east)!0.5!(EXE.west)$);
            \coordinate (RT) at ($(EXE.east)!0.5!(MEM.west)$);

            %---- TOP rail: left segment, bump, right segment
            \draw[very thick] ($(IF.west)+(-\marg,\dy)$) -- ($(LT)+(0,\dy)$);
            \draw[very thick] ($(LT)+(0,\dy)$)
                .. controls ($(EXE.north)+(0,0.9)$) ..
                ($(RT)+(0,\dy)$);
            \draw[very thick] ($(RT)+(0,\dy)$) -- ($(WB.east)+(\marg,\dy)$);

            %---- BOTTOM rail: left segment, bump (down), right segment
            \draw[very thick] ($(IF.west)+(-\marg,-\dy)$) -- ($(LT)+(0,-\dy)$);
            \draw[very thick] ($(LT)+(0,-\dy)$)
                .. controls ($(EXE.south)+(0,-0.9)$) ..
                ($(RT)+(0,-\dy)$);
            \draw[very thick] ($(RT)+(0,-\dy)$) -- ($(WB.east)+(\marg,-\dy)$);
        \end{tikzpicture}
   % \end{columns}

    \begin{itemize}
        \item If we allow multiple instructions to execute in parallel in \textbf{all stages}, we can break this barrier
    \end{itemize}

    \centering
    \begin{tikzpicture}[stage/.style={font=\bfseries, inner sep=1pt}]
        %--- stage labels (center line) ---
        \node (IF)  {IF};
        \node (ID)  [right=of IF]  {ID};
        \node (EXE) [right=of ID]  {EXE};
        \node (MEM) [right=of EXE] {MEM};
        \node (WB)  [right=of MEM] {WB};

        \def\dy{0.62}
        \def\dyarrowx{0.5cm}
        \def\dyarrowy{0.1cm}
        \def\marg{0.6}

        % rails
        \draw[very thick] ($(IF.west)+(-\marg,\dy)$) -- ($(WB.east)+(\marg,\dy)$);
        \draw[very thick] ($(IF.west)+(-\marg,-\dy)$) -- ($(WB.east)+(\marg,-\dy)$);
        
        \foreach \a in {IF,ID,EXE,MEM,WB}{
            \draw[-{Stealth}]
                ($(\a.north)+(-\dyarrowx,\dyarrowy)$) --
                ($(\a.north)+(\dyarrowx,\dyarrowy)$);
            \draw[-{Stealth}]
                ($(\a.south)+(-\dyarrowx,-\dyarrowy)$) --
                ($(\a.south)+(\dyarrowx,-\dyarrowy)$);
        }

    \end{tikzpicture}


    \vspace{0.5cm}
    \centering

\end{frame}

\begin{frame}{True Dependencies: RAW Hazards}
    \begin{exampleblock}{Read After Write (RAW)}
        {\ttfamily\footnotesize
        (1) ADD \textcolor{red}{R1}, R2, R3\\
        (2) ADD R5, R6, \textcolor{red}{R1}  // Must wait for \textcolor{red}{R1}
        }
    \end{exampleblock}
    
    \begin{alertblock}{Key Point}
        RAW hazards represent \textbf{true data dependencies} that cannot be eliminated—only the data flow defines program correctness.
    \end{alertblock}
\end{frame}

\begin{frame}{False Dependencies: WAR Hazards}
    \begin{exampleblock}{Write After Read (WAR)}
        {\ttfamily\footnotesize
        (1) DIV R1, R2, R3  // 40 cycles\\
        (2) ADD R5, \textcolor{red}{R6}, R1  // Waits for R1\\
        (3) ADD \textcolor{red}{R6}, R7, R8  // Could execute early!
        }
    \end{exampleblock}
    
    \begin{block}{The Problem}
        If (3) executes before (2), instruction (2) reads the \textbf{wrong} \textcolor{red}{R6} value.
    \end{block}
    
    \begin{alertblock}{Key Insight}
        WAR hazards are \textbf{artificial}—caused by register name reuse, not data flow.
    \end{alertblock}
\end{frame}

\begin{frame}{False Dependencies: WAW Hazards}
    \begin{exampleblock}{Write After Write (WAW)}
        {\ttfamily\footnotesize
        (1) DIV R1, R2, R3  // 40 cycles\\
        (2) ADD \textcolor{red}{R5}, R6, R1  // Waits for R1\\
        (3) ADD \textcolor{red}{R5}, R7, R8  // Could execute early!
        }
    \end{exampleblock}
    
    \begin{block}{The Problem}
        If (3) executes before (2), \textcolor{red}{R5} gets the \textbf{wrong} final value.
    \end{block}
    
    \begin{alertblock}{Solution Preview}
        Both WAR and WAW are \textbf{false dependencies}—register renaming eliminates them entirely.
    \end{alertblock}
\end{frame}

\begin{frame}{Register Renaming: Eliminating False Dependencies}
    \begin{block}{The Mechanism}
        \begin{itemize}
            \item \textbf{Architectural registers:} What the program sees (R0-R31)
            \item \textbf{Physical registers:} What the hardware uses (P0-P127)
            \item Dynamic mapping eliminates name conflicts
        \end{itemize}
    \end{block}
    
    \begin{exampleblock}{Renaming in Action}
        {\ttfamily\small
        \textcolor{red}{R1} $\leftarrow$ R2+R3  $\Rightarrow$  \textcolor{correctgreen}{P17} $\leftarrow$ P5+P8\\
        \textcolor{red}{R1} $\leftarrow$ R4+R5  $\Rightarrow$  \textcolor{correctgreen}{P23} $\leftarrow$ P11+P14
        }
    \end{exampleblock}
    
    \begin{alertblock}{Result}
        No WAR or WAW hazards—different physical registers for each write!
    \end{alertblock}
\end{frame}

\begin{frame}{Register Renaming - Implementation}
    We maintain two mappings:
    
    \begin{enumerate}
        \item \textbf{Architectural → Physical:} (e.g., R5→P8)
        \begin{itemize}
            \item For resolving false dependencies
            \item Saved during decode → execution transition
        \end{itemize}
        
        \item \textbf{Physical → Architectural:} (e.g., P8→R5)
        \begin{itemize}
            \item For saving the value back to the intended register
            \item Saved as part of the commit stage
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{OOO Execution Processor Architecture}
    \centering
    \begin{tikzpicture}[scale=1.2]
        % Stages
        \node[draw, fill=lightblue, minimum width=2cm, minimum height=1cm] (fetch) at (0,0) {Fetch \& Decode};
        \node[draw, fill=highlightorange, minimum width=2cm, minimum height=1cm, rounded corners] (exe) at (4,0) {EXE};
        \node[draw, fill=lightblue, minimum width=2cm, minimum height=1cm] (retire) at (8,0) {Retire (commit)};
        
        % Labels
        \node[below=0.2cm of fetch] {\textbf{In-order}};
        \node[below=0.2cm of exe] {\textbf{Out-of-order}};
        \node[below=0.2cm of retire] {\textbf{In-order}};
        
        % Arrows
        \draw[->, thick] (fetch) -- (exe);
        \draw[->, thick] (exe) -- (retire);
        
        % Annotations
        \node[above=0.5cm of fetch, text width=2cm, align=center] {Next instruction slot};
        \node[above=0.5cm of retire, text width=2cm, align=center] {Next instruction to commit};
    \end{tikzpicture}
    
    \vspace{0.5cm}
    Most modern processors perform fetch/decode and commit stages \textbf{in-order}, while only the execution stage is \textbf{out-of-order}.
\end{frame}

\begin{frame}{ROB (Re-Order Buffer)}
    \begin{itemize}
        \item A common implementation of Register Renaming uses ROB
        \item ROB is a buffer that receives instructions from decode stage in order
        \item The corresponding ROB entry serves as the physical register number for the instruction's destination
        \item After EXE stage, the result is written to the corresponding ROB entry
        \item Instructions commit (exit the processor) in ROB order: an instruction can only commit if the one before it has committed
    \end{itemize}
    
    \vspace{0.5cm}
    \centering
    \drawROB{
        R2/R3 \\
        R4+P0 \\
        R3+R3 \\
        R3+P2 \\
        {} \\
    }
\end{frame}

\begin{frame}{ROB Example - Initial State}
    \begin{columns}
        \column{0.4\textwidth}
        Instructions:
        {\ttfamily\small
        DIV R1, R2, R3\\
        ADD R2, R4, R1\\
        ADD R2, R3, R3\\
        ADD R4, R3, R2
        }
        
        \column{0.6\textwidth}
        \centering
        ROB (Cyclic Buffer):
        
        \drawROB{
            {} \\
            {} \\
            {} \\
            {} \\
            {} \\
        }
        
        \begin{tikzpicture}
            \node[draw, minimum width=3cm] (renamer) at (0,-2) {Renamer};
            \node[left=0.2cm of renamer] {Arch reg};
            \node[right=0.2cm of renamer] {Phys reg};
        \end{tikzpicture}
    \end{columns}
\end{frame}

\begin{frame}{ROB Example - After First Instruction}
    \begin{columns}
        \column{0.4\textwidth}
        Instructions:
        {\ttfamily\small
        DIV R1, R2, R3  \checkmark\\
        ADD R2, R4, R1\\
        ADD R2, R3, R3\\
        ADD R4, R3, R2
        }
        
        \column{0.6\textwidth}
        \centering
        ROB:
        
        \drawROB{
            R2/R3 \\
            {} \\
            {} \\
            {} \\
            {} \\
        }
        
        \vspace{0.2cm}
        {\small R1 $\rightarrow$ P0}
    \end{columns}
\end{frame}

\begin{frame}{ROB Example - After All Instructions}
    \begin{columns}
        \column{0.4\textwidth}
        Instructions:
        {\ttfamily\small
        DIV R1, R2, R3  \checkmark\\
        ADD R2, R4, R1  \checkmark\\
        ADD R2, R3, R3  \checkmark\\
        ADD R4, R3, R2  \checkmark
        }
        
        \textcolor{correctgreen}{Note: No more False Dependencies! (but RAW still exists)}
        
        \column{0.6\textwidth}
        \centering
        ROB:
        
        \drawROB{
            R2/R3 \\
            R4+P0 \\
            R3+R3 \\
            R3+P2 \\
            {} \\
        }
        
        \vspace{0.2cm}
        {\small 
        R1 $\rightarrow$ P0\\
        R2 $\rightarrow$ P1\\
        R2 $\rightarrow$ P2\\
        R4 $\rightarrow$ P3
        }
    \end{columns}
\end{frame}

\begin{frame}{OOO Scheme Overview}
    \centering
    \begin{tikzpicture}[scale=1]
        % Main components
        \node[draw, fill=lightblue, minimum width=1.5cm, minimum height=3cm] (fe) at (0,0) {};
        \node at (0,0) {FE};
        
        \node[draw, fill=lightblue, minimum width=1.5cm, minimum height=3cm] (id) at (2,0) {};
        \node at (2,0) {ID};
        
        \node[draw, fill=lightblue, minimum width=1.5cm, minimum height=3cm] (alloc) at (4,0) {};
        \node at (4,0) {ALLOC};
        
        % OOO section (background box)
        \node[draw, fill=gray!20, rounded corners, minimum width=4cm, minimum height=3.5cm] (ooo) at (7,0) {};
        \node at (7,1.3) {\textbf{OOO}};
        \node at (7,0.7) {\footnotesize Not a single cycle};
        \node[draw, fill=darkblue, text=white, minimum width=3cm, minimum height=0.8cm] at (7,-0.3) {EXE/MEM + WB};
        
        \node[draw, fill=darkblue, text=white, minimum width=2cm, minimum height=3cm] (commit) at (10.5,0) {};
        \node[rotate=90] at (10.5,0) {Commit (Retire)};
        
        % Arrows
        \draw[->, thick] (fe) -- (id);
        \draw[->, thick] (id) -- (alloc);
        \draw[->, thick] (alloc) -- (5.5,0);
        \draw[->, thick] (8.5,0) -- (commit);
    \end{tikzpicture}
\end{frame}

\begin{frame}{Summary: Out-of-Order Execution}
    \begin{block}{The Journey}
        \begin{enumerate}
            \item \textbf{Problem:} Long-latency operations stall the pipeline
            \item \textbf{Solution:} Execute independent instructions out of order
            \item \textbf{Challenge:} False dependencies (WAR, WAW)
            \item \textbf{Solution:} Register renaming with ROB
        \end{enumerate}
    \end{block}
    
    \begin{exampleblock}{Modern Processor Pipeline}
        \begin{itemize}
            \item \textbf{Front-end:} In-order fetch and decode
            \item \textbf{Execution:} Out-of-order with multiple units
            \item \textbf{Back-end:} In-order commit (retirement)
        \end{itemize}
    \end{exampleblock}
    
    \begin{alertblock}{Bottom Line}
        OOO execution dramatically improves IPC by hiding latencies and maximizing parallelism.
    \end{alertblock}
\end{frame}

\begin{frame}{Historical Note: IBM System/360 Model 91 (1966)}
    \begin{columns}
        \column{0.4\textwidth}
        \includegraphics[width=\textwidth]{figures/ibm360m91.jpg}
        
        \vspace{0.2cm}
        \scriptsize Photo: NASA Goddard Space Flight Center
        {
            \fontsize{4}{5}\selectfont
            By Bundesarchiv, B 145 Bild-F038812-0014 / Schaack, Lothar / 
            \href{https://commons.wikimedia.org/w/index.php?curid=5455799}{CC-BY-SA 3.0}
        }
        
        \column{0.6\textwidth}
        \begin{itemize}
            \item \textbf{First IBM computer} with out-of-order execution
            \item Developed by Robert Tomasulo at IBM
            \item Introduced the \textbf{Tomasulo Algorithm}:
            \begin{itemize}
                \footnotesize
                \item Register renaming via reservation stations
                \item Dynamic scheduling
                \item Common Data Bus (CDB) for results
            \end{itemize}
            \item \textbf{Performance:} 16.6 MFLOPS peak
            \item \textbf{Cost:} \$6-7 million (1966 dollars)
        \end{itemize}
    \end{columns}
    
    \vspace{0.3cm}
    \begin{alertblock}{Legacy}
        The Tomasulo algorithm's concepts remain fundamental to modern processors—every high-performance CPU today uses variations of these techniques.
    \end{alertblock}
\end{frame}

\end{document}