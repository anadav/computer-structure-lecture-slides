#!/usr/bin/env python3
"""
Find overfull boxes in LaTeX presentations.

Parses the .log file generated by pdflatex to find overfull hbox/vbox warnings
and reports which pages have content that doesn't fit.

Usage:
    python find_overfull.py <tex_file_or_log_file>
    python find_overfull.py presentation.tex
    python find_overfull.py build/presentation.log
"""

import argparse
import re
import sys
from pathlib import Path
from collections import defaultdict
from dataclasses import dataclass
from typing import Optional


@dataclass
class OverfullWarning:
    """Represents an overfull box warning."""
    box_type: str  # 'hbox' or 'vbox'
    badness: float  # how much it's overfull (in pt)
    page: Optional[int]
    source_line: Optional[int]  # line number in source .tex file
    line_in_log: int
    context: str  # the text/content causing the issue


def find_log_file(input_path: Path) -> Path:
    """Find the log file for the given input (tex or log file)."""
    if input_path.suffix == '.log':
        return input_path

    # Try common locations for log file
    candidates = [
        input_path.with_suffix('.log'),
        Path('build') / input_path.with_suffix('.log').name,
        input_path.parent / 'build' / input_path.with_suffix('.log').name,
    ]

    for candidate in candidates:
        if candidate.exists():
            return candidate

    raise FileNotFoundError(
        f"Could not find log file for {input_path}. "
        f"Tried: {', '.join(str(c) for c in candidates)}"
    )


def parse_log_file(log_path: Path) -> list[OverfullWarning]:
    """Parse a LaTeX log file and extract overfull box warnings."""
    warnings = []
    current_page = 0

    # Pattern for overfull warnings
    # Examples:
    # Overfull \hbox (12.34pt too wide) in paragraph at lines 100--105
    # Overfull \vbox (5.0pt too high) detected at line 383
    overfull_pattern = re.compile(
        r'Overfull \\([hv]box) \(([0-9.]+)pt too (?:wide|high)\)'
    )

    # Pattern to extract source line numbers
    # "at lines 100--105" or "at line 383"
    source_line_pattern = re.compile(r'at lines? (\d+)')

    # Pattern for page numbers - can be [1 or [1] or [1{
    # Page markers in beamer often appear as [1 on their own line
    page_pattern = re.compile(r'\[(\d+)[\]\{\s]?')

    with open(log_path, 'r', encoding='utf-8', errors='replace') as f:
        lines = f.readlines()

    i = 0
    while i < len(lines):
        line = lines[i]

        # Track current page - check for page markers
        for match in page_pattern.finditer(line):
            page_num = int(match.group(1))
            # Only update if it's a reasonable progression (avoid false matches)
            if page_num >= current_page:
                current_page = page_num

        # Check for overfull warning
        overfull_match = overfull_pattern.search(line)
        if overfull_match:
            box_type = overfull_match.group(1)
            badness = float(overfull_match.group(2))

            # Extract source line number
            source_line = None
            source_match = source_line_pattern.search(line)
            if source_match:
                source_line = int(source_match.group(1))

            # Get context (next few lines often contain the problematic content)
            context_lines = []
            for j in range(i + 1, min(i + 4, len(lines))):
                context_line = lines[j].strip()
                if context_line and not context_line.startswith('\\') and not context_line.startswith('['):
                    context_lines.append(context_line)
                if context_line.startswith('[') or 'Overfull' in context_line:
                    break

            context = ' '.join(context_lines)[:100]  # Limit context length

            # The warning appears before the page is shipped out,
            # so the content is on the NEXT page
            warnings.append(OverfullWarning(
                box_type=box_type,
                badness=badness,
                page=current_page + 1 if current_page > 0 else None,
                source_line=source_line,
                line_in_log=i + 1,
                context=context
            ))

        i += 1

    return warnings


def group_by_page(warnings: list[OverfullWarning]) -> dict[Optional[int], list[OverfullWarning]]:
    """Group warnings by page number."""
    by_page = defaultdict(list)
    for w in warnings:
        by_page[w.page].append(w)
    return dict(by_page)


def main():
    parser = argparse.ArgumentParser(
        description='Find overfull boxes in LaTeX presentations'
    )
    parser.add_argument(
        'input_file',
        type=Path,
        help='Path to .tex or .log file'
    )
    parser.add_argument(
        '--min-badness',
        type=float,
        default=0.0,
        help='Only report overfull boxes exceeding this many pt (default: 0)'
    )
    parser.add_argument(
        '--pages-only',
        action='store_true',
        help='Only list page numbers, one per line'
    )
    parser.add_argument(
        '--json',
        action='store_true',
        help='Output in JSON format'
    )
    parser.add_argument(
        '--vbox-only',
        action='store_true',
        help='Only report overfull vboxes (vertical overflow, content too tall)'
    )
    parser.add_argument(
        '--hbox-only',
        action='store_true',
        help='Only report overfull hboxes (horizontal overflow, content too wide)'
    )

    args = parser.parse_args()

    try:
        log_path = find_log_file(args.input_file)
    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    print(f"Parsing: {log_path}", file=sys.stderr)

    warnings = parse_log_file(log_path)

    # Filter by box type
    if args.vbox_only:
        warnings = [w for w in warnings if w.box_type == 'vbox']
    elif args.hbox_only:
        warnings = [w for w in warnings if w.box_type == 'hbox']

    # Filter by minimum badness
    if args.min_badness > 0:
        warnings = [w for w in warnings if w.badness >= args.min_badness]

    if not warnings:
        print("No overfull boxes found!", file=sys.stderr)
        sys.exit(0)

    if args.json:
        import json
        output = [
            {
                'page': w.page,
                'type': w.box_type,
                'badness_pt': w.badness,
                'source_line': w.source_line,
                'context': w.context
            }
            for w in warnings
        ]
        print(json.dumps(output, indent=2))
        sys.exit(0)

    if args.pages_only:
        pages = sorted(set(w.page for w in warnings if w.page is not None))
        for page in pages:
            print(page)
        sys.exit(0)

    # Default: detailed output grouped by page
    by_page = group_by_page(warnings)

    print(f"\nFound {len(warnings)} overfull box(es) on {len(by_page)} page(s):\n")

    for page in sorted(by_page.keys(), key=lambda x: (x is None, x)):
        page_warnings = by_page[page]
        page_str = f"Page {page}" if page else "Unknown page"
        print(f"{'='*60}")
        print(f"{page_str} ({len(page_warnings)} warning(s))")
        print(f"{'='*60}")

        for w in page_warnings:
            overflow_type = 'wide' if w.box_type == 'hbox' else 'high'
            line_info = f" (source line {w.source_line})" if w.source_line else ""
            print(f"  - Overfull \\{w.box_type}: {w.badness:.1f}pt too {overflow_type}{line_info}")
            if w.context:
                print(f"    Context: {w.context[:80]}{'...' if len(w.context) > 80 else ''}")
        print()


if __name__ == '__main__':
    main()
